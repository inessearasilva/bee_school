{"ast":null,"code":"import objPath from \"object-path\";\nconst replaceValuesJDT = (jdt, composition) => {\n  if (!composition) {\n    // handle the case where composition is undefined or null\n    return jdt;\n  }\n\n  //fazer cópida do jdt\n  let newJDT = {\n    ...jdt\n  };\n  //expressão regular para remover tudo o que esteja na composition para além do itemPath\n  const regex = /((?!value|start|end|date|time|unit).)*/g;\n  //ir buscar todos os itemPaths da composition usando a expressão regular\n  const compositionKeys = Object.keys(composition).map(key => key.match(regex)[0].slice(0, -1));\n  //percorre cada itemPath da composition\n  console.log(\"comp\", composition);\n  //console.log(\"objeto\", Object.keys(composition));\n  for (let index in compositionKeys) {\n    let itemPath = compositionKeys[index];\n    //vai procurar no jdt o itemPath que está na composition\n    let obj = objPath.get(newJDT, itemPath);\n    // se encontrar (ou seja se o objeto for diferente de undefined), faz a substituição pelo valor da composition\n    if (obj !== undefined) {\n      //console.log(\"hello\",obj, itemPath);\n      switch (obj.dataType) {\n        case \"DV_DATE_TIME\":\n          obj.value.date = composition[itemPath.concat('.value.date')];\n          obj.value.time = composition[itemPath.concat('.value.time')];\n          break;\n        case \"DV_DURATION\":\n        case \"DV_QUANTITY\":\n          obj.value.value = composition[itemPath.concat('.value.value')];\n          obj.value.unit = composition[itemPath.concat('.value.unit')];\n          break;\n        case \"DV_INTERVAL<DV_DATE>\":\n        case \"DV_INTERVAL<DV_COUNT>\":\n        case \"DV_INTERVAL<DV_TIME>\":\n          obj.value.start = composition[itemPath.concat('.value.start')];\n          obj.value.end = composition[itemPath.concat('.value.end')];\n          break;\n        case \"DV_INTERVAL<DV_DATE_TIME>\":\n          obj.value.date.start = composition[itemPath.concat('.value.date.start')];\n          obj.value.date.end = composition[itemPath.concat('.value.date.end')];\n          obj.value.time.start = composition[itemPath.concat('.value.time.start')];\n          obj.value.time.end = composition[itemPath.concat('.value.time.end')];\n          break;\n        case \"DV_INTERVAL<DV_QUANTITY>\":\n          obj.value.value.start = composition[itemPath.concat('.value.value.start')];\n          obj.value.value.end = composition[itemPath.concat('.value.value.end')];\n          obj.value.unit = composition[itemPath.concat('.value.unit')];\n          break;\n        default:\n          obj.value = composition[itemPath.concat('.value')];\n      }\n    }\n  }\n  // calculate total score\n  let totalScore = 0;\n  compositionKeys.forEach(itemPath => {\n    const obj = objPath.get(newJDT, itemPath);\n    if (obj !== undefined && obj.dataType === 'DV_ORDINAL') {\n      totalScore += composition[itemPath.concat('.value')];\n    }\n  });\n  // update Total Score item\n  const totalScoreObj = objPath.get(newJDT, '.../.../items[openEHR-EHR-OBSERVATION.symptom_sign_screening_tool.v1]/data/items[at0002]');\n  if (totalScoreObj !== undefined && totalScoreObj.dataType === 'DV_COUNT') {\n    totalScoreObj.value = totalScore;\n  }\n  return newJDT;\n};\nexport { replaceValuesJDT };","map":{"version":3,"names":["objPath","replaceValuesJDT","jdt","composition","newJDT","regex","compositionKeys","Object","keys","map","key","match","slice","console","log","index","itemPath","obj","get","undefined","dataType","value","date","concat","time","unit","start","end","totalScore","forEach","totalScoreObj"],"sources":["C:/Users/ines_/fisiosys/frontend/src/views/dashboard/SavedValues.js"],"sourcesContent":["import objPath from \"object-path\";\r\n\r\nconst replaceValuesJDT = (jdt, composition) => {\r\n    if (!composition) {\r\n        // handle the case where composition is undefined or null\r\n        return jdt;\r\n    }\r\n\r\n    //fazer cópida do jdt\r\n    let newJDT = {...jdt};\r\n    //expressão regular para remover tudo o que esteja na composition para além do itemPath\r\n    const regex = /((?!value|start|end|date|time|unit).)*/g;\r\n    //ir buscar todos os itemPaths da composition usando a expressão regular\r\n    const compositionKeys = Object.keys(composition).map(key=> key.match(regex)[0].slice(0, -1));\r\n    //percorre cada itemPath da composition\r\n    console.log(\"comp\",composition);\r\n    //console.log(\"objeto\", Object.keys(composition));\r\n    for (let index in compositionKeys) {\r\n        let itemPath = compositionKeys[index];\r\n        //vai procurar no jdt o itemPath que está na composition\r\n        let obj = objPath.get(newJDT, itemPath);\r\n        // se encontrar (ou seja se o objeto for diferente de undefined), faz a substituição pelo valor da composition\r\n        if (obj !== undefined) {\r\n            //console.log(\"hello\",obj, itemPath);\r\n            switch(obj.dataType) {\r\n                case \"DV_DATE_TIME\":\r\n                    obj.value.date = composition[itemPath.concat('.value.date')];\r\n                    obj.value.time = composition[itemPath.concat('.value.time')];\r\n                    break;\r\n                case \"DV_DURATION\":\r\n                case \"DV_QUANTITY\":\r\n                    obj.value.value = composition[itemPath.concat('.value.value')];\r\n                    obj.value.unit = composition[itemPath.concat('.value.unit')];\r\n                    break;\r\n                case \"DV_INTERVAL<DV_DATE>\":\r\n                case \"DV_INTERVAL<DV_COUNT>\":\r\n                case \"DV_INTERVAL<DV_TIME>\":\r\n                    obj.value.start = composition[itemPath.concat('.value.start')];\r\n                    obj.value.end = composition[itemPath.concat('.value.end')];\r\n                    break;\r\n                case \"DV_INTERVAL<DV_DATE_TIME>\":\r\n                    obj.value.date.start = composition[itemPath.concat('.value.date.start')];\r\n                    obj.value.date.end = composition[itemPath.concat('.value.date.end')];\r\n                    obj.value.time.start = composition[itemPath.concat('.value.time.start')];\r\n                    obj.value.time.end = composition[itemPath.concat('.value.time.end')];\r\n                    break;\r\n                case \"DV_INTERVAL<DV_QUANTITY>\":\r\n                    obj.value.value.start = composition[itemPath.concat('.value.value.start')];\r\n                    obj.value.value.end = composition[itemPath.concat('.value.value.end')];\r\n                    obj.value.unit = composition[itemPath.concat('.value.unit')];\r\n                    break;\r\n                default:\r\n                    obj.value = composition[itemPath.concat('.value')]\r\n\r\n            }\r\n\r\n        }\r\n    }\r\n    // calculate total score\r\n    let totalScore = 0;\r\n    compositionKeys.forEach((itemPath) => {\r\n    const obj = objPath.get(newJDT, itemPath);\r\n    if (obj !== undefined && obj.dataType === 'DV_ORDINAL') {\r\n        totalScore += composition[itemPath.concat('.value')];\r\n    }\r\n    });\r\n    // update Total Score item\r\n    const totalScoreObj = objPath.get(newJDT, '.../.../items[openEHR-EHR-OBSERVATION.symptom_sign_screening_tool.v1]/data/items[at0002]');\r\n    if (totalScoreObj !== undefined && totalScoreObj.dataType === 'DV_COUNT') {\r\n    totalScoreObj.value = totalScore;\r\n    }\r\n\r\n    return newJDT;\r\n}\r\n\r\nexport { replaceValuesJDT };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}