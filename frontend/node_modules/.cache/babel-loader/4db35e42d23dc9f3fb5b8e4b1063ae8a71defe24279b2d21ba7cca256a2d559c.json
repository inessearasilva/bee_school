{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst extract_1 = __importDefault(require(\"./extract\"));\nconst request_1 = __importDefault(require(\"./request\"));\nconst utils_1 = require(\"./utils\");\n/**\n * sets up options for the fetch request and calls extract on html\n *\n * @param {object} options - options for ogs\n * @return {object} object with ogs results\n *\n */\nasync function setOptionsAndReturnOpenGraphResults(ogsOptions) {\n  const {\n    options\n  } = (0, utils_1.optionSetup)(ogsOptions);\n  if (options.html && options.url) throw new Error('Must specify either `url` or `html`, not both');\n  if (options.html) {\n    const ogObject = (0, extract_1.default)(options.html, options);\n    ogObject.success = true;\n    return {\n      ogObject,\n      response: {\n        body: options.html\n      },\n      html: options.html\n    };\n  }\n  const formattedUrl = (0, utils_1.validateAndFormatURL)(options.url || '', options.urlValidatorSettings || utils_1.defaultUrlValidatorSettings);\n  if (!formattedUrl.url) throw new Error('Invalid URL');\n  options.url = formattedUrl.url;\n  // trying to limit non html pages\n  if ((0, utils_1.isThisANonHTMLUrl)(options.url)) throw new Error('Must scrape an HTML page');\n  // eslint-disable-next-line max-len\n  if (options.blacklist && options.blacklist.some(blacklistedHostname => options.url?.includes(blacklistedHostname))) {\n    throw new Error('Host name has been black listed');\n  }\n  try {\n    const {\n      body,\n      response\n    } = await (0, request_1.default)(options);\n    const ogObject = (0, extract_1.default)(body, options);\n    ogObject.requestUrl = options.url;\n    ogObject.success = true;\n    return {\n      ogObject,\n      response,\n      html: body\n    };\n  } catch (exception) {\n    if (exception && (exception.code === 'ENOTFOUND' || exception.code === 'EHOSTUNREACH' || exception.code === 'ENETUNREACH')) {\n      throw new Error('Page not found');\n    } else if (exception && exception.name === 'AbortError') {\n      throw new Error('The operation was aborted due to timeout');\n    }\n    if (exception instanceof Error) throw exception;\n    throw new Error('Page not found');\n  }\n}\nexports.default = setOptionsAndReturnOpenGraphResults;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","extract_1","require","request_1","utils_1","setOptionsAndReturnOpenGraphResults","ogsOptions","options","optionSetup","html","url","Error","ogObject","default","success","response","body","formattedUrl","validateAndFormatURL","urlValidatorSettings","defaultUrlValidatorSettings","isThisANonHTMLUrl","blacklist","some","blacklistedHostname","includes","requestUrl","exception","code","name"],"sources":["C:/Users/ines_/bee_v2/bee_school/frontend/node_modules/open-graph-scraper/dist/lib/openGraphScraper.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst extract_1 = __importDefault(require(\"./extract\"));\nconst request_1 = __importDefault(require(\"./request\"));\nconst utils_1 = require(\"./utils\");\n/**\n * sets up options for the fetch request and calls extract on html\n *\n * @param {object} options - options for ogs\n * @return {object} object with ogs results\n *\n */\nasync function setOptionsAndReturnOpenGraphResults(ogsOptions) {\n    const { options } = (0, utils_1.optionSetup)(ogsOptions);\n    if (options.html && options.url)\n        throw new Error('Must specify either `url` or `html`, not both');\n    if (options.html) {\n        const ogObject = (0, extract_1.default)(options.html, options);\n        ogObject.success = true;\n        return { ogObject, response: { body: options.html }, html: options.html };\n    }\n    const formattedUrl = (0, utils_1.validateAndFormatURL)(options.url || '', (options.urlValidatorSettings || utils_1.defaultUrlValidatorSettings));\n    if (!formattedUrl.url)\n        throw new Error('Invalid URL');\n    options.url = formattedUrl.url;\n    // trying to limit non html pages\n    if ((0, utils_1.isThisANonHTMLUrl)(options.url))\n        throw new Error('Must scrape an HTML page');\n    // eslint-disable-next-line max-len\n    if (options.blacklist && options.blacklist.some((blacklistedHostname) => options.url?.includes(blacklistedHostname))) {\n        throw new Error('Host name has been black listed');\n    }\n    try {\n        const { body, response } = await (0, request_1.default)(options);\n        const ogObject = (0, extract_1.default)(body, options);\n        ogObject.requestUrl = options.url;\n        ogObject.success = true;\n        return { ogObject, response, html: body };\n    }\n    catch (exception) {\n        if (exception && (exception.code === 'ENOTFOUND' || exception.code === 'EHOSTUNREACH' || exception.code === 'ENETUNREACH')) {\n            throw new Error('Page not found');\n        }\n        else if (exception && (exception.name === 'AbortError')) {\n            throw new Error('The operation was aborted due to timeout');\n        }\n        if (exception instanceof Error)\n            throw exception;\n        throw new Error('Page not found');\n    }\n}\nexports.default = setOptionsAndReturnOpenGraphResults;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}