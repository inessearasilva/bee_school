{"ast":null,"code":"import _toConsumableArray from \"C:/Users/ines_/fisiosys/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/Users/ines_/fisiosys/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar handleSubForm = function handleSubForm(path, subForm) {\n  var value = undefined;\n  subForm.forEach(function (obj) {\n    Object.keys(obj.values).forEach(function (p) {\n      var newp = p.split(\".\").join(\"-\"); // Vejo se é o campo em questão\n\n      if (newp === path) {\n        // Verifico o valor se o campo ainda está a undefined\n        // Ao voltar do subForm, os valores vêm limpos no handleSubmit, ou seja, não há editorState, arrays com campos vazios, etc. => o que tiver vazio vem a null\n        if (value === undefined) {\n          // Só quero atualizar se o valor do campo não estiver a null, senão não me interessa e fica como está\n          if (obj.values[p] !== null) {\n            // Ponho um valor qualquer para dizer que está definido => assim não precisa de ver se é array, editorState, etc.\n            value = \"defined\";\n          }\n        }\n      } else if (Array.isArray(obj.values[p])) {\n        var newSubform = obj.values[p];\n        if (newSubform.length > 0) {\n          if (newSubform[0].id) {\n            // Vou verificar se não será outro subForm o path em questão\n            value = handleSubForm(path, newSubform); // Volto a fazer o mesmo processo\n          }\n        }\n      }\n    });\n  });\n\n  return value;\n};\nvar getFieldValue = function getFieldValue(values, path, subForms) {\n  var value = values[path]; // Verificar se está no subform\n\n  if (value === undefined) {\n    subForms.forEach(function (obj) {\n      obj.values.forEach(function (section) {\n        Object.keys(section.values).forEach(function (p) {\n          var newp = p.split(\".\").join(\"-\"); // Vejo se é o campo em questão\n\n          if (newp === path) {\n            // Verifico o valor se o campo ainda está a undefined\n            // Ao voltar do subForm, os valores vêm limpos no handleSubmit, ou seja, não há editorState, arrays com campos vazios, etc. => o que tiver vazio vem a null\n            if (value === undefined) {\n              // Só quero atualizar se o valor do campo não estiver a null, senão não me interessa e fica como está\n              if (section.values[p] !== null) {\n                // Ponho um valor qualquer para dizer que está definido => assim não precisa de ver se é array, editorState, etc.\n                value = \"defined\";\n              }\n            }\n          } else if (Array.isArray(section.values[p])) {\n            var newSubform = section.values[p];\n            if (newSubform.length > 0) {\n              if (newSubform[0].id) {\n                // Vou verificar se não será outro subForm o path em questão\n                value = handleSubForm(path, newSubform); // Verifico o subform\n              }\n            }\n          }\n        });\n      });\n    });\n  }\n\n  return value;\n};\nvar handleRequiredSection = function handleRequiredSection(objectValidation, pathLabel, values, multipleSections) {\n  var arrayFieldValues = [];\n  var sectionsError = [];\n  var object = _objectSpread({}, objectValidation);\n  if (Object.keys(object).length !== 0) {\n    for (var i = 0; i < Object.keys(object).length; i++) {\n      var key = Object.keys(object)[i];\n      var array = object[key];\n      if (array.indexOf(pathLabel) > -1) {\n        var fieldValues = [];\n        var arrayPaths = _toConsumableArray(array);\n        arrayPaths.pop();\n        arrayPaths.pop();\n        for (var j = 0; j < arrayPaths.length; j++) {\n          var path = arrayPaths[j];\n          var obtainedValue = getFieldValue(values, path, multipleSections);\n          fieldValues.push(obtainedValue); // Antigamento quando não precessava dentro de subsecções\n          //fieldValues.push(values[path]);\n        }\n\n        arrayFieldValues.push([].concat(fieldValues, [array[array.length - 2], array[array.length - 1]]));\n      }\n    }\n    if (arrayFieldValues.length !== 0) {\n      arrayFieldValues.forEach(function (array) {\n        var arrayPaths = _toConsumableArray(array);\n        arrayPaths.pop();\n        arrayPaths.pop();\n        if (arrayPaths.filter(function (value) {\n          if (value !== undefined) {\n            if (Array.isArray(value)) {\n              var textIds = value.filter(function (obj) {\n                return obj.textId !== undefined;\n              });\n              var identifierIds = value.filter(function (obj) {\n                return obj.identifierId !== undefined;\n              });\n              if (textIds.length > 0) {\n                var writtenFields = value.filter(function (obj) {\n                  return obj.value.getCurrentContent().hasText();\n                });\n                if (writtenFields.length > 0) {\n                  return true;\n                }\n                return false;\n              } else if (identifierIds.length > 0) {\n                var writtenIdentifiers = value.filter(function (obj) {\n                  return obj.value !== \"\";\n                });\n                if (writtenIdentifiers.length > 0) {\n                  return true;\n                }\n                return false;\n              } else {\n                if (value.length > 0) {\n                  return true;\n                }\n                return false;\n              }\n            } else if (value._immutable !== undefined) {\n              if (value.getCurrentContent().hasText()) {\n                return true;\n              }\n              return false;\n            }\n            return true;\n          }\n          return false;\n        }).length < array[array.length - 1]) {\n          var textError = array[array.length - 2] + \" (Número de campos a preencher: \" + array[array.length - 1] + \")\";\n          sectionsError.push(textError);\n        }\n      });\n      if (sectionsError.length >= 1) {\n        return sectionsError;\n      }\n      return true;\n    }\n    return true;\n  }\n  return true;\n};\nexport { handleRequiredSection };","map":{"version":3,"names":["handleSubForm","path","subForm","value","undefined","forEach","obj","Object","keys","values","p","newp","split","join","Array","isArray","newSubform","length","id","getFieldValue","subForms","section","handleRequiredSection","objectValidation","pathLabel","multipleSections","arrayFieldValues","sectionsError","object","i","key","array","indexOf","fieldValues","arrayPaths","pop","j","obtainedValue","push","filter","textIds","textId","identifierIds","identifierId","writtenFields","getCurrentContent","hasText","writtenIdentifiers","_immutable","textError"],"sources":["C:/Users/ines_/fisiosys/frontend/node_modules/protected-aidaforms/dist/assets/functions/HandleSectionValidation/handleRequiredSection.js"],"sourcesContent":["const handleSubForm = (path, subForm) => {\r\n  let value = undefined;\r\n  subForm.forEach(obj => {\r\n    Object.keys(obj.values).forEach(p => {\r\n      const newp = p.split(\".\").join(\"-\"); // Vejo se é o campo em questão\r\n\r\n      if (newp === path) {\r\n        // Verifico o valor se o campo ainda está a undefined\r\n        // Ao voltar do subForm, os valores vêm limpos no handleSubmit, ou seja, não há editorState, arrays com campos vazios, etc. => o que tiver vazio vem a null\r\n        if (value === undefined) {\r\n          // Só quero atualizar se o valor do campo não estiver a null, senão não me interessa e fica como está\r\n          if (obj.values[p] !== null) {\r\n            // Ponho um valor qualquer para dizer que está definido => assim não precisa de ver se é array, editorState, etc.\r\n            value = \"defined\";\r\n          }\r\n        }\r\n      } else if (Array.isArray(obj.values[p])) {\r\n        const newSubform = obj.values[p];\r\n\r\n        if (newSubform.length > 0) {\r\n          if (newSubform[0].id) {\r\n            // Vou verificar se não será outro subForm o path em questão\r\n            value = handleSubForm(path, newSubform); // Volto a fazer o mesmo processo\r\n          }\r\n        }\r\n      }\r\n    });\r\n  });\r\n  return value;\r\n};\r\n\r\nconst getFieldValue = (values, path, subForms) => {\r\n  let value = values[path]; // Verificar se está no subform\r\n\r\n  if (value === undefined) {\r\n    subForms.forEach(obj => {\r\n      obj.values.forEach(section => {\r\n        Object.keys(section.values).forEach(p => {\r\n          const newp = p.split(\".\").join(\"-\"); // Vejo se é o campo em questão\r\n\r\n          if (newp === path) {\r\n            // Verifico o valor se o campo ainda está a undefined\r\n            // Ao voltar do subForm, os valores vêm limpos no handleSubmit, ou seja, não há editorState, arrays com campos vazios, etc. => o que tiver vazio vem a null\r\n            if (value === undefined) {\r\n              // Só quero atualizar se o valor do campo não estiver a null, senão não me interessa e fica como está\r\n              if (section.values[p] !== null) {\r\n                // Ponho um valor qualquer para dizer que está definido => assim não precisa de ver se é array, editorState, etc.\r\n                value = \"defined\";\r\n              }\r\n            }\r\n          } else if (Array.isArray(section.values[p])) {\r\n            const newSubform = section.values[p];\r\n\r\n            if (newSubform.length > 0) {\r\n              if (newSubform[0].id) {\r\n                // Vou verificar se não será outro subForm o path em questão\r\n                value = handleSubForm(path, newSubform); // Verifico o subform\r\n              }\r\n            }\r\n          }\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  return value;\r\n};\r\n\r\nconst handleRequiredSection = (objectValidation, pathLabel, values, multipleSections) => {\r\n  let arrayFieldValues = [];\r\n  let sectionsError = [];\r\n  let object = { ...objectValidation\r\n  };\r\n\r\n  if (Object.keys(object).length !== 0) {\r\n    for (let i = 0; i < Object.keys(object).length; i++) {\r\n      let key = Object.keys(object)[i];\r\n      let array = object[key];\r\n\r\n      if (array.indexOf(pathLabel) > -1) {\r\n        let fieldValues = [];\r\n        let arrayPaths = [...array];\r\n        arrayPaths.pop();\r\n        arrayPaths.pop();\r\n\r\n        for (let j = 0; j < arrayPaths.length; j++) {\r\n          let path = arrayPaths[j];\r\n          const obtainedValue = getFieldValue(values, path, multipleSections);\r\n          fieldValues.push(obtainedValue); // Antigamento quando não precessava dentro de subsecções\r\n          //fieldValues.push(values[path]);\r\n        }\r\n\r\n        arrayFieldValues.push([...fieldValues, array[array.length - 2], array[array.length - 1]]);\r\n      }\r\n    }\r\n\r\n    if (arrayFieldValues.length !== 0) {\r\n      arrayFieldValues.forEach(function (array) {\r\n        let arrayPaths = [...array];\r\n        arrayPaths.pop();\r\n        arrayPaths.pop();\r\n\r\n        if (arrayPaths.filter(function (value) {\r\n          if (value !== undefined) {\r\n            if (Array.isArray(value)) {\r\n              let textIds = value.filter(obj => obj.textId !== undefined);\r\n              let identifierIds = value.filter(obj => obj.identifierId !== undefined);\r\n\r\n              if (textIds.length > 0) {\r\n                let writtenFields = value.filter(obj => obj.value.getCurrentContent().hasText());\r\n\r\n                if (writtenFields.length > 0) {\r\n                  return true;\r\n                }\r\n\r\n                return false;\r\n              } else if (identifierIds.length > 0) {\r\n                let writtenIdentifiers = value.filter(obj => obj.value !== \"\");\r\n\r\n                if (writtenIdentifiers.length > 0) {\r\n                  return true;\r\n                }\r\n\r\n                return false;\r\n              } else {\r\n                if (value.length > 0) {\r\n                  return true;\r\n                }\r\n\r\n                return false;\r\n              }\r\n            } else if (value._immutable !== undefined) {\r\n              if (value.getCurrentContent().hasText()) {\r\n                return true;\r\n              }\r\n\r\n              return false;\r\n            }\r\n\r\n            return true;\r\n          }\r\n\r\n          return false;\r\n        }).length < array[array.length - 1]) {\r\n          const textError = array[array.length - 2] + \" (Número de campos a preencher: \" + array[array.length - 1] + \")\";\r\n          sectionsError.push(textError);\r\n        }\r\n      });\r\n\r\n      if (sectionsError.length >= 1) {\r\n        return sectionsError;\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nexport { handleRequiredSection };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}