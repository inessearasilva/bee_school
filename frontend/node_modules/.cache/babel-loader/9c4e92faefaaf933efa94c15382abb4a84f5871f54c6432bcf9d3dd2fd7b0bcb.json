{"ast":null,"code":"'use strict';\n\nconst {\n  redirectStatus,\n  badPorts,\n  referrerPolicy: referrerPolicyTokens\n} = require('./constants');\nconst {\n  getGlobalOrigin\n} = require('./global');\nconst {\n  performance\n} = require('perf_hooks');\nconst {\n  isBlobLike,\n  toUSVString,\n  ReadableStreamFrom\n} = require('../core/util');\nconst assert = require('assert');\nconst {\n  isUint8Array\n} = require('util/types');\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */\nlet crypto;\ntry {\n  crypto = require('crypto');\n} catch {}\nfunction responseURL(response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList;\n  const length = urlList.length;\n  return length === 0 ? null : urlList[length - 1].toString();\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL(response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatus.includes(response.status)) {\n    return null;\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location');\n\n  // 3. If location is a header value, then set location to the result of\n  //    parsing location with response’s URL.\n  if (location !== null && isValidHeaderValue(location)) {\n    location = new URL(location, responseURL(response));\n  }\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment;\n  }\n\n  // 5. Return location.\n  return location;\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL(request) {\n  return request.urlList[request.urlList.length - 1];\n}\nfunction requestBadPort(request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request);\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (urlIsHttpHttpsScheme(url) && badPorts.includes(url.port)) {\n    return 'blocked';\n  }\n\n  // 3. Return allowed.\n  return 'allowed';\n}\nfunction isErrorLike(object) {\n  return object instanceof Error || object?.constructor?.name === 'Error' || object?.constructor?.name === 'DOMException';\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase(statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i);\n    if (!(c === 0x09 ||\n    // HTAB\n    c >= 0x20 && c <= 0x7e ||\n    // SP / VCHAR\n    c >= 0x80 && c <= 0xff\n    // obs-text\n    )) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isTokenChar(c) {\n  return !(c >= 0x7f || c <= 0x20 || c === '(' || c === ')' || c === '<' || c === '>' || c === '@' || c === ',' || c === ';' || c === ':' || c === '\\\\' || c === '\"' || c === '/' || c === '[' || c === ']' || c === '?' || c === '=' || c === '{' || c === '}');\n}\n\n// See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\nfunction isValidHTTPToken(characters) {\n  if (!characters || typeof characters !== 'string') {\n    return false;\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    const c = characters.charCodeAt(i);\n    if (c > 0x7f || !isTokenChar(c)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// https://fetch.spec.whatwg.org/#header-name\n// https://github.com/chromium/chromium/blob/b3d37e6f94f87d59e44662d6078f6a12de845d17/net/http/http_util.cc#L342\nfunction isValidHeaderName(potentialValue) {\n  if (potentialValue.length === 0) {\n    return false;\n  }\n  return isValidHTTPToken(potentialValue);\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue(potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  if (potentialValue.startsWith('\\t') || potentialValue.startsWith(' ') || potentialValue.endsWith('\\t') || potentialValue.endsWith(' ')) {\n    return false;\n  }\n  if (potentialValue.includes('\\0') || potentialValue.includes('\\r') || potentialValue.includes('\\n')) {\n    return false;\n  }\n  return true;\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect(request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n\n  // 8.1 Parse a referrer policy from a Referrer-Policy header\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n  const {\n    headersList\n  } = actualResponse;\n  // 2. Let policy be the empty string.\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n  // 4. Return policy.\n  const policyHeader = (headersList.get('referrer-policy') ?? '').split(',');\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  let policy = '';\n  if (policyHeader.length > 0) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim();\n      if (referrerPolicyTokens.includes(token)) {\n        policy = token;\n        break;\n      }\n    }\n  }\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy;\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck() {\n  // TODO\n  return 'allowed';\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck() {\n  // TODO\n  return 'success';\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck() {\n  // TODO\n  return 'success';\n}\nfunction appendFetchMetadata(httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null;\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode;\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header);\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader(request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin;\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('origin', serializedOrigin);\n    }\n\n    // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null;\n        break;\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n          serializedOrigin = null;\n        }\n        break;\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null;\n        }\n        break;\n      default:\n      // Do nothing.\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('origin', serializedOrigin);\n    }\n  }\n}\nfunction coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now();\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo(timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  };\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer() {\n  // Note: the fetch spec doesn't make use of embedder policy or CSP list\n  return {\n    referrerPolicy: 'strict-origin-when-cross-origin'\n  };\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer(policyContainer) {\n  return {\n    referrerPolicy: policyContainer.referrerPolicy\n  };\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer(request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy;\n\n  // Note: policy cannot (shouldn't) be null or an empty string.\n  assert(policy);\n\n  // 2. Let environment be request’s client.\n\n  let referrerSource = null;\n\n  // 3. Switch on request’s referrer:\n  if (request.referrer === 'client') {\n    // Note: node isn't a browser and doesn't implement document/iframes,\n    // so we bypass this step and replace it with our own.\n\n    const globalOrigin = getGlobalOrigin();\n    if (!globalOrigin || globalOrigin.origin === 'null') {\n      return 'no-referrer';\n    }\n\n    // note: we need to clone it as it's mutated\n    referrerSource = new URL(globalOrigin);\n  } else if (request.referrer instanceof URL) {\n    // Let referrerSource be request’s referrer.\n    referrerSource = request.referrer;\n  }\n\n  // 4. Let request’s referrerURL be the result of stripping referrerSource for\n  //    use as a referrer.\n  let referrerURL = stripURLForReferrer(referrerSource);\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n  //    a referrer, with the origin-only flag set to true.\n  const referrerOrigin = stripURLForReferrer(referrerSource, true);\n\n  // 6. If the result of serializing referrerURL is a string whose length is\n  //    greater than 4096, set referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin;\n  }\n  const areSameOrigin = sameOrigin(request, referrerURL);\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);\n\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin':\n      return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);\n    case 'unsafe-url':\n      return referrerURL;\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer';\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerURL : referrerOrigin;\n    case 'strict-origin-when-cross-origin':\n      {\n        const currentURL = requestCurrentURL(request);\n\n        // 1. If the origin of referrerURL and the origin of request’s current\n        //    URL are the same, then return referrerURL.\n        if (sameOrigin(referrerURL, currentURL)) {\n          return referrerURL;\n        }\n\n        // 2. If referrerURL is a potentially trustworthy URL and request’s\n        //    current URL is not a potentially trustworthy URL, then return no\n        //    referrer.\n        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n          return 'no-referrer';\n        }\n\n        // 3. Return referrerOrigin.\n        return referrerOrigin;\n      }\n    case 'strict-origin': // eslint-disable-line\n    /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n    /**\n     * 1. If referrerURL is a potentially trustworthy URL and\n     * request’s current URL is not a potentially trustworthy URL,\n     * then return no referrer.\n     * 2. Return referrerOrigin\n    */\n\n    default:\n      // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin;\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */\nfunction stripURLForReferrer(url, originOnly) {\n  // 1. Assert: url is a URL.\n  assert(url instanceof URL);\n\n  // 2. If url’s scheme is a local scheme, then return no referrer.\n  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {\n    return 'no-referrer';\n  }\n\n  // 3. Set url’s username to the empty string.\n  url.username = '';\n\n  // 4. Set url’s password to the empty string.\n  url.password = '';\n\n  // 5. Set url’s fragment to null.\n  url.hash = '';\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly) {\n    // 1. Set url’s path to « the empty string ».\n    url.pathname = '';\n\n    // 2. Set url’s query to null.\n    url.search = '';\n  }\n\n  // 7. Return url.\n  return url;\n}\nfunction isURLPotentiallyTrustworthy(url) {\n  if (!(url instanceof URL)) {\n    return false;\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true;\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true;\n\n  // If file, return true\n  if (url.protocol === 'file:') return true;\n  return isOriginPotentiallyTrustworthy(url.origin);\n  function isOriginPotentiallyTrustworthy(origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false;\n    const originAsURL = new URL(origin);\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true;\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) || originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.') || originAsURL.hostname.endsWith('.localhost')) {\n      return true;\n    }\n\n    // If any other, return false\n    return false;\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch(bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true;\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList);\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true;\n  }\n\n  // 3. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true;\n  }\n\n  // 4. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));\n  // get the strongest algorithm\n  const strongest = list[0].algo;\n  // get all entries that use the strongest algorithm; ignore weaker\n  const metadata = list.filter(item => item.algo === strongest);\n\n  // 5. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo;\n\n    // 2. Let expectedValue be the val component of item.\n    const expectedValue = item.hash;\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    const actualValue = crypto.createHash(algorithm).update(bytes).digest('base64');\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (actualValue === expectedValue) {\n      return true;\n    }\n  }\n\n  // 6. Return false.\n  return false;\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\\x21-\\x7e]?)?/i;\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata(metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = [];\n\n  // 2. Let empty be equal to true.\n  let empty = true;\n  const supportedHashes = crypto.getHashes();\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false;\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token);\n\n    // 3. If token does not parse, continue to the next token.\n    if (parsedToken === null || parsedToken.groups === undefined) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue;\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo;\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm.toLowerCase())) {\n      result.push(parsedToken.groups);\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata';\n  }\n  return result;\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin(A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  if (A.origin === B.origin && A.origin === 'null') {\n    return true;\n  }\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true;\n  }\n\n  // 3. Return false.\n  return false;\n}\nfunction createDeferredPromise() {\n  let res;\n  let rej;\n  const promise = new Promise((resolve, reject) => {\n    res = resolve;\n    rej = reject;\n  });\n  return {\n    promise,\n    resolve: res,\n    reject: rej\n  };\n}\nfunction isAborted(fetchParams) {\n  return fetchParams.controller.state === 'aborted';\n}\nfunction isCancelled(fetchParams) {\n  return fetchParams.controller.state === 'aborted' || fetchParams.controller.state === 'terminated';\n}\n\n// https://fetch.spec.whatwg.org/#concept-method-normalize\nfunction normalizeMethod(method) {\n  return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString(value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value);\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable');\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string');\n\n  // 4. Return result.\n  return result;\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {() => unknown[]} iterator\n * @param {string} name name of the instance\n * @param {'key'|'value'|'key+value'} kind\n */\nfunction makeIterator(iterator, name, kind) {\n  const object = {\n    index: 0,\n    kind,\n    target: iterator\n  };\n  const i = {\n    next() {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n\n      // 2. Let thisValue be the this value.\n\n      // 3. Let object be ? ToObject(thisValue).\n\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (Object.getPrototypeOf(this) !== i) {\n        throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);\n      }\n\n      // 6. Let index be object’s index.\n      // 7. Let kind be object’s kind.\n      // 8. Let values be object’s target's value pairs to iterate over.\n      const {\n        index,\n        kind,\n        target\n      } = object;\n      const values = target();\n\n      // 9. Let len be the length of values.\n      const len = values.length;\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const pair = values[index];\n\n      // 12. Set object’s index to index + 1.\n      object.index = index + 1;\n\n      // 13. Return the iterator result for pair and kind.\n      return iteratorResult(pair, kind);\n    },\n    // The class string of an iterator prototype object for a given interface is the\n    // result of concatenating the identifier of the interface and the string \" Iterator\".\n    [Symbol.toStringTag]: `${name} Iterator`\n  };\n\n  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n  Object.setPrototypeOf(i, esIteratorPrototype);\n  // esIteratorPrototype needs to be the prototype of i\n  // which is the prototype of an empty object. Yes, it's confusing.\n  return Object.setPrototypeOf({}, i);\n}\n\n// https://webidl.spec.whatwg.org/#iterator-result\nfunction iteratorResult(pair, kind) {\n  let result;\n\n  // 1. Let result be a value determined by the value of kind:\n  switch (kind) {\n    case 'key':\n      {\n        // 1. Let idlKey be pair’s key.\n        // 2. Let key be the result of converting idlKey to an\n        //    ECMAScript value.\n        // 3. result is key.\n        result = pair[0];\n        break;\n      }\n    case 'value':\n      {\n        // 1. Let idlValue be pair’s value.\n        // 2. Let value be the result of converting idlValue to\n        //    an ECMAScript value.\n        // 3. result is value.\n        result = pair[1];\n        break;\n      }\n    case 'key+value':\n      {\n        // 1. Let idlKey be pair’s key.\n        // 2. Let idlValue be pair’s value.\n        // 3. Let key be the result of converting idlKey to an\n        //    ECMAScript value.\n        // 4. Let value be the result of converting idlValue to\n        //    an ECMAScript value.\n        // 5. Let array be ! ArrayCreate(2).\n        // 6. Call ! CreateDataProperty(array, \"0\", key).\n        // 7. Call ! CreateDataProperty(array, \"1\", value).\n        // 8. result is array.\n        result = pair;\n        break;\n      }\n  }\n\n  // 2. Return CreateIterResultObject(result, false).\n  return {\n    value: result,\n    done: false\n  };\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nfunction fullyReadBody(body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = bytes => queueMicrotask(() => processBody(bytes));\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = error => queueMicrotask(() => processBodyError(error));\n\n  // 4. Let reader be the result of getting a reader for body’s stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n  let reader;\n  try {\n    reader = body.stream.getReader();\n  } catch (e) {\n    errorSteps(e);\n    return;\n  }\n\n  // 5. Read all bytes from reader, given successSteps and errorSteps.\n  readAllBytes(reader, successSteps, errorSteps);\n}\n\n/** @type {ReadableStream} */\nlet ReadableStream = globalThis.ReadableStream;\nfunction isReadableStreamLike(stream) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream;\n  }\n  return stream instanceof ReadableStream || stream[Symbol.toStringTag] === 'ReadableStream' && typeof stream.tee === 'function';\n}\nconst MAXIMUM_ARGUMENT_LENGTH = 65535;\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {number[]|Uint8Array} input\n */\nfunction isomorphicDecode(input) {\n  // 1. To isomorphic decode a byte sequence input, return a string whose code point\n  //    length is equal to input’s length and whose code points have the same values\n  //    as the values of input’s bytes, in the same order.\n\n  if (input.length < MAXIMUM_ARGUMENT_LENGTH) {\n    return String.fromCharCode(...input);\n  }\n  return input.reduce((previous, current) => previous + String.fromCharCode(current), '');\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose(controller) {\n  try {\n    controller.close();\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed')) {\n      throw err;\n    }\n  }\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode(input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  for (let i = 0; i < input.length; i++) {\n    assert(input.charCodeAt(i) <= 0xFF);\n  }\n\n  // 2. Return a byte sequence whose length is equal to input’s code\n  //    point length and whose bytes have the same values as the\n  //    values of input’s code points, in the same order\n  return input;\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n * @param {(bytes: Uint8Array) => void} successSteps\n * @param {(error: Error) => void} failureSteps\n */\nasync function readAllBytes(reader, successSteps, failureSteps) {\n  const bytes = [];\n  let byteLength = 0;\n  while (true) {\n    let done;\n    let chunk;\n    try {\n      ({\n        done,\n        value: chunk\n      } = await reader.read());\n    } catch (e) {\n      // 1. Call failureSteps with e.\n      failureSteps(e);\n      return;\n    }\n    if (done) {\n      // 1. Call successSteps with bytes.\n      successSteps(Buffer.concat(bytes, byteLength));\n      return;\n    }\n\n    // 1. If chunk is not a Uint8Array object, call failureSteps\n    //    with a TypeError and abort these steps.\n    if (!isUint8Array(chunk)) {\n      failureSteps(new TypeError('Received non-Uint8Array chunk'));\n      return;\n    }\n\n    // 2. Append the bytes represented by chunk to bytes.\n    bytes.push(chunk);\n    byteLength += chunk.length;\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */\nfunction urlIsLocal(url) {\n  assert('protocol' in url); // ensure it's a url object\n\n  const protocol = url.protocol;\n  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:';\n}\n\n/**\n * @param {string|URL} url\n */\nfunction urlHasHttpsScheme(url) {\n  if (typeof url === 'string') {\n    return url.startsWith('https:');\n  }\n  return url.protocol === 'https:';\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */\nfunction urlIsHttpHttpsScheme(url) {\n  assert('protocol' in url); // ensure it's a url object\n\n  const protocol = url.protocol;\n  return protocol === 'http:' || protocol === 'https:';\n}\n\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */\nconst hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  toUSVString,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  hasOwn,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch,\n  isReadableStreamLike,\n  readableStreamClose,\n  isomorphicEncode,\n  isomorphicDecode,\n  urlIsLocal,\n  urlHasHttpsScheme,\n  urlIsHttpHttpsScheme,\n  readAllBytes\n};","map":{"version":3,"names":["redirectStatus","badPorts","referrerPolicy","referrerPolicyTokens","require","getGlobalOrigin","performance","isBlobLike","toUSVString","ReadableStreamFrom","assert","isUint8Array","crypto","responseURL","response","urlList","length","toString","responseLocationURL","requestFragment","includes","status","location","headersList","get","isValidHeaderValue","URL","hash","requestCurrentURL","request","requestBadPort","url","urlIsHttpHttpsScheme","port","isErrorLike","object","Error","constructor","name","isValidReasonPhrase","statusText","i","c","charCodeAt","isTokenChar","isValidHTTPToken","characters","isValidHeaderName","potentialValue","startsWith","endsWith","setRequestReferrerPolicyOnRedirect","actualResponse","policyHeader","split","policy","token","trim","crossOriginResourcePolicyCheck","corsCheck","TAOCheck","appendFetchMetadata","httpRequest","header","mode","set","appendRequestOriginHeader","serializedOrigin","origin","responseTainting","append","method","urlHasHttpsScheme","sameOrigin","coarsenedSharedCurrentTime","crossOriginIsolatedCapability","now","createOpaqueTimingInfo","timingInfo","startTime","redirectStartTime","redirectEndTime","postRedirectStartTime","finalServiceWorkerStartTime","finalNetworkResponseStartTime","finalNetworkRequestStartTime","endTime","encodedBodySize","decodedBodySize","finalConnectionTimingInfo","makePolicyContainer","clonePolicyContainer","policyContainer","determineRequestsReferrer","referrerSource","referrer","globalOrigin","referrerURL","stripURLForReferrer","referrerOrigin","areSameOrigin","isNonPotentiallyTrustWorthy","isURLPotentiallyTrustworthy","currentURL","originOnly","protocol","username","password","pathname","search","href","isOriginPotentiallyTrustworthy","originAsURL","test","hostname","bytesMatch","bytes","metadataList","undefined","parsedMetadata","parseMetadata","list","sort","d","algo","localeCompare","strongest","metadata","filter","item","algorithm","expectedValue","actualValue","createHash","update","digest","parseHashWithOptions","result","empty","supportedHashes","getHashes","parsedToken","exec","groups","toLowerCase","push","tryUpgradeRequestToAPotentiallyTrustworthyURL","A","B","createDeferredPromise","res","rej","promise","Promise","resolve","reject","isAborted","fetchParams","controller","state","isCancelled","normalizeMethod","toUpperCase","serializeJavascriptValueToJSONString","value","JSON","stringify","TypeError","esIteratorPrototype","Object","getPrototypeOf","Symbol","iterator","makeIterator","kind","index","target","next","values","len","done","pair","iteratorResult","toStringTag","setPrototypeOf","fullyReadBody","body","processBody","processBodyError","successSteps","queueMicrotask","errorSteps","error","reader","stream","getReader","e","readAllBytes","ReadableStream","globalThis","isReadableStreamLike","tee","MAXIMUM_ARGUMENT_LENGTH","isomorphicDecode","input","String","fromCharCode","reduce","previous","current","readableStreamClose","close","err","message","isomorphicEncode","failureSteps","byteLength","chunk","read","Buffer","concat","urlIsLocal","hasOwn","dict","key","prototype","hasOwnProperty","call","module","exports"],"sources":["C:/Users/ines_/bee_v2/bee_school/frontend/node_modules/undici/lib/fetch/util.js"],"sourcesContent":["'use strict'\n\nconst { redirectStatus, badPorts, referrerPolicy: referrerPolicyTokens } = require('./constants')\nconst { getGlobalOrigin } = require('./global')\nconst { performance } = require('perf_hooks')\nconst { isBlobLike, toUSVString, ReadableStreamFrom } = require('../core/util')\nconst assert = require('assert')\nconst { isUint8Array } = require('util/types')\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */\nlet crypto\n\ntry {\n  crypto = require('crypto')\n} catch {\n\n}\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatus.includes(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location')\n\n  // 3. If location is a header value, then set location to the result of\n  //    parsing location with response’s URL.\n  if (location !== null && isValidHeaderValue(location)) {\n    location = new URL(location, responseURL(response))\n  }\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (urlIsHttpHttpsScheme(url) && badPorts.includes(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isErrorLike (object) {\n  return object instanceof Error || (\n    object?.constructor?.name === 'Error' ||\n    object?.constructor?.name === 'DOMException'\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isTokenChar (c) {\n  return !(\n    c >= 0x7f ||\n    c <= 0x20 ||\n    c === '(' ||\n    c === ')' ||\n    c === '<' ||\n    c === '>' ||\n    c === '@' ||\n    c === ',' ||\n    c === ';' ||\n    c === ':' ||\n    c === '\\\\' ||\n    c === '\"' ||\n    c === '/' ||\n    c === '[' ||\n    c === ']' ||\n    c === '?' ||\n    c === '=' ||\n    c === '{' ||\n    c === '}'\n  )\n}\n\n// See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\nfunction isValidHTTPToken (characters) {\n  if (!characters || typeof characters !== 'string') {\n    return false\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    const c = characters.charCodeAt(i)\n    if (c > 0x7f || !isTokenChar(c)) {\n      return false\n    }\n  }\n  return true\n}\n\n// https://fetch.spec.whatwg.org/#header-name\n// https://github.com/chromium/chromium/blob/b3d37e6f94f87d59e44662d6078f6a12de845d17/net/http/http_util.cc#L342\nfunction isValidHeaderName (potentialValue) {\n  if (potentialValue.length === 0) {\n    return false\n  }\n\n  return isValidHTTPToken(potentialValue)\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue (potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  if (\n    potentialValue.startsWith('\\t') ||\n    potentialValue.startsWith(' ') ||\n    potentialValue.endsWith('\\t') ||\n    potentialValue.endsWith(' ')\n  ) {\n    return false\n  }\n\n  if (\n    potentialValue.includes('\\0') ||\n    potentialValue.includes('\\r') ||\n    potentialValue.includes('\\n')\n  ) {\n    return false\n  }\n\n  return true\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n\n  // 8.1 Parse a referrer policy from a Referrer-Policy header\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n  const { headersList } = actualResponse\n  // 2. Let policy be the empty string.\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n  // 4. Return policy.\n  const policyHeader = (headersList.get('referrer-policy') ?? '').split(',')\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  let policy = ''\n  if (policyHeader.length > 0) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim()\n      if (referrerPolicyTokens.includes(token)) {\n        policy = token\n        break\n      }\n    }\n  }\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('origin', serializedOrigin)\n    }\n\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('origin', serializedOrigin)\n    }\n  }\n}\n\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now()\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // Note: the fetch spec doesn't make use of embedder policy or CSP list\n  return {\n    referrerPolicy: 'strict-origin-when-cross-origin'\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer (policyContainer) {\n  return {\n    referrerPolicy: policyContainer.referrerPolicy\n  }\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer (request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy\n\n  // Note: policy cannot (shouldn't) be null or an empty string.\n  assert(policy)\n\n  // 2. Let environment be request’s client.\n\n  let referrerSource = null\n\n  // 3. Switch on request’s referrer:\n  if (request.referrer === 'client') {\n    // Note: node isn't a browser and doesn't implement document/iframes,\n    // so we bypass this step and replace it with our own.\n\n    const globalOrigin = getGlobalOrigin()\n\n    if (!globalOrigin || globalOrigin.origin === 'null') {\n      return 'no-referrer'\n    }\n\n    // note: we need to clone it as it's mutated\n    referrerSource = new URL(globalOrigin)\n  } else if (request.referrer instanceof URL) {\n    // Let referrerSource be request’s referrer.\n    referrerSource = request.referrer\n  }\n\n  // 4. Let request’s referrerURL be the result of stripping referrerSource for\n  //    use as a referrer.\n  let referrerURL = stripURLForReferrer(referrerSource)\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n  //    a referrer, with the origin-only flag set to true.\n  const referrerOrigin = stripURLForReferrer(referrerSource, true)\n\n  // 6. If the result of serializing referrerURL is a string whose length is\n  //    greater than 4096, set referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin\n  }\n\n  const areSameOrigin = sameOrigin(request, referrerURL)\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) &&\n    !isURLPotentiallyTrustworthy(request.url)\n\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin': return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true)\n    case 'unsafe-url': return referrerURL\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer'\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerURL : referrerOrigin\n    case 'strict-origin-when-cross-origin': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If the origin of referrerURL and the origin of request’s current\n      //    URL are the same, then return referrerURL.\n      if (sameOrigin(referrerURL, currentURL)) {\n        return referrerURL\n      }\n\n      // 2. If referrerURL is a potentially trustworthy URL and request’s\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n\n      // 3. Return referrerOrigin.\n      return referrerOrigin\n    }\n    case 'strict-origin': // eslint-disable-line\n      /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * request’s current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n      /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n\n    default: // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */\nfunction stripURLForReferrer (url, originOnly) {\n  // 1. Assert: url is a URL.\n  assert(url instanceof URL)\n\n  // 2. If url’s scheme is a local scheme, then return no referrer.\n  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {\n    return 'no-referrer'\n  }\n\n  // 3. Set url’s username to the empty string.\n  url.username = ''\n\n  // 4. Set url’s password to the empty string.\n  url.password = ''\n\n  // 5. Set url’s fragment to null.\n  url.hash = ''\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly) {\n    // 1. Set url’s path to « the empty string ».\n    url.pathname = ''\n\n    // 2. Set url’s query to null.\n    url.search = ''\n  }\n\n  // 7. Return url.\n  return url\n}\n\nfunction isURLPotentiallyTrustworthy (url) {\n  if (!(url instanceof URL)) {\n    return false\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true\n\n  // If file, return true\n  if (url.protocol === 'file:') return true\n\n  return isOriginPotentiallyTrustworthy(url.origin)\n\n  function isOriginPotentiallyTrustworthy (origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false\n\n    const originAsURL = new URL(origin)\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) ||\n     (originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.')) ||\n     (originAsURL.hostname.endsWith('.localhost'))) {\n      return true\n    }\n\n    // If any other, return false\n    return false\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch (bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList)\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true\n  }\n\n  // 3. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true\n  }\n\n  // 4. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo))\n  // get the strongest algorithm\n  const strongest = list[0].algo\n  // get all entries that use the strongest algorithm; ignore weaker\n  const metadata = list.filter((item) => item.algo === strongest)\n\n  // 5. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo\n\n    // 2. Let expectedValue be the val component of item.\n    const expectedValue = item.hash\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    const actualValue = crypto.createHash(algorithm).update(bytes).digest('base64')\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (actualValue === expectedValue) {\n      return true\n    }\n  }\n\n  // 6. Return false.\n  return false\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\\x21-\\x7e]?)?/i\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata (metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = []\n\n  // 2. Let empty be equal to true.\n  let empty = true\n\n  const supportedHashes = crypto.getHashes()\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token)\n\n    // 3. If token does not parse, continue to the next token.\n    if (parsedToken === null || parsedToken.groups === undefined) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm.toLowerCase())) {\n      result.push(parsedToken.groups)\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata'\n  }\n\n  return result\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  if (A.origin === B.origin && A.origin === 'null') {\n    return true\n  }\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nfunction isAborted (fetchParams) {\n  return fetchParams.controller.state === 'aborted'\n}\n\nfunction isCancelled (fetchParams) {\n  return fetchParams.controller.state === 'aborted' ||\n    fetchParams.controller.state === 'terminated'\n}\n\n// https://fetch.spec.whatwg.org/#concept-method-normalize\nfunction normalizeMethod (method) {\n  return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method)\n    ? method.toUpperCase()\n    : method\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString (value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value)\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable')\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string')\n\n  // 4. Return result.\n  return result\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {() => unknown[]} iterator\n * @param {string} name name of the instance\n * @param {'key'|'value'|'key+value'} kind\n */\nfunction makeIterator (iterator, name, kind) {\n  const object = {\n    index: 0,\n    kind,\n    target: iterator\n  }\n\n  const i = {\n    next () {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n\n      // 2. Let thisValue be the this value.\n\n      // 3. Let object be ? ToObject(thisValue).\n\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (Object.getPrototypeOf(this) !== i) {\n        throw new TypeError(\n          `'next' called on an object that does not implement interface ${name} Iterator.`\n        )\n      }\n\n      // 6. Let index be object’s index.\n      // 7. Let kind be object’s kind.\n      // 8. Let values be object’s target's value pairs to iterate over.\n      const { index, kind, target } = object\n      const values = target()\n\n      // 9. Let len be the length of values.\n      const len = values.length\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return { value: undefined, done: true }\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const pair = values[index]\n\n      // 12. Set object’s index to index + 1.\n      object.index = index + 1\n\n      // 13. Return the iterator result for pair and kind.\n      return iteratorResult(pair, kind)\n    },\n    // The class string of an iterator prototype object for a given interface is the\n    // result of concatenating the identifier of the interface and the string \" Iterator\".\n    [Symbol.toStringTag]: `${name} Iterator`\n  }\n\n  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n  Object.setPrototypeOf(i, esIteratorPrototype)\n  // esIteratorPrototype needs to be the prototype of i\n  // which is the prototype of an empty object. Yes, it's confusing.\n  return Object.setPrototypeOf({}, i)\n}\n\n// https://webidl.spec.whatwg.org/#iterator-result\nfunction iteratorResult (pair, kind) {\n  let result\n\n  // 1. Let result be a value determined by the value of kind:\n  switch (kind) {\n    case 'key': {\n      // 1. Let idlKey be pair’s key.\n      // 2. Let key be the result of converting idlKey to an\n      //    ECMAScript value.\n      // 3. result is key.\n      result = pair[0]\n      break\n    }\n    case 'value': {\n      // 1. Let idlValue be pair’s value.\n      // 2. Let value be the result of converting idlValue to\n      //    an ECMAScript value.\n      // 3. result is value.\n      result = pair[1]\n      break\n    }\n    case 'key+value': {\n      // 1. Let idlKey be pair’s key.\n      // 2. Let idlValue be pair’s value.\n      // 3. Let key be the result of converting idlKey to an\n      //    ECMAScript value.\n      // 4. Let value be the result of converting idlValue to\n      //    an ECMAScript value.\n      // 5. Let array be ! ArrayCreate(2).\n      // 6. Call ! CreateDataProperty(array, \"0\", key).\n      // 7. Call ! CreateDataProperty(array, \"1\", value).\n      // 8. result is array.\n      result = pair\n      break\n    }\n  }\n\n  // 2. Return CreateIterResultObject(result, false).\n  return { value: result, done: false }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nfunction fullyReadBody (body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = (bytes) => queueMicrotask(() => processBody(bytes))\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = (error) => queueMicrotask(() => processBodyError(error))\n\n  // 4. Let reader be the result of getting a reader for body’s stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n  let reader\n\n  try {\n    reader = body.stream.getReader()\n  } catch (e) {\n    errorSteps(e)\n    return\n  }\n\n  // 5. Read all bytes from reader, given successSteps and errorSteps.\n  readAllBytes(reader, successSteps, errorSteps)\n}\n\n/** @type {ReadableStream} */\nlet ReadableStream = globalThis.ReadableStream\n\nfunction isReadableStreamLike (stream) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  return stream instanceof ReadableStream || (\n    stream[Symbol.toStringTag] === 'ReadableStream' &&\n    typeof stream.tee === 'function'\n  )\n}\n\nconst MAXIMUM_ARGUMENT_LENGTH = 65535\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {number[]|Uint8Array} input\n */\nfunction isomorphicDecode (input) {\n  // 1. To isomorphic decode a byte sequence input, return a string whose code point\n  //    length is equal to input’s length and whose code points have the same values\n  //    as the values of input’s bytes, in the same order.\n\n  if (input.length < MAXIMUM_ARGUMENT_LENGTH) {\n    return String.fromCharCode(...input)\n  }\n\n  return input.reduce((previous, current) => previous + String.fromCharCode(current), '')\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose (controller) {\n  try {\n    controller.close()\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed')) {\n      throw err\n    }\n  }\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode (input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  for (let i = 0; i < input.length; i++) {\n    assert(input.charCodeAt(i) <= 0xFF)\n  }\n\n  // 2. Return a byte sequence whose length is equal to input’s code\n  //    point length and whose bytes have the same values as the\n  //    values of input’s code points, in the same order\n  return input\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n * @param {(bytes: Uint8Array) => void} successSteps\n * @param {(error: Error) => void} failureSteps\n */\nasync function readAllBytes (reader, successSteps, failureSteps) {\n  const bytes = []\n  let byteLength = 0\n\n  while (true) {\n    let done\n    let chunk\n\n    try {\n      ({ done, value: chunk } = await reader.read())\n    } catch (e) {\n      // 1. Call failureSteps with e.\n      failureSteps(e)\n      return\n    }\n\n    if (done) {\n      // 1. Call successSteps with bytes.\n      successSteps(Buffer.concat(bytes, byteLength))\n      return\n    }\n\n    // 1. If chunk is not a Uint8Array object, call failureSteps\n    //    with a TypeError and abort these steps.\n    if (!isUint8Array(chunk)) {\n      failureSteps(new TypeError('Received non-Uint8Array chunk'))\n      return\n    }\n\n    // 2. Append the bytes represented by chunk to bytes.\n    bytes.push(chunk)\n    byteLength += chunk.length\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */\nfunction urlIsLocal (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'\n}\n\n/**\n * @param {string|URL} url\n */\nfunction urlHasHttpsScheme (url) {\n  if (typeof url === 'string') {\n    return url.startsWith('https:')\n  }\n\n  return url.protocol === 'https:'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */\nfunction urlIsHttpHttpsScheme (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'http:' || protocol === 'https:'\n}\n\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */\nconst hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key))\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  toUSVString,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  hasOwn,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch,\n  isReadableStreamLike,\n  readableStreamClose,\n  isomorphicEncode,\n  isomorphicDecode,\n  urlIsLocal,\n  urlHasHttpsScheme,\n  urlIsHttpHttpsScheme,\n  readAllBytes\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}