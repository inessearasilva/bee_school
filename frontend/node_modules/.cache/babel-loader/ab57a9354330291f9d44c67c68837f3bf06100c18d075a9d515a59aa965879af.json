{"ast":null,"code":"import t from \"lodash.debounce\";\nimport n, { useRef as r, useState as e, useEffect as o } from \"react\";\nimport { select as a, event as i } from \"d3-selection\";\nimport u from \"resize-observer-polyfill\";\nimport \"d3-transition\";\nimport { range as f, min as l, max as s, descending as c } from \"d3-array\";\nimport h from \"d3-cloud\";\nimport d from \"lodash.clonedeep\";\nimport m from \"seedrandom\";\nimport y from \"tippy.js\";\nimport { dispatch as p } from \"d3-dispatch\";\nimport { scaleOrdinal as x, scaleLinear as v, scaleSqrt as g, scaleLog as b } from \"d3-scale\";\nimport { schemeCategory10 as w } from \"d3-scale-chromatic\";\nfunction M() {\n  return (M = Object.assign || function (t) {\n    for (var n = 1; n < arguments.length; n++) {\n      var r = arguments[n];\n      for (var e in r) Object.prototype.hasOwnProperty.call(r, e) && (t[e] = r[e]);\n    }\n    return t;\n  }).apply(this, arguments);\n}\nvar z = Math.PI / 180;\nfunction k(t) {\n  return t.text;\n}\nfunction W() {\n  return \"serif\";\n}\nfunction S() {\n  return \"normal\";\n}\nfunction O(t) {\n  return Math.sqrt(t.value);\n}\nfunction T() {\n  return 30 * (~~(6 * Math.random()) - 3);\n}\nfunction j() {\n  return 1;\n}\nfunction A(t, n, r, e) {\n  if (!n.sprite) {\n    var o = t.context,\n      a = t.ratio;\n    o.clearRect(0, 0, 2048 / a, 2048 / a);\n    var i = 0,\n      u = 0,\n      f = 0,\n      l = r.length;\n    for (--e; ++e < l;) {\n      n = r[e], o.save(), o.font = n.style + \" \" + n.weight + \" \" + ~~((n.size + 1) / a) + \"px \" + n.font;\n      var s = o.measureText(n.text + \"m\").width * a,\n        c = n.size << 1;\n      if (n.rotate) {\n        var h = Math.sin(n.rotate * z),\n          d = Math.cos(n.rotate * z),\n          m = s * d,\n          y = s * h,\n          p = c * d,\n          x = c * h;\n        s = Math.max(Math.abs(m + x), Math.abs(m - x)) + 31 >> 5 << 5, c = ~~Math.max(Math.abs(y + p), Math.abs(y - p));\n      } else s = s + 31 >> 5 << 5;\n      if (c > f && (f = c), i + s >= 2048 && (i = 0, u += f, f = 0), u + c >= 2048) break;\n      o.translate((i + (s >> 1)) / a, (u + (c >> 1)) / a), n.rotate && o.rotate(n.rotate * z), o.fillText(n.text, 0, 0), n.padding && (o.lineWidth = 2 * n.padding, o.strokeText(n.text, 0, 0)), o.restore(), n.width = s, n.height = c, n.xoff = i, n.yoff = u, n.x1 = s >> 1, n.y1 = c >> 1, n.x0 = -n.x1, n.y0 = -n.y1, n.hasText = !0, i += s;\n    }\n    for (var v = o.getImageData(0, 0, 2048 / a, 2048 / a).data, g = []; --e >= 0;) if ((n = r[e]).hasText) {\n      for (var b = (s = n.width) >> 5, w = (c = n.y1 - n.y0, 0); w < c * b; w++) g[w] = 0;\n      if (null == (i = n.xoff)) return;\n      u = n.yoff;\n      for (var M = 0, k = -1, W = 0; W < c; W++) {\n        for (w = 0; w < s; w++) {\n          var S = v[2048 * (u + W) + (i + w) << 2] ? 1 << 31 - w % 32 : 0;\n          g[b * W + (w >> 5)] |= S, M |= S;\n        }\n        M ? k = W : (n.y0++, c--, W--, u++);\n      }\n      n.y1 = n.y0 + k, n.sprite = g.slice(0, (n.y1 - n.y0) * b);\n    }\n  }\n}\nfunction I(t, n, r) {\n  for (var e, o = t.sprite, a = t.width >> 5, i = t.x - (a << 4), u = 127 & i, f = 32 - u, l = t.y1 - t.y0, s = (t.y + t.y0) * (r >>= 5) + (i >> 5), c = 0; c < l; c++) {\n    e = 0;\n    for (var h = 0; h <= a; h++) if ((e << f | (h < a ? (e = o[c * a + h]) >>> u : 0)) & n[s + h]) return !0;\n    s += r;\n  }\n  return !1;\n}\nfunction q(t, n) {\n  var r = t[0],\n    e = t[1];\n  n.x + n.x0 < r.x && (r.x = n.x + n.x0), n.y + n.y0 < r.y && (r.y = n.y + n.y0), n.x + n.x1 > e.x && (e.x = n.x + n.x1), n.y + n.y1 > e.y && (e.y = n.y + n.y1);\n}\nfunction E(t) {\n  var n = t[0] / t[1];\n  return function (t) {\n    return [n * (t *= .1) * Math.cos(t), t * Math.sin(t)];\n  };\n}\nfunction C() {\n  return document.createElement(\"canvas\");\n}\nfunction D(t) {\n  return \"function\" == typeof t ? t : function () {\n    return t;\n  };\n}\nvar F = {\n  archimedean: E,\n  rectangular: function (t) {\n    var n = 4 * t[0] / t[1],\n      r = 0,\n      e = 0;\n    return function (t) {\n      var o = t < 0 ? -1 : 1;\n      switch (Math.sqrt(1 + 4 * o * t) - o & 3) {\n        case 0:\n          r += n;\n          break;\n        case 1:\n          e += 4;\n          break;\n        case 2:\n          r -= n;\n          break;\n        default:\n          e -= 4;\n      }\n      return [r, e];\n    };\n  }\n};\nfunction P(t, n) {\n  return t[Math.floor(n() * t.length)];\n}\nfunction L(t) {\n  return t.size + \"px\";\n}\nfunction N(t) {\n  return t.text;\n}\nfunction R(t) {\n  return \"translate(\" + t.x + \", \" + t.y + \")\" + (\"number\" == typeof t.rotate ? \"rotate(\" + t.rotate + \")\" : \"\");\n}\nfunction U(t) {\n  var n,\n    r = t.callbacks,\n    e = t.maxWords,\n    o = t.options,\n    a = t.selection,\n    u = t.size,\n    f = o.deterministic,\n    x = o.enableOptimizations,\n    w = o.fontFamily,\n    z = o.fontStyle,\n    U = o.fontSizes,\n    H = o.fontWeight,\n    B = o.padding,\n    G = o.randomSeed,\n    J = o.rotations,\n    K = o.rotationAngles,\n    Q = o.spiral,\n    V = o.scale,\n    X = t.words.concat().sort(function (t, n) {\n      return c(t.value, n.value);\n    }).slice(0, e),\n    Y = m(f ? G || \"deterministic\" : null);\n  (n = x ? function () {\n    var t = [256, 256],\n      n = k,\n      r = W,\n      e = O,\n      o = S,\n      a = S,\n      i = T,\n      u = j,\n      f = E,\n      l = [],\n      s = Infinity,\n      c = p(\"word\", \"end\"),\n      h = Math.random,\n      d = {},\n      m = C,\n      y = !1;\n    function x(n, r, e) {\n      for (var o, a, i, u, l, s = r.x, c = r.y, d = Math.sqrt(t[0] * t[0] + t[1] * t[1]), m = f(t), y = h() < .5 ? 1 : -1, p = -y; (o = m(p += y)) && (a = ~~o[0], i = ~~o[1], !(Math.min(Math.abs(a), Math.abs(i)) >= d));) if (r.x = s + a, r.y = c + i, !(r.x + r.x0 < 0 || r.y + r.y0 < 0 || r.x + r.x1 > t[0] || r.y + r.y1 > t[1] || e && I(r, n, t[0]) || e && !((u = r).x + u.x1 > (l = e)[0].x && u.x + u.x0 < l[1].x && u.y + u.y1 > l[0].y && u.y + u.y0 < l[1].y))) {\n        for (var x, v = r.sprite, g = r.width >> 5, b = t[0] >> 5, w = r.x - (g << 4), M = 127 & w, z = 32 - M, k = r.y1 - r.y0, W = (r.y + r.y0) * b + (w >> 5), S = 0; S < k; S++) {\n          x = 0;\n          for (var O = 0; O <= g; O++) n[W + O] |= x << z | (O < g ? (x = v[S * g + O]) >>> M : 0);\n          W += b;\n        }\n        return delete r.sprite, !0;\n      }\n      return !1;\n    }\n    return d.canvas = function (t) {\n      return arguments.length ? (m = D(t), d) : m;\n    }, d.start = function () {\n      var f = function (t) {\n          t.width = t.height = 1;\n          var n = Math.sqrt(t.getContext(\"2d\").getImageData(0, 0, 1, 1).data.length >> 2);\n          t.width = 2048 / n, t.height = 2048 / n;\n          var r = t.getContext(\"2d\");\n          return r.fillStyle = r.strokeStyle = \"red\", r.textAlign = \"center\", {\n            context: r,\n            ratio: n\n          };\n        }(m()),\n        s = new Uint32Array((t[0] >> 5) * t[1]),\n        p = null,\n        v = [],\n        g = l.map(function (t, f) {\n          return t.text = n.call(this, t, f), t.font = r.call(this, t, f), t.style = o.call(this, t, f), t.weight = a.call(this, t, f), t.rotate = i.call(this, t, f), t.size = ~~e.call(this, t, f), t.padding = u.call(this, t, f), t;\n        }).sort(function (t, n) {\n          return n.size - t.size;\n        });\n      return setTimeout(function () {\n        return function n(r) {\n          var e = 50 * r,\n            o = Math.min(50 * (r + 1), l.length);\n          !function (n, r) {\n            for (var e = n; e < r; e += 1) {\n              var o = g[e];\n              o.x = t[0] * (h() + .5) >> 1, o.y = t[1] * (h() + .5) >> 1, A(f, o, g, e), o.hasText && x(s, o, p) && (v.push(o), c.call(\"word\", d, o), p ? q(p, o) : p = [{\n                x: o.x + o.x0,\n                y: o.y + o.y0\n              }, {\n                x: o.x + o.x1,\n                y: o.y + o.y1\n              }], o.x -= t[0] >> 1, o.y -= t[1] >> 1);\n            }\n          }(e, o), y || (o < l.length ? setTimeout(function () {\n            return n(r + 1);\n          }, 0) : (d.stop(), c.call(\"end\", d, v, p)));\n        }(0);\n      }, 0), d;\n    }, d.revive = function () {\n      return y = !1, d;\n    }, d.stop = function () {\n      return y = !0, d;\n    }, d.timeInterval = function (t) {\n      return arguments.length ? (s = null == t ? Infinity : t, d) : s;\n    }, d.words = function (t) {\n      return arguments.length ? (l = t, d) : l;\n    }, d.size = function (n) {\n      return arguments.length ? (t = [+n[0], +n[1]], d) : t;\n    }, d.font = function (t) {\n      return arguments.length ? (r = D(t), d) : r;\n    }, d.fontStyle = function (t) {\n      return arguments.length ? (o = D(t), d) : o;\n    }, d.fontWeight = function (t) {\n      return arguments.length ? (a = D(t), d) : a;\n    }, d.rotate = function (t) {\n      return arguments.length ? (i = D(t), d) : i;\n    }, d.text = function (t) {\n      return arguments.length ? (n = D(t), d) : n;\n    }, d.spiral = function (t) {\n      return arguments.length ? (f = F[t] || t, d) : f;\n    }, d.fontSize = function (t) {\n      return arguments.length ? (e = D(t), d) : e;\n    }, d.padding = function (t) {\n      return arguments.length ? (u = D(t), d) : u;\n    }, d.random = function (t) {\n      return arguments.length ? (h = t, d) : h;\n    }, d.on = function () {\n      var t = c.on.apply(c, arguments);\n      return t === c ? d : t;\n    }, d;\n  }() : h()).size(u).padding(B).words(d(X)).rotate(function () {\n    return void 0 === J ? 30 * (~~(6 * Y()) - 3) : function (t, n, r) {\n      if (t < 1) return 0;\n      var e = [];\n      if (1 === t) e = [n[0]];else {\n        e = [].concat(n);\n        for (var o = (n[1] - n[0]) / (t - 1), a = n[0] + o; a < n[1];) e.push(a), a += o;\n      }\n      return P(e, r);\n    }(J, K, Y);\n  }).spiral(Q).random(Y).text(N).font(w).fontStyle(z).fontWeight(H), function t(e, u) {\n    void 0 === u && (u = 1), x && n.revive(), n.fontSize(function (t) {\n      return function (t, n, r) {\n        var e,\n          o = l(t, function (t) {\n            return Number(t.value);\n          }),\n          a = s(t, function (t) {\n            return Number(t.value);\n          });\n        switch (r) {\n          case \"log\":\n            e = b;\n            break;\n          case \"sqrt\":\n            e = g;\n            break;\n          case \"linear\":\n          default:\n            e = v;\n        }\n        return e().domain([o, a]).range(n);\n      }(X, e, V)(t.value);\n    }).on(\"end\", function (n) {\n      if (X.length !== n.length && u <= 10) {\n        10 === u && console.warn(\"Unable to layout \" + (X.length - n.length) + \" word(s) after \" + u + \" attempts.  Consider: (1) Increasing the container/component size. (2) Lowering the max font size. (3) Limiting the rotation angles.\");\n        var f = Math.max(.95 * e[0], 1);\n        t([f, Math.max(.95 * e[1], f)], u + 1);\n      } else !function (t) {\n        var n,\n          r = t.callbacks,\n          e = t.options,\n          o = t.random,\n          a = t.words,\n          u = r.getWordColor,\n          f = r.getWordTooltip,\n          l = r.onWordClick,\n          s = r.onWordMouseOver,\n          c = r.onWordMouseOut,\n          h = e.colors,\n          d = e.enableTooltip,\n          m = e.fontStyle,\n          p = e.fontWeight,\n          x = e.textAttributes,\n          v = e.tooltipOptions,\n          g = e.fontFamily,\n          b = e.transitionDuration;\n        function w(t) {\n          return u ? u(t) : P(h, o);\n        }\n        t.selection.selectAll(\"text\").data(a).join(function (t) {\n          var r = t.append(\"text\").on(\"click\", function (t) {\n            l && l(t, i);\n          }).on(\"mouseover\", function (t) {\n            d && (n = y(i.target, M({\n              animation: \"scale\",\n              arrow: !0,\n              content: function () {\n                return f(t);\n              }\n            }, v))), s && s(t, i);\n          }).on(\"mouseout\", function (t) {\n            n && n.destroy(), c && c(t, i);\n          }).attr(\"cursor\", l ? \"pointer\" : \"default\").attr(\"fill\", w).attr(\"font-family\", g).attr(\"font-style\", m).attr(\"font-weight\", p).attr(\"text-anchor\", \"middle\").attr(\"transform\", \"translate(0, 0) rotate(0)\");\n          \"object\" == typeof x && Object.keys(x).forEach(function (t) {\n            r = r.attr(t, x[t]);\n          }), r = r.call(function (t) {\n            return t.transition().duration(b).attr(\"font-size\", L).attr(\"transform\", R).text(N);\n          });\n        }, function (t) {\n          t.transition().duration(b).attr(\"fill\", w).attr(\"font-family\", g).attr(\"font-size\", L).attr(\"transform\", R).text(N);\n        }, function (t) {\n          t.transition().duration(b).attr(\"fill-opacity\", 0).remove();\n        });\n      }({\n        callbacks: r,\n        options: o,\n        random: Y,\n        selection: a,\n        words: n\n      });\n    }).start();\n  }(U);\n}\nvar H = {\n    getWordTooltip: function (t) {\n      return t.text + \" (\" + t.value + \")\";\n    }\n  },\n  B = {\n    colors: f(20).map(function (t) {\n      return t.toString();\n    }).map(x(w)),\n    deterministic: !1,\n    enableOptimizations: !1,\n    enableTooltip: !0,\n    fontFamily: \"times new roman\",\n    fontSizes: [4, 32],\n    fontStyle: \"normal\",\n    fontWeight: \"normal\",\n    padding: 1,\n    rotationAngles: [-90, 90],\n    scale: \"sqrt\",\n    spiral: \"rectangular\",\n    tooltipOptions: {},\n    transitionDuration: 600\n  };\nfunction G(i) {\n  var f = i.callbacks,\n    l = i.maxWords,\n    s = void 0 === l ? 100 : l,\n    c = i.minSize,\n    h = i.options,\n    d = i.size,\n    m = i.words,\n    y = function (t, n) {\n      if (null == t) return {};\n      var r,\n        e,\n        o = {},\n        a = Object.keys(t);\n      for (e = 0; e < a.length; e++) n.indexOf(r = a[e]) >= 0 || (o[r] = t[r]);\n      return o;\n    }(i, [\"callbacks\", \"maxWords\", \"minSize\", \"options\", \"size\", \"words\"]),\n    p = M({}, H, f),\n    x = M({}, B, h),\n    v = function (t, n, i) {\n      var f = r(),\n        l = e(n),\n        s = l[0],\n        c = l[1],\n        h = e(null),\n        d = h[0],\n        m = h[1];\n      return o(function () {\n        var r = f.current,\n          e = a(r).append(\"svg\").style(\"display\", \"block\");\n        \"object\" == typeof i && Object.keys(i).forEach(function (t) {\n          e = e.attr(t, i[t]);\n        });\n        var o = e.append(\"g\");\n        function l(t, n) {\n          e.attr(\"height\", n).attr(\"width\", t), o.attr(\"transform\", \"translate(\" + t / 2 + \", \" + n / 2 + \")\"), c([t, n]);\n        }\n        m(o);\n        var s = 0,\n          h = 0;\n        void 0 === n ? (s = r.parentElement.offsetWidth, h = r.parentElement.offsetHeight) : (s = n[0], h = n[1]), l(s = Math.max(s, t[0]), h = Math.max(h, t[1]));\n        var d = new u(function (t) {\n          if (t && 0 !== t.length && void 0 === n) {\n            var r = t[0].contentRect;\n            l(r.width, r.height);\n          }\n        });\n        return d.observe(r), function () {\n          d.unobserve(r), a(r).selectAll(\"*\").remove();\n        };\n      }, [n, t, i]), [f, d, s];\n    }(c, d, h.svgAttributes),\n    g = v[0],\n    b = v[1],\n    w = v[2],\n    z = r(t(U, 100));\n  return o(function () {\n    b && z.current({\n      callbacks: p,\n      maxWords: s,\n      options: x,\n      selection: b,\n      size: w,\n      words: m\n    });\n  }, [s, p, x, b, w, m]), n.createElement(\"div\", M({\n    ref: g,\n    style: {\n      height: \"100%\",\n      width: \"100%\"\n    }\n  }, y));\n}\nG.defaultProps = {\n  callbacks: H,\n  maxWords: 100,\n  minSize: [300, 300],\n  options: B\n};\nexport default G;\nexport { H as defaultCallbacks, B as defaultOptions };","map":{"version":3,"mappings":"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","names":["cloudRadians","Math","PI","cloudText","d","text","cloudFont","cloudFontNormal","cloudFontSize","sqrt","value","cloudRotate","random","cloudPadding","cloudSprite","contextAndRatio","data","di","sprite","c","context","ratio","clearRect","x","y","maxh","n","length","save","font","style","weight","size","w","measureText","width","h","rotate","sr","sin","cr","cos","wcr","wsr","hcr","hsr","max","abs","cw","translate","fillText","padding","lineWidth","strokeText","restore","height","xoff","yoff","x1","y1","x0","y0","hasText","pixels","getImageData","w32","i","seen","seenRow","j","m","slice","cloudCollide","tag","board","sw","last","lx","sx","msx","cloudBounds","bounds","b0","b1","archimedeanSpiral","e","t","cloudCanvas","document","createElement","functor","spirals","archimedean","rectangular","dx","sign","choose","array","floor","getFontSize","word","getText","getTransform","layout","cloud","callbacks","maxWords","options","selection","deterministic","enableOptimizations","fontFamily","fontStyle","fontSizes","fontWeight","randomSeed","rotations","rotationAngles","spiral","scale","sortedWords","words","concat","sort","descending","seedrandom","fontSize","timeInterval","Infinity","event","dispatch","canvas","killed","place","perimeter","dxdy","dy","a","b","startX","startY","maxDelta","s","dt","min","_","arguments","start","getContext","fillStyle","strokeStyle","textAlign","Uint32Array","tags","map","call","this","setTimeout","loop","from","to","push","multiStep","stop","revive","on","apply","optimizedD3Cloud","d3Cloud","clonedeep","undefined","angles","increment","angle","draw","attempts","scaleFunction","minSize","Number","maxSize","scaleLog","scaleSqrt","scaleLinear","domain","range","getFontScale","fontScale","computedWords","console","warn","minFontSize","tooltipInstance","getWordColor","getWordTooltip","onWordClick","onWordMouseOver","onWordMouseOut","colors","enableTooltip","textAttributes","tooltipOptions","transitionDuration","getFill","selectAll","join","enter","append","tippy","target","animation","arrow","content","destroy","attr","Object","keys","forEach","key","transition","duration","update","exit","remove","render","defaultCallbacks","defaultOptions","number","toString","scaleOrdinal","schemeCategory10","ReactWordCloud","initialSize","rest","mergedCallbacks","mergedOptions","svgAttributes","elementRef","useRef","useState","setSize","setSelection","useEffect","element","current","svg","select","updateSize","parentElement","offsetWidth","offsetHeight","resizeObserver","ResizeObserver","entries","contentRect","observe","unobserve","useResponsiveSvgSelection","ref","debounce","React","defaultProps"],"sources":["C:\\Users\\ines_\\bee_v2\\bee_school\\frontend\\node_modules\\react-wordcloud\\src\\optimized-d3-cloud.js","C:\\Users\\ines_\\bee_v2\\bee_school\\frontend\\node_modules\\react-wordcloud\\src\\utils.js","C:\\Users\\ines_\\bee_v2\\bee_school\\frontend\\node_modules\\react-wordcloud\\src\\layout.js","C:\\Users\\ines_\\bee_v2\\bee_school\\frontend\\node_modules\\react-wordcloud\\src\\index.js","C:\\Users\\ines_\\bee_v2\\bee_school\\frontend\\node_modules\\react-wordcloud\\src\\hooks.js"],"sourcesContent":["// @ts-nocheck\n/**\n * Author: Augustinas (https://github.com/WhoAteDaCake)\n * Source: https://github.com/chrisrzhou/react-wordcloud/blob/166d0b0400a87647fe4e7855a26fe581ce38a502/src/cloud.ts\n * TEMPORARY workaround\n *\n * Implements the wordcloud algorithm based on: https://github.com/jasondavies/d3-cloud/tree/v1.2.5\n * Improvements:\n *  Use a setTimeout + batch sizes to calculate clouds in order to avoid blocking main thread for two long (87-101)\n *\n */\n\n// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\n\nimport { dispatch } from 'd3-dispatch';\n\nconst cloudRadians = Math.PI / 180,\n  cw = (1 << 11) >> 5,\n  ch = 1 << 11;\n\nexport default function Cloud() {\n  let size = [256, 256],\n    text = cloudText,\n    font = cloudFont,\n    fontSize = cloudFontSize,\n    fontStyle = cloudFontNormal,\n    fontWeight = cloudFontNormal,\n    rotate = cloudRotate,\n    padding = cloudPadding,\n    spiral = archimedeanSpiral,\n    words = [],\n    timeInterval = Infinity,\n    event = dispatch('word', 'end'),\n    timer = null,\n    random = Math.random,\n    cloud = {},\n    canvas = cloudCanvas;\n\n  let killed = false;\n\n  cloud.canvas = function(_) {\n    return arguments.length ? ((canvas = functor(_)), cloud) : canvas;\n  };\n\n  cloud.start = function() {\n    let contextAndRatio = getContext(canvas()),\n      board = zeroArray((size[0] >> 5) * size[1]),\n      bounds = null,\n      n = words.length,\n      i = -1,\n      tags = [],\n      data = words\n        .map(function(d, i) {\n          d.text = text.call(this, d, i);\n          d.font = font.call(this, d, i);\n          d.style = fontStyle.call(this, d, i);\n          d.weight = fontWeight.call(this, d, i);\n          d.rotate = rotate.call(this, d, i);\n          d.size = ~~fontSize.call(this, d, i);\n          d.padding = padding.call(this, d, i);\n          return d;\n        })\n        .sort(function(a, b) {\n          return b.size - a.size;\n        });\n\n    // Added by react-wordcloud\n    // Allows to calculate a subset of data instead of all of the words at once\n    function multiStep(from, to) {\n      for (let i = from; i < to; i += 1) {\n        const d = data[i];\n        d.x = (size[0] * (random() + 0.5)) >> 1;\n        d.y = (size[1] * (random() + 0.5)) >> 1;\n        cloudSprite(contextAndRatio, d, data, i);\n        if (d.hasText && place(board, d, bounds)) {\n          tags.push(d);\n          event.call('word', cloud, d);\n          if (bounds) cloudBounds(bounds, d);\n          else\n            bounds = [\n              { x: d.x + d.x0, y: d.y + d.y0 },\n              { x: d.x + d.x1, y: d.y + d.y1 },\n            ];\n          // Temporary hack\n          d.x -= size[0] >> 1;\n          d.y -= size[1] >> 1;\n        }\n      }\n    }\n\n    // Added by react-wordcloud\n    // Iterates dataset using setTimeout in order to prevent blocking of the main thread\n    function loop(i) {\n      const step = 50;\n      const from = i * step;\n      const to = Math.min((i + 1) * step, words.length);\n      multiStep(from, to);\n      if (killed) {\n        return;\n      }\n      if (to < words.length) {\n        setTimeout(() => loop(i + 1), 0);\n      } else {\n        cloud.stop();\n        event.call('end', cloud, tags, bounds);\n      }\n    }\n    setTimeout(() => loop(0), 0);\n\n    return cloud;\n  };\n\n  cloud.revive = () => {\n    killed = false;\n    return cloud;\n  };\n\n  cloud.stop = function() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n    killed = true;\n    return cloud;\n  };\n\n  function getContext(canvas) {\n    canvas.width = canvas.height = 1;\n    const ratio = Math.sqrt(\n      canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2,\n    );\n    canvas.width = (cw << 5) / ratio;\n    canvas.height = ch / ratio;\n\n    const context = canvas.getContext('2d');\n    context.fillStyle = context.strokeStyle = 'red';\n    context.textAlign = 'center';\n\n    return { context: context, ratio: ratio };\n  }\n\n  function place(board, tag, bounds) {\n    let perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],\n      startX = tag.x,\n      startY = tag.y,\n      maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\n      s = spiral(size),\n      dt = random() < 0.5 ? 1 : -1,\n      t = -dt,\n      dxdy,\n      dx,\n      dy;\n\n    while ((dxdy = s((t += dt)))) {\n      dx = ~~dxdy[0];\n      dy = ~~dxdy[1];\n\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\n\n      tag.x = startX + dx;\n      tag.y = startY + dy;\n\n      if (\n        tag.x + tag.x0 < 0 ||\n        tag.y + tag.y0 < 0 ||\n        tag.x + tag.x1 > size[0] ||\n        tag.y + tag.y1 > size[1]\n      )\n        continue;\n      // TODO only check for collisions within current bounds.\n      if (!bounds || !cloudCollide(tag, board, size[0])) {\n        if (!bounds || collideRects(tag, bounds)) {\n          var sprite = tag.sprite,\n            w = tag.width >> 5,\n            sw = size[0] >> 5,\n            lx = tag.x - (w << 4),\n            sx = lx & 0x7f,\n            msx = 32 - sx,\n            h = tag.y1 - tag.y0,\n            x = (tag.y + tag.y0) * sw + (lx >> 5),\n            last;\n          for (let j = 0; j < h; j++) {\n            last = 0;\n            for (let i = 0; i <= w; i++) {\n              board[x + i] |=\n                (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n            }\n            x += sw;\n          }\n          delete tag.sprite;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  cloud.timeInterval = function(_) {\n    return arguments.length\n      ? ((timeInterval = _ == null ? Infinity : _), cloud)\n      : timeInterval;\n  };\n\n  cloud.words = function(_) {\n    return arguments.length ? ((words = _), cloud) : words;\n  };\n\n  cloud.size = function(_) {\n    return arguments.length ? ((size = [+_[0], +_[1]]), cloud) : size;\n  };\n\n  cloud.font = function(_) {\n    return arguments.length ? ((font = functor(_)), cloud) : font;\n  };\n\n  cloud.fontStyle = function(_) {\n    return arguments.length ? ((fontStyle = functor(_)), cloud) : fontStyle;\n  };\n\n  cloud.fontWeight = function(_) {\n    return arguments.length ? ((fontWeight = functor(_)), cloud) : fontWeight;\n  };\n\n  cloud.rotate = function(_) {\n    return arguments.length ? ((rotate = functor(_)), cloud) : rotate;\n  };\n\n  cloud.text = function(_) {\n    return arguments.length ? ((text = functor(_)), cloud) : text;\n  };\n\n  cloud.spiral = function(_) {\n    return arguments.length ? ((spiral = spirals[_] || _), cloud) : spiral;\n  };\n\n  cloud.fontSize = function(_) {\n    return arguments.length ? ((fontSize = functor(_)), cloud) : fontSize;\n  };\n\n  cloud.padding = function(_) {\n    return arguments.length ? ((padding = functor(_)), cloud) : padding;\n  };\n\n  cloud.random = function(_) {\n    return arguments.length ? ((random = _), cloud) : random;\n  };\n\n  cloud.on = function() {\n    const value = event.on.apply(event, arguments);\n    return value === event ? cloud : value;\n  };\n\n  return cloud;\n}\n\nfunction cloudText(d) {\n  return d.text;\n}\n\nfunction cloudFont() {\n  return 'serif';\n}\n\nfunction cloudFontNormal() {\n  return 'normal';\n}\n\nfunction cloudFontSize(d) {\n  return Math.sqrt(d.value);\n}\n\nfunction cloudRotate() {\n  return (~~(Math.random() * 6) - 3) * 30;\n}\n\nfunction cloudPadding() {\n  return 1;\n}\n\n// Fetches a monochrome sprite bitmap for the specified text.\n// Load in batches for speed.\nfunction cloudSprite(contextAndRatio, d, data, di) {\n  if (d.sprite) return;\n  const c = contextAndRatio.context,\n    ratio = contextAndRatio.ratio;\n\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n  let x = 0,\n    y = 0,\n    maxh = 0,\n    n = data.length;\n  --di;\n  while (++di < n) {\n    d = data[di];\n    c.save();\n    c.font =\n      d.style +\n      ' ' +\n      d.weight +\n      ' ' +\n      ~~((d.size + 1) / ratio) +\n      'px ' +\n      d.font;\n    var w = c.measureText(d.text + 'm').width * ratio,\n      h = d.size << 1;\n    if (d.rotate) {\n      const sr = Math.sin(d.rotate * cloudRadians),\n        cr = Math.cos(d.rotate * cloudRadians),\n        wcr = w * cr,\n        wsr = w * sr,\n        hcr = h * cr,\n        hsr = h * sr;\n      w =\n        ((Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5) << 5;\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n    } else {\n      w = ((w + 0x1f) >> 5) << 5;\n    }\n    if (h > maxh) maxh = h;\n    if (x + w >= cw << 5) {\n      x = 0;\n      y += maxh;\n      maxh = 0;\n    }\n    if (y + h >= ch) break;\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n    if (d.rotate) c.rotate(d.rotate * cloudRadians);\n    c.fillText(d.text, 0, 0);\n\n    if (d.padding) {\n      c.lineWidth = 2 * d.padding;\n      c.strokeText(d.text, 0, 0);\n    }\n    c.restore();\n    d.width = w;\n    d.height = h;\n    d.xoff = x;\n    d.yoff = y;\n    d.x1 = w >> 1;\n    d.y1 = h >> 1;\n    d.x0 = -d.x1;\n    d.y0 = -d.y1;\n    d.hasText = true;\n    x += w;\n  }\n  const pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\n    sprite = [];\n  while (--di >= 0) {\n    d = data[di];\n    if (!d.hasText) continue;\n    var w = d.width,\n      w32 = w >> 5,\n      h = d.y1 - d.y0;\n    // Zero the buffer\n    for (var i = 0; i < h * w32; i++) sprite[i] = 0;\n    x = d.xoff;\n    if (x == null) return;\n    y = d.yoff;\n    let seen = 0,\n      seenRow = -1;\n    for (let j = 0; j < h; j++) {\n      for (var i = 0; i < w; i++) {\n        const k = w32 * j + (i >> 5),\n          m = pixels[((y + j) * (cw << 5) + (x + i)) << 2]\n            ? 1 << (31 - (i % 32))\n            : 0;\n        sprite[k] |= m;\n        seen |= m;\n      }\n      if (seen) seenRow = j;\n      else {\n        d.y0++;\n        h--;\n        j--;\n        y++;\n      }\n    }\n    d.y1 = d.y0 + seenRow;\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n  }\n}\n\n// Use mask-based collision detection.\nfunction cloudCollide(tag, board, sw) {\n  sw >>= 5;\n  let sprite = tag.sprite,\n    w = tag.width >> 5,\n    lx = tag.x - (w << 4),\n    sx = lx & 0x7f,\n    msx = 32 - sx,\n    h = tag.y1 - tag.y0,\n    x = (tag.y + tag.y0) * sw + (lx >> 5),\n    last;\n  for (let j = 0; j < h; j++) {\n    last = 0;\n    for (let i = 0; i <= w; i++) {\n      if (\n        ((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) &\n        board[x + i]\n      )\n        return true;\n    }\n    x += sw;\n  }\n  return false;\n}\n\nfunction cloudBounds(bounds, d) {\n  const b0 = bounds[0],\n    b1 = bounds[1];\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\n}\n\nfunction collideRects(a, b) {\n  return (\n    a.x + a.x1 > b[0].x &&\n    a.x + a.x0 < b[1].x &&\n    a.y + a.y1 > b[0].y &&\n    a.y + a.y0 < b[1].y\n  );\n}\n\nfunction archimedeanSpiral(size) {\n  const e = size[0] / size[1];\n  return function(t) {\n    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];\n  };\n}\n\nfunction rectangularSpiral(size) {\n  let dy = 4,\n    dx = (dy * size[0]) / size[1],\n    x = 0,\n    y = 0;\n  return function(t) {\n    const sign = t < 0 ? -1 : 1;\n    // See triangular numbers: T_n = n * (n + 1) / 2.\n    switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {\n      case 0:\n        x += dx;\n        break;\n      case 1:\n        y += dy;\n        break;\n      case 2:\n        x -= dx;\n        break;\n      default:\n        y -= dy;\n        break;\n    }\n    return [x, y];\n  };\n}\n\nfunction zeroArray(n) {\n  const a = new Uint32Array(n);\n  return a;\n}\n\nfunction cloudCanvas() {\n  return document.createElement('canvas');\n}\n\nfunction functor(d) {\n  return typeof d === 'function'\n    ? d\n    : function() {\n        return d;\n      };\n}\n\nvar spirals = {\n  archimedean: archimedeanSpiral,\n  rectangular: rectangularSpiral,\n};\n","import { max, min, range } from 'd3-array';\nimport { scaleLinear, scaleLog, scaleOrdinal, scaleSqrt } from 'd3-scale';\nimport { schemeCategory10 } from 'd3-scale-chromatic';\n\nexport function choose(array, random) {\n  return array[Math.floor(random() * array.length)];\n}\n\nexport function getDefaultColors() {\n  return range(20)\n    .map(number => number.toString())\n    .map(scaleOrdinal(schemeCategory10));\n}\n\nexport function getFontScale(words, fontSizes, scale) {\n  const minSize = min(words, word => Number(word.value));\n  const maxSize = max(words, word => Number(word.value));\n  let scaleFunction;\n  switch (scale) {\n    case 'log':\n      scaleFunction = scaleLog;\n      break;\n    case 'sqrt':\n      scaleFunction = scaleSqrt;\n      break;\n    case 'linear':\n    default:\n      scaleFunction = scaleLinear;\n      break;\n  }\n\n  const fontScale = scaleFunction()\n    .domain([minSize, maxSize])\n    .range(fontSizes);\n  return fontScale;\n}\n\nexport function getFontSize(word) {\n  return `${word.size}px`;\n}\n\nexport function getText(word) {\n  return word.text;\n}\n\nexport function getTransform(word) {\n  const translate = `translate(${word.x}, ${word.y})`;\n  const rotate =\n    typeof word.rotate === 'number' ? `rotate(${word.rotate})` : '';\n  return translate + rotate;\n}\n\nexport function rotate(rotations, rotationAngles, random) {\n  if (rotations < 1) {\n    return 0;\n  }\n\n  let angles = [];\n  if (rotations === 1) {\n    angles = [rotationAngles[0]];\n  } else {\n    angles = [...rotationAngles];\n    const increment = (rotationAngles[1] - rotationAngles[0]) / (rotations - 1);\n    let angle = rotationAngles[0] + increment;\n    while (angle < rotationAngles[1]) {\n      angles.push(angle);\n      angle += increment;\n    }\n  }\n\n  return choose(angles, random);\n}\n","import 'd3-transition';\n\nimport { descending } from 'd3-array';\nimport d3Cloud from 'd3-cloud';\nimport { event } from 'd3-selection';\nimport clonedeep from 'lodash.clonedeep';\nimport seedrandom from 'seedrandom';\nimport tippy from 'tippy.js';\n\nimport optimizedD3Cloud from './optimized-d3-cloud';\nimport {\n  choose,\n  getFontScale,\n  getFontSize,\n  getText,\n  getTransform,\n  rotate,\n} from './utils';\n\nexport function render({ callbacks, options, random, selection, words }) {\n  const {\n    getWordColor,\n    getWordTooltip,\n    onWordClick,\n    onWordMouseOver,\n    onWordMouseOut,\n  } = callbacks;\n  const {\n    colors,\n    enableTooltip,\n    fontStyle,\n    fontWeight,\n    textAttributes,\n    tooltipOptions,\n  } = options;\n  const { fontFamily, transitionDuration } = options;\n\n  function getFill(word) {\n    return getWordColor ? getWordColor(word) : choose(colors, random);\n  }\n\n  // Load words\n  let tooltipInstance;\n  const vizWords = selection.selectAll('text').data(words);\n  vizWords.join(\n    enter => {\n      let text = enter\n        .append('text')\n        .on('click', word => {\n          if (onWordClick) {\n            onWordClick(word, event);\n          }\n        })\n        .on('mouseover', word => {\n          if (enableTooltip) {\n            tooltipInstance = tippy(event.target, {\n              animation: 'scale',\n              arrow: true,\n              content: () => getWordTooltip(word),\n              ...tooltipOptions,\n            });\n          }\n\n          if (onWordMouseOver) {\n            onWordMouseOver(word, event);\n          }\n        })\n        .on('mouseout', word => {\n          if (tooltipInstance) {\n            tooltipInstance.destroy();\n          }\n\n          if (onWordMouseOut) {\n            onWordMouseOut(word, event);\n          }\n        })\n        .attr('cursor', onWordClick ? 'pointer' : 'default')\n        .attr('fill', getFill)\n        .attr('font-family', fontFamily)\n        .attr('font-style', fontStyle)\n        .attr('font-weight', fontWeight)\n        .attr('text-anchor', 'middle')\n        .attr('transform', 'translate(0, 0) rotate(0)');\n\n      if (typeof textAttributes === 'object') {\n        Object.keys(textAttributes).forEach(key => {\n          text = text.attr(key, textAttributes[key]);\n        });\n      }\n\n      text = text.call(enter =>\n        enter\n          .transition()\n          .duration(transitionDuration)\n          .attr('font-size', getFontSize)\n          .attr('transform', getTransform)\n          .text(getText),\n      );\n    },\n    update => {\n      update\n        .transition()\n        .duration(transitionDuration)\n        .attr('fill', getFill)\n        .attr('font-family', fontFamily)\n        .attr('font-size', getFontSize)\n        .attr('transform', getTransform)\n        .text(getText);\n    },\n    exit => {\n      exit\n        .transition()\n        .duration(transitionDuration)\n        .attr('fill-opacity', 0)\n        .remove();\n    },\n  );\n}\n\nexport function layout({\n  callbacks,\n  maxWords,\n  options,\n  selection,\n  size,\n  words,\n}) {\n  const MAX_LAYOUT_ATTEMPTS = 10;\n  const SHRINK_FACTOR = 0.95;\n  const {\n    deterministic,\n    enableOptimizations,\n    fontFamily,\n    fontStyle,\n    fontSizes,\n    fontWeight,\n    padding,\n    randomSeed,\n    rotations,\n    rotationAngles,\n    spiral,\n    scale,\n  } = options;\n\n  const sortedWords = words\n    .concat()\n    .sort((x, y) => descending(x.value, y.value))\n    .slice(0, maxWords);\n\n  const random = seedrandom(\n    deterministic ? randomSeed || 'deterministic' : null,\n  );\n\n  let cloud;\n  if (enableOptimizations) {\n    cloud = optimizedD3Cloud();\n  } else {\n    cloud = d3Cloud();\n  }\n\n  cloud\n    .size(size)\n    // @ts-ignore\n    .padding(padding)\n    .words(clonedeep(sortedWords))\n    .rotate(() => {\n      if (rotations === undefined) {\n        // Default rotation algorithm\n        return (~~(random() * 6) - 3) * 30;\n      }\n\n      return rotate(rotations, rotationAngles, random);\n    })\n    .spiral(spiral)\n    .random(random)\n    .text(getText)\n    .font(fontFamily)\n    .fontStyle(fontStyle)\n    .fontWeight(fontWeight);\n\n  function draw(fontSizes, attempts = 1) {\n    if (enableOptimizations) {\n      cloud.revive();\n    }\n\n    cloud\n      .fontSize(word => {\n        const fontScale = getFontScale(sortedWords, fontSizes, scale);\n        return fontScale(word.value);\n      })\n      .on('end', computedWords => {\n        /** KNOWN ISSUE: https://github.com/jasondavies/d3-cloud/issues/36\n         * Recursively layout and decrease font-sizes by a SHRINK_FACTOR.\n         * Bail out with a warning message after MAX_LAYOUT_ATTEMPTS.\n         */\n        if (\n          sortedWords.length !== computedWords.length &&\n          attempts <= MAX_LAYOUT_ATTEMPTS\n        ) {\n          if (attempts === MAX_LAYOUT_ATTEMPTS) {\n            console.warn(\n              `Unable to layout ${sortedWords.length -\n                computedWords.length} word(s) after ${attempts} attempts.  Consider: (1) Increasing the container/component size. (2) Lowering the max font size. (3) Limiting the rotation angles.`,\n            );\n          }\n\n          const minFontSize = Math.max(fontSizes[0] * SHRINK_FACTOR, 1);\n          const maxFontSize = Math.max(\n            fontSizes[1] * SHRINK_FACTOR,\n            minFontSize,\n          );\n\n          draw([minFontSize, maxFontSize], attempts + 1);\n        } else {\n          render({\n            callbacks,\n            options,\n            random,\n            selection,\n            words: computedWords,\n          });\n        }\n      })\n      .start();\n  }\n\n  draw(fontSizes);\n}\n","import debounce from 'lodash.debounce';\nimport React, { useEffect, useRef } from 'react';\n\nimport { useResponsiveSvgSelection } from './hooks';\nimport { layout } from './layout';\nimport { getDefaultColors } from './utils';\n\nexport const defaultCallbacks = {\n  getWordTooltip: ({ text, value }) => `${text} (${value})`,\n};\n\nexport const defaultOptions = {\n  colors: getDefaultColors(),\n  deterministic: false,\n  enableOptimizations: false,\n  enableTooltip: true,\n  fontFamily: 'times new roman',\n  fontSizes: [4, 32],\n  fontStyle: 'normal',\n  fontWeight: 'normal',\n  padding: 1,\n  rotationAngles: [-90, 90],\n  scale: 'sqrt',\n  spiral: 'rectangular',\n  tooltipOptions: {},\n  transitionDuration: 600,\n};\n\nfunction ReactWordCloud({\n  callbacks,\n  maxWords = 100,\n  minSize,\n  options,\n  size: initialSize,\n  words,\n  ...rest\n}) {\n  const mergedCallbacks = { ...defaultCallbacks, ...callbacks };\n  const mergedOptions = { ...defaultOptions, ...options };\n\n  const [ref, selection, size] = useResponsiveSvgSelection(\n    minSize,\n    initialSize,\n    options.svgAttributes,\n  );\n\n  const render = useRef(debounce(layout, 100));\n\n  useEffect(() => {\n    if (selection) {\n      render.current({\n        callbacks: mergedCallbacks,\n        maxWords,\n        options: mergedOptions,\n        selection,\n        size,\n        words,\n      });\n    }\n  }, [maxWords, mergedCallbacks, mergedOptions, selection, size, words]);\n\n  return <div ref={ref} style={{ height: '100%', width: '100%' }} {...rest} />;\n}\n\nReactWordCloud.defaultProps = {\n  callbacks: defaultCallbacks,\n  maxWords: 100,\n  minSize: [300, 300],\n  options: defaultOptions,\n};\n\nexport default ReactWordCloud;\n","import { select } from 'd3-selection';\nimport { useEffect, useRef, useState } from 'react';\nimport ResizeObserver from 'resize-observer-polyfill';\n\nexport function useResponsiveSvgSelection(minSize, initialSize, svgAttributes) {\n  const elementRef = useRef();\n  const [size, setSize] = useState(initialSize);\n  const [selection, setSelection] = useState(null);\n\n  useEffect(() => {\n    const element = elementRef.current;\n\n    // Set svg selection\n    let svg = select(element)\n      .append('svg')\n      .style('display', 'block'); // Native inline svg leaves undesired white space\n\n    if (typeof svgAttributes === 'object') {\n      Object.keys(svgAttributes).forEach(key => {\n        svg = svg.attr(key, svgAttributes[key]);\n      });\n    }\n\n    const selection = svg.append('g');\n    setSelection(selection);\n\n    function updateSize(width, height) {\n      svg.attr('height', height).attr('width', width);\n      selection.attr('transform', `translate(${width / 2}, ${height / 2})`);\n      setSize([width, height]);\n    }\n\n    let width = 0;\n    let height = 0;\n    if (initialSize === undefined) {\n      // Use parentNode size if resized has not occurred\n      width = element.parentElement.offsetWidth;\n      height = element.parentElement.offsetHeight;\n    } else {\n      // Use initialSize if it is provided\n      [width, height] = initialSize;\n    }\n\n    width = Math.max(width, minSize[0]);\n    height = Math.max(height, minSize[1]);\n    updateSize(width, height);\n\n    // Update resize using a resize observer\n    const resizeObserver = new ResizeObserver(entries => {\n      if (!entries || entries.length === 0) {\n        return;\n      }\n\n      if (initialSize === undefined) {\n        const { width, height } = entries[0].contentRect;\n        updateSize(width, height);\n      }\n    });\n    resizeObserver.observe(element);\n\n    // Cleanup\n    return () => {\n      resizeObserver.unobserve(element);\n      select(element)\n        .selectAll('*')\n        .remove();\n    };\n  }, [initialSize, minSize, svgAttributes]);\n\n  return [elementRef, selection, size];\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}