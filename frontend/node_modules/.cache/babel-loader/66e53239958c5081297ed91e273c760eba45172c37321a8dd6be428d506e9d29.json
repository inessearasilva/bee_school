{"ast":null,"code":"const handleInOperator = (condition, value) => {\n  const array = condition.map(x => {\n    return x.toString();\n  });\n  let isTrue = false;\n  if (array.indexOf(value) > -1) {\n    isTrue = true;\n  }\n  return isTrue;\n};\nconst handleNotInOperator = (condition, value) => {\n  const array = condition.map(x => {\n    return x.toString();\n  });\n  let isTrue = false;\n  if (array.indexOf(value) === -1) {\n    isTrue = true;\n  }\n  return isTrue;\n};\nconst handleBetweenOperator = (condition, value) => {\n  let isTrue = false;\n  if (value === \"\") {\n    return false;\n  }\n  if (!isNaN(Number(value)) && !isNaN(Number(condition[0])) && !isNaN(Number(condition[1]))) {\n    if (Number(value) > Number(condition[0]) && Number(value) < Number(condition[1])) {\n      isTrue = true;\n    }\n  }\n  return isTrue;\n};\nconst handleNotBetweenOperator = (condition, value) => {\n  let isTrue = false;\n  if (value === \"\") {\n    return false;\n  }\n  if (!isNaN(Number(value)) && !isNaN(Number(condition[0])) && !isNaN(Number(condition[1]))) {\n    if (Number(value) < Number(condition[0]) || Number(value) > Number(condition[1])) {\n      isTrue = true;\n    }\n  }\n  return isTrue;\n};\nconst handleGtOperator = (condition, value) => {\n  let isTrue = false;\n  if (!isNaN(Number(value)) && !isNaN(Number(condition))) {\n    if (Number(value) > Number(condition)) {\n      isTrue = true;\n    }\n  }\n  return isTrue;\n};\nconst handleGteOperator = (condition, value) => {\n  let isTrue = false;\n  if (!isNaN(Number(value)) && !isNaN(Number(condition))) {\n    if (Number(value) >= Number(condition)) {\n      isTrue = true;\n    }\n  }\n  return isTrue;\n};\nconst handleLtOperator = (condition, value) => {\n  let isTrue = false;\n  if (value === \"\") {\n    return false;\n  }\n  if (!isNaN(Number(value)) && !isNaN(Number(condition))) {\n    if (Number(value) < Number(condition)) {\n      isTrue = true;\n    }\n  }\n  return isTrue;\n};\nconst handleLteOperator = (condition, value) => {\n  let isTrue = false;\n  if (value === \"\") {\n    return false;\n  }\n  if (!isNaN(Number(value)) && !isNaN(Number(condition))) {\n    if (Number(value) <= Number(condition)) {\n      isTrue = true;\n    }\n  }\n  return isTrue;\n};\nconst handleNeOperator = (condition, value) => {\n  let isTrue = false;\n  if (!isNaN(Number(value)) && !isNaN(Number(condition))) {\n    if (Number(value) !== Number(condition)) {\n      isTrue = true;\n    }\n  } else if (value !== condition) {\n    isTrue = true;\n  }\n  return isTrue;\n};\nconst handleEqOperator = (condition, value) => {\n  let isTrue = false;\n  if (!isNaN(Number(value)) && !isNaN(Number(condition))) {\n    if (Number(value) === Number(condition)) {\n      isTrue = true;\n    }\n  } else if (value === condition) {\n    isTrue = true;\n  }\n  return isTrue;\n};\nconst handleConditionValidation = (condition, value) => {\n  let conditionValidation;\n  if (condition[\"$in\"]) {\n    conditionValidation = operatorsFunctions[\"$in\"](condition[\"$in\"], value);\n  } else if (condition[\"$gt\"]) {\n    conditionValidation = operatorsFunctions[\"$gt\"](condition[\"$gt\"], value);\n  } else if (condition[\"$gte\"]) {\n    conditionValidation = operatorsFunctions[\"$gte\"](condition[\"$gte\"], value);\n  } else if (condition[\"$lt\"]) {\n    conditionValidation = operatorsFunctions[\"$lt\"](condition[\"$lt\"], value);\n  } else if (condition[\"$lte\"]) {\n    conditionValidation = operatorsFunctions[\"$lte\"](condition[\"$lte\"], value);\n  } else if (condition[\"$ne\"]) {\n    conditionValidation = operatorsFunctions[\"$ne\"](condition[\"$ne\"], value);\n  } else if (condition[\"$eq\"]) {\n    conditionValidation = operatorsFunctions[\"$eq\"](condition[\"$eq\"], value);\n  } else if (condition[\"$notIn\"]) {\n    conditionValidation = operatorsFunctions[\"$notIn\"](condition[\"$notIn\"], value);\n  } else if (condition[\"$notBetween\"]) {\n    conditionValidation = operatorsFunctions[\"$notBetween\"](condition[\"$notBetween\"], value);\n  } else if (condition[\"$between\"]) {\n    conditionValidation = operatorsFunctions[\"$between\"](condition[\"$between\"], value);\n  }\n  return conditionValidation;\n};\nconst operatorsFunctions = {\n  $in: handleInOperator,\n  $gt: handleGtOperator,\n  $gte: handleGteOperator,\n  $lt: handleLtOperator,\n  $lte: handleLteOperator,\n  $ne: handleNeOperator,\n  $eq: handleEqOperator,\n  $notIn: handleNotInOperator,\n  $between: handleBetweenOperator,\n  $notBetween: handleNotBetweenOperator\n};\nexport { handleConditionValidation };","map":{"version":3,"names":["handleInOperator","condition","value","array","map","x","toString","isTrue","indexOf","handleNotInOperator","handleBetweenOperator","isNaN","Number","handleNotBetweenOperator","handleGtOperator","handleGteOperator","handleLtOperator","handleLteOperator","handleNeOperator","handleEqOperator","handleConditionValidation","conditionValidation","operatorsFunctions","$in","$gt","$gte","$lt","$lte","$ne","$eq","$notIn","$between","$notBetween"],"sources":["C:/Users/ines_/fisiosys/frontend/node_modules/protected-aidaforms/dist/assets/functions/HandleRules/handleConditionValidation.js"],"sourcesContent":["const handleInOperator = (condition, value) => {\n  const array = condition.map(x => {\n    return x.toString();\n  });\n  let isTrue = false;\n\n  if (array.indexOf(value) > -1) {\n    isTrue = true;\n  }\n\n  return isTrue;\n};\n\nconst handleNotInOperator = (condition, value) => {\n  const array = condition.map(x => {\n    return x.toString();\n  });\n  let isTrue = false;\n\n  if (array.indexOf(value) === -1) {\n    isTrue = true;\n  }\n\n  return isTrue;\n};\n\nconst handleBetweenOperator = (condition, value) => {\n  let isTrue = false;\n\n  if (value === \"\") {\n    return false;\n  }\n\n  if (!isNaN(Number(value)) && !isNaN(Number(condition[0])) && !isNaN(Number(condition[1]))) {\n    if (Number(value) > Number(condition[0]) && Number(value) < Number(condition[1])) {\n      isTrue = true;\n    }\n  }\n\n  return isTrue;\n};\n\nconst handleNotBetweenOperator = (condition, value) => {\n  let isTrue = false;\n\n  if (value === \"\") {\n    return false;\n  }\n\n  if (!isNaN(Number(value)) && !isNaN(Number(condition[0])) && !isNaN(Number(condition[1]))) {\n    if (Number(value) < Number(condition[0]) || Number(value) > Number(condition[1])) {\n      isTrue = true;\n    }\n  }\n\n  return isTrue;\n};\n\nconst handleGtOperator = (condition, value) => {\n  let isTrue = false;\n\n  if (!isNaN(Number(value)) && !isNaN(Number(condition))) {\n    if (Number(value) > Number(condition)) {\n      isTrue = true;\n    }\n  }\n\n  return isTrue;\n};\n\nconst handleGteOperator = (condition, value) => {\n  let isTrue = false;\n\n  if (!isNaN(Number(value)) && !isNaN(Number(condition))) {\n    if (Number(value) >= Number(condition)) {\n      isTrue = true;\n    }\n  }\n\n  return isTrue;\n};\n\nconst handleLtOperator = (condition, value) => {\n  let isTrue = false;\n\n  if (value === \"\") {\n    return false;\n  }\n\n  if (!isNaN(Number(value)) && !isNaN(Number(condition))) {\n    if (Number(value) < Number(condition)) {\n      isTrue = true;\n    }\n  }\n\n  return isTrue;\n};\n\nconst handleLteOperator = (condition, value) => {\n  let isTrue = false;\n\n  if (value === \"\") {\n    return false;\n  }\n\n  if (!isNaN(Number(value)) && !isNaN(Number(condition))) {\n    if (Number(value) <= Number(condition)) {\n      isTrue = true;\n    }\n  }\n\n  return isTrue;\n};\n\nconst handleNeOperator = (condition, value) => {\n  let isTrue = false;\n\n  if (!isNaN(Number(value)) && !isNaN(Number(condition))) {\n    if (Number(value) !== Number(condition)) {\n      isTrue = true;\n    }\n  } else if (value !== condition) {\n    isTrue = true;\n  }\n\n  return isTrue;\n};\n\nconst handleEqOperator = (condition, value) => {\n  let isTrue = false;\n\n  if (!isNaN(Number(value)) && !isNaN(Number(condition))) {\n    if (Number(value) === Number(condition)) {\n      isTrue = true;\n    }\n  } else if (value === condition) {\n    isTrue = true;\n  }\n\n  return isTrue;\n};\n\nconst handleConditionValidation = (condition, value) => {\n  let conditionValidation;\n\n  if (condition[\"$in\"]) {\n    conditionValidation = operatorsFunctions[\"$in\"](condition[\"$in\"], value);\n  } else if (condition[\"$gt\"]) {\n    conditionValidation = operatorsFunctions[\"$gt\"](condition[\"$gt\"], value);\n  } else if (condition[\"$gte\"]) {\n    conditionValidation = operatorsFunctions[\"$gte\"](condition[\"$gte\"], value);\n  } else if (condition[\"$lt\"]) {\n    conditionValidation = operatorsFunctions[\"$lt\"](condition[\"$lt\"], value);\n  } else if (condition[\"$lte\"]) {\n    conditionValidation = operatorsFunctions[\"$lte\"](condition[\"$lte\"], value);\n  } else if (condition[\"$ne\"]) {\n    conditionValidation = operatorsFunctions[\"$ne\"](condition[\"$ne\"], value);\n  } else if (condition[\"$eq\"]) {\n    conditionValidation = operatorsFunctions[\"$eq\"](condition[\"$eq\"], value);\n  } else if (condition[\"$notIn\"]) {\n    conditionValidation = operatorsFunctions[\"$notIn\"](condition[\"$notIn\"], value);\n  } else if (condition[\"$notBetween\"]) {\n    conditionValidation = operatorsFunctions[\"$notBetween\"](condition[\"$notBetween\"], value);\n  } else if (condition[\"$between\"]) {\n    conditionValidation = operatorsFunctions[\"$between\"](condition[\"$between\"], value);\n  }\n\n  return conditionValidation;\n};\n\nconst operatorsFunctions = {\n  $in: handleInOperator,\n  $gt: handleGtOperator,\n  $gte: handleGteOperator,\n  $lt: handleLtOperator,\n  $lte: handleLteOperator,\n  $ne: handleNeOperator,\n  $eq: handleEqOperator,\n  $notIn: handleNotInOperator,\n  $between: handleBetweenOperator,\n  $notBetween: handleNotBetweenOperator\n};\nexport { handleConditionValidation };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}