{"ast":null,"code":"/*!\r\n * EventEmitter2\r\n * https://github.com/hij1nx/EventEmitter2\r\n *\r\n * Copyright (c) 2013 hij1nx\r\n * Licensed under the MIT license.\r\n */\n;\n!function (undefined) {\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n  function configure(conf) {\n    if (conf) {\n      this._conf = conf;\n      conf.delimiter && (this.delimiter = conf.delimiter);\n      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this.newListener = conf.newListener);\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n  function EventEmitter(conf) {\n    this._events = {};\n    this.newListener = false;\n    configure.call(this, conf);\n  }\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\n\n  //\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i) {\n    if (!tree) {\n      return [];\n    }\n    var listeners = [],\n      leaf,\n      len,\n      branch,\n      xTree,\n      xxTree,\n      isolatedBranch,\n      endReached,\n      typeLength = type.length,\n      currentType = type[i],\n      nextType = type[i + 1];\n    if (i === typeLength && tree._listeners) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n      if (typeof tree._listeners === 'function') {\n        handlers && handlers.push(tree._listeners);\n        return [tree];\n      } else {\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n          handlers && handlers.push(tree._listeners[leaf]);\n        }\n        return [tree];\n      }\n    }\n    if (currentType === '*' || currentType === '**' || tree[currentType]) {\n      //\n      // If the event emitted is '*' at this part\n      // or there is a concrete match at this patch\n      //\n      if (currentType === '*') {\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 1));\n          }\n        }\n        return listeners;\n      } else if (currentType === '**') {\n        endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === '*';\n        if (endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n        }\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            if (branch === '*' || branch === '**') {\n              if (tree[branch]._listeners && !endReached) {\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n              }\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            } else if (branch === nextType) {\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 2));\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            }\n          }\n        }\n        return listeners;\n      }\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i + 1));\n    }\n    xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i + 1);\n    }\n    xxTree = tree['**'];\n    if (xxTree) {\n      if (i < typeLength) {\n        if (xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        for (branch in xxTree) {\n          if (branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n            if (branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i + 2);\n            } else if (branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i + 1);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, {\n                '**': isolatedBranch\n              }, i + 1);\n            }\n          }\n        }\n      } else if (xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength);\n      } else if (xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n      }\n    }\n    return listeners;\n  }\n  function growListenerTree(type, listener) {\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    for (var i = 0, len = type.length; i + 1 < len; i++) {\n      if (type[i] === '**' && type[i + 1] === '**') {\n        return;\n      }\n    }\n    var tree = this.listenerTree;\n    var name = type.shift();\n    while (name) {\n      if (!tree[name]) {\n        tree[name] = {};\n      }\n      tree = tree[name];\n      if (type.length === 0) {\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        } else if (typeof tree._listeners === 'function') {\n          tree._listeners = [tree._listeners, listener];\n        } else if (isArray(tree._listeners)) {\n          tree._listeners.push(listener);\n          if (!tree._listeners.warned) {\n            var m = defaultMaxListeners;\n            if (typeof this._events.maxListeners !== 'undefined') {\n              m = this._events.maxListeners;\n            }\n            if (m > 0 && tree._listeners.length > m) {\n              tree._listeners.warned = true;\n              console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', tree._listeners.length);\n              if (console.trace) {\n                console.trace();\n              }\n            }\n          }\n        }\n        return true;\n      }\n      name = type.shift();\n    }\n    return true;\n  }\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n  EventEmitter.prototype.setMaxListeners = function (n) {\n    this._events || init.call(this);\n    this._events.maxListeners = n;\n    if (!this._conf) this._conf = {};\n    this._conf.maxListeners = n;\n  };\n  EventEmitter.prototype.event = '';\n  EventEmitter.prototype.once = function (event, fn) {\n    this.many(event, 1, fn);\n    return this;\n  };\n  EventEmitter.prototype.many = function (event, ttl, fn) {\n    var self = this;\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      fn.apply(this, arguments);\n    }\n    listener._origin = fn;\n    this.on(event, listener);\n    return self;\n  };\n  EventEmitter.prototype.emit = function () {\n    this._events || init.call(this);\n    var type = arguments[0];\n    if (type === 'newListener' && !this.newListener) {\n      if (!this._events.newListener) {\n        return false;\n      }\n    }\n    var al = arguments.length;\n    var args, l, i, j;\n    var handler;\n    if (this._all && this._all.length) {\n      handler = this._all.slice();\n      if (al > 3) {\n        args = new Array(al);\n        for (j = 1; j < al; j++) args[j] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n          case 1:\n            handler[i].call(this, type);\n            break;\n          case 2:\n            handler[i].call(this, type, arguments[1]);\n            break;\n          case 3:\n            handler[i].call(this, type, arguments[1], arguments[2]);\n            break;\n          default:\n            handler[i].apply(this, args);\n        }\n      }\n    }\n    if (this.wildcard) {\n      handler = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n      if (typeof handler === 'function') {\n        this.event = type;\n        switch (al) {\n          case 1:\n            handler.call(this);\n            break;\n          case 2:\n            handler.call(this, arguments[1]);\n            break;\n          case 3:\n            handler.call(this, arguments[1], arguments[2]);\n            break;\n          default:\n            args = new Array(al - 1);\n            for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n            handler.apply(this, args);\n        }\n        return true;\n      } else if (handler) {\n        // need to make copy of handlers because list can change in the middle\n        // of emit call\n        handler = handler.slice();\n      }\n    }\n    if (handler && handler.length) {\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n          case 1:\n            handler[i].call(this);\n            break;\n          case 2:\n            handler[i].call(this, arguments[1]);\n            break;\n          case 3:\n            handler[i].call(this, arguments[1], arguments[2]);\n            break;\n          default:\n            handler[i].apply(this, args);\n        }\n      }\n      return true;\n    } else if (!this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n    return !!this._all;\n  };\n  EventEmitter.prototype.emitAsync = function () {\n    this._events || init.call(this);\n    var type = arguments[0];\n    if (type === 'newListener' && !this.newListener) {\n      if (!this._events.newListener) {\n        return Promise.resolve([false]);\n      }\n    }\n    var promises = [];\n    var al = arguments.length;\n    var args, l, i, j;\n    var handler;\n    if (this._all) {\n      if (al > 3) {\n        args = new Array(al);\n        for (j = 1; j < al; j++) args[j] = arguments[j];\n      }\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n          case 1:\n            promises.push(this._all[i].call(this, type));\n            break;\n          case 2:\n            promises.push(this._all[i].call(this, type, arguments[1]));\n            break;\n          case 3:\n            promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\n            break;\n          default:\n            promises.push(this._all[i].apply(this, args));\n        }\n      }\n    }\n    if (this.wildcard) {\n      handler = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n    }\n    if (typeof handler === 'function') {\n      this.event = type;\n      switch (al) {\n        case 1:\n          promises.push(handler.call(this));\n          break;\n        case 2:\n          promises.push(handler.call(this, arguments[1]));\n          break;\n        case 3:\n          promises.push(handler.call(this, arguments[1], arguments[2]));\n          break;\n        default:\n          args = new Array(al - 1);\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n          promises.push(handler.apply(this, args));\n      }\n    } else if (handler && handler.length) {\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n          case 1:\n            promises.push(handler[i].call(this));\n            break;\n          case 2:\n            promises.push(handler[i].call(this, arguments[1]));\n            break;\n          case 3:\n            promises.push(handler[i].call(this, arguments[1], arguments[2]));\n            break;\n          default:\n            promises.push(handler[i].apply(this, args));\n        }\n      }\n    } else if (!this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\n      } else {\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n    return Promise.all(promises);\n  };\n  EventEmitter.prototype.on = function (type, listener) {\n    if (typeof type === 'function') {\n      this.onAny(type);\n      return this;\n    }\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    this.emit('newListener', type, listener);\n    if (this.wildcard) {\n      growListenerTree.call(this, type, listener);\n      return this;\n    }\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    } else if (typeof this._events[type] === 'function') {\n      // Adding the second element, need to change to array.\n      this._events[type] = [this._events[type], listener];\n    } else if (isArray(this._events[type])) {\n      // If we've already got an array, just append.\n      this._events[type].push(listener);\n\n      // Check for listener leak\n      if (!this._events[type].warned) {\n        var m = defaultMaxListeners;\n        if (typeof this._events.maxListeners !== 'undefined') {\n          m = this._events.maxListeners;\n        }\n        if (m > 0 && this._events[type].length > m) {\n          this._events[type].warned = true;\n          console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);\n          if (console.trace) {\n            console.trace();\n          }\n        }\n      }\n    }\n    return this;\n  };\n  EventEmitter.prototype.onAny = function (fn) {\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n    if (!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    this._all.push(fn);\n    return this;\n  };\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n  EventEmitter.prototype.off = function (type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n    var handlers,\n      leafs = [];\n    if (this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n    } else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({\n        _listeners: handlers\n      });\n    }\n    for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n        var position = -1;\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {\n            position = i;\n            break;\n          }\n        }\n        if (position < 0) {\n          continue;\n        }\n        if (this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        } else {\n          this._events[type].splice(position, 1);\n        }\n        if (handlers.length === 0) {\n          if (this.wildcard) {\n            delete leaf._listeners;\n          } else {\n            delete this._events[type];\n          }\n        }\n        this.emit(\"removeListener\", type, listener);\n        return this;\n      } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {\n        if (this.wildcard) {\n          delete leaf._listeners;\n        } else {\n          delete this._events[type];\n        }\n        this.emit(\"removeListener\", type, listener);\n      }\n    }\n    function recursivelyGarbageCollect(root) {\n      if (root === undefined) {\n        return;\n      }\n      var keys = Object.keys(root);\n      for (var i in keys) {\n        var key = keys[i];\n        var obj = root[key];\n        if (obj instanceof Function || typeof obj !== \"object\") continue;\n        if (Object.keys(obj).length > 0) {\n          recursivelyGarbageCollect(root[key]);\n        }\n        if (Object.keys(obj).length === 0) {\n          delete root[key];\n        }\n      }\n    }\n    recursivelyGarbageCollect(this.listenerTree);\n    return this;\n  };\n  EventEmitter.prototype.offAny = function (fn) {\n    var i = 0,\n      l = 0,\n      fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for (i = 0, l = fns.length; i < l; i++) {\n        if (fn === fns[i]) {\n          fns.splice(i, 1);\n          this.emit(\"removeListenerAny\", fn);\n          return this;\n        }\n      }\n    } else {\n      fns = this._all;\n      for (i = 0, l = fns.length; i < l; i++) this.emit(\"removeListenerAny\", fns[i]);\n      this._all = [];\n    }\n    return this;\n  };\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n  EventEmitter.prototype.removeAllListeners = function (type) {\n    if (arguments.length === 0) {\n      !this._events || init.call(this);\n      return this;\n    }\n    if (this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n      for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {\n        var leaf = leafs[iLeaf];\n        leaf._listeners = null;\n      }\n    } else {\n      if (!this._events || !this._events[type]) return this;\n      this._events[type] = null;\n    }\n    return this;\n  };\n  EventEmitter.prototype.listeners = function (type) {\n    if (this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers;\n    }\n    this._events || init.call(this);\n    if (!this._events[type]) this._events[type] = [];\n    if (!isArray(this._events[type])) {\n      this._events[type] = [this._events[type]];\n    }\n    return this._events[type];\n  };\n  EventEmitter.prototype.listenersAny = function () {\n    if (this._all) {\n      return this._all;\n    } else {\n      return [];\n    }\n  };\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(function () {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = EventEmitter;\n  } else {\n    // Browser global.\n    window.EventEmitter2 = EventEmitter;\n  }\n}();","map":{"version":3,"names":["undefined","isArray","Array","_isArray","obj","Object","prototype","toString","call","defaultMaxListeners","init","_events","_conf","configure","conf","delimiter","maxListeners","wildcard","newListener","listenerTree","EventEmitter","EventEmitter2","searchListenerTree","handlers","type","tree","i","listeners","leaf","len","branch","xTree","xxTree","isolatedBranch","endReached","typeLength","length","currentType","nextType","_listeners","push","hasOwnProperty","concat","growListenerTree","listener","split","slice","name","shift","warned","m","console","error","trace","setMaxListeners","n","event","once","fn","many","ttl","self","Error","off","apply","arguments","_origin","on","emit","al","args","l","j","handler","_all","ns","emitAsync","Promise","resolve","promises","reject","all","onAny","addListener","leafs","iLeaf","position","splice","recursivelyGarbageCollect","root","keys","key","Function","offAny","fns","removeListener","removeAllListeners","listenersAny","define","amd","exports","module","window"],"sources":["C:/Users/ines_/bee_v2/bee_school/frontend/node_modules/eventemitter2/lib/eventemitter2.js"],"sourcesContent":["/*!\r\n * EventEmitter2\r\n * https://github.com/hij1nx/EventEmitter2\r\n *\r\n * Copyright (c) 2013 hij1nx\r\n * Licensed under the MIT license.\r\n */\r\n;!function(undefined) {\r\n\r\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\r\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\r\n  };\r\n  var defaultMaxListeners = 10;\r\n\r\n  function init() {\r\n    this._events = {};\r\n    if (this._conf) {\r\n      configure.call(this, this._conf);\r\n    }\r\n  }\r\n\r\n  function configure(conf) {\r\n    if (conf) {\r\n\r\n      this._conf = conf;\r\n\r\n      conf.delimiter && (this.delimiter = conf.delimiter);\r\n      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\r\n      conf.wildcard && (this.wildcard = conf.wildcard);\r\n      conf.newListener && (this.newListener = conf.newListener);\r\n\r\n      if (this.wildcard) {\r\n        this.listenerTree = {};\r\n      }\r\n    }\r\n  }\r\n\r\n  function EventEmitter(conf) {\r\n    this._events = {};\r\n    this.newListener = false;\r\n    configure.call(this, conf);\r\n  }\r\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\r\n\r\n  //\r\n  // Attention, function return type now is array, always !\r\n  // It has zero elements if no any matches found and one or more\r\n  // elements (leafs) if there are matches\r\n  //\r\n  function searchListenerTree(handlers, type, tree, i) {\r\n    if (!tree) {\r\n      return [];\r\n    }\r\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\r\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\r\n    if (i === typeLength && tree._listeners) {\r\n      //\r\n      // If at the end of the event(s) list and the tree has listeners\r\n      // invoke those listeners.\r\n      //\r\n      if (typeof tree._listeners === 'function') {\r\n        handlers && handlers.push(tree._listeners);\r\n        return [tree];\r\n      } else {\r\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\r\n          handlers && handlers.push(tree._listeners[leaf]);\r\n        }\r\n        return [tree];\r\n      }\r\n    }\r\n\r\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\r\n      //\r\n      // If the event emitted is '*' at this part\r\n      // or there is a concrete match at this patch\r\n      //\r\n      if (currentType === '*') {\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\r\n          }\r\n        }\r\n        return listeners;\r\n      } else if(currentType === '**') {\r\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\r\n        if(endReached && tree._listeners) {\r\n          // The next element has a _listeners, add it to the handlers.\r\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\r\n        }\r\n\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            if(branch === '*' || branch === '**') {\r\n              if(tree[branch]._listeners && !endReached) {\r\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\r\n              }\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            } else if(branch === nextType) {\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\r\n            } else {\r\n              // No match on this one, shift into the tree but not in the type array.\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            }\r\n          }\r\n        }\r\n        return listeners;\r\n      }\r\n\r\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\r\n    }\r\n\r\n    xTree = tree['*'];\r\n    if (xTree) {\r\n      //\r\n      // If the listener tree will allow any match for this part,\r\n      // then recursively explore all branches of the tree\r\n      //\r\n      searchListenerTree(handlers, type, xTree, i+1);\r\n    }\r\n\r\n    xxTree = tree['**'];\r\n    if(xxTree) {\r\n      if(i < typeLength) {\r\n        if(xxTree._listeners) {\r\n          // If we have a listener on a '**', it will catch all, so add its handler.\r\n          searchListenerTree(handlers, type, xxTree, typeLength);\r\n        }\r\n\r\n        // Build arrays of matching next branches and others.\r\n        for(branch in xxTree) {\r\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\r\n            if(branch === nextType) {\r\n              // We know the next element will match, so jump twice.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\r\n            } else if(branch === currentType) {\r\n              // Current node matches, move into the tree.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\r\n            } else {\r\n              isolatedBranch = {};\r\n              isolatedBranch[branch] = xxTree[branch];\r\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\r\n            }\r\n          }\r\n        }\r\n      } else if(xxTree._listeners) {\r\n        // We have reached the end and still on a '**'\r\n        searchListenerTree(handlers, type, xxTree, typeLength);\r\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\r\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\r\n      }\r\n    }\r\n\r\n    return listeners;\r\n  }\r\n\r\n  function growListenerTree(type, listener) {\r\n\r\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n\r\n    //\r\n    // Looks for two consecutive '**', if so, don't add the event at all.\r\n    //\r\n    for(var i = 0, len = type.length; i+1 < len; i++) {\r\n      if(type[i] === '**' && type[i+1] === '**') {\r\n        return;\r\n      }\r\n    }\r\n\r\n    var tree = this.listenerTree;\r\n    var name = type.shift();\r\n\r\n    while (name) {\r\n\r\n      if (!tree[name]) {\r\n        tree[name] = {};\r\n      }\r\n\r\n      tree = tree[name];\r\n\r\n      if (type.length === 0) {\r\n\r\n        if (!tree._listeners) {\r\n          tree._listeners = listener;\r\n        }\r\n        else if(typeof tree._listeners === 'function') {\r\n          tree._listeners = [tree._listeners, listener];\r\n        }\r\n        else if (isArray(tree._listeners)) {\r\n\r\n          tree._listeners.push(listener);\r\n\r\n          if (!tree._listeners.warned) {\r\n\r\n            var m = defaultMaxListeners;\r\n\r\n            if (typeof this._events.maxListeners !== 'undefined') {\r\n              m = this._events.maxListeners;\r\n            }\r\n\r\n            if (m > 0 && tree._listeners.length > m) {\r\n\r\n              tree._listeners.warned = true;\r\n              console.error('(node) warning: possible EventEmitter memory ' +\r\n                            'leak detected. %d listeners added. ' +\r\n                            'Use emitter.setMaxListeners() to increase limit.',\r\n                            tree._listeners.length);\r\n              if(console.trace){\r\n                console.trace();\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      name = type.shift();\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // By default EventEmitters will print a warning if more than\r\n  // 10 listeners are added to it. This is a useful default which\r\n  // helps finding memory leaks.\r\n  //\r\n  // Obviously not all Emitters should be limited to 10. This function allows\r\n  // that to be increased. Set to zero for unlimited.\r\n\r\n  EventEmitter.prototype.delimiter = '.';\r\n\r\n  EventEmitter.prototype.setMaxListeners = function(n) {\r\n    this._events || init.call(this);\r\n    this._events.maxListeners = n;\r\n    if (!this._conf) this._conf = {};\r\n    this._conf.maxListeners = n;\r\n  };\r\n\r\n  EventEmitter.prototype.event = '';\r\n\r\n  EventEmitter.prototype.once = function(event, fn) {\r\n    this.many(event, 1, fn);\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.many = function(event, ttl, fn) {\r\n    var self = this;\r\n\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('many only accepts instances of Function');\r\n    }\r\n\r\n    function listener() {\r\n      if (--ttl === 0) {\r\n        self.off(event, listener);\r\n      }\r\n      fn.apply(this, arguments);\r\n    }\r\n\r\n    listener._origin = fn;\r\n\r\n    this.on(event, listener);\r\n\r\n    return self;\r\n  };\r\n\r\n  EventEmitter.prototype.emit = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this.newListener) {\r\n      if (!this._events.newListener) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    var al = arguments.length;\r\n    var args,l,i,j;\r\n    var handler;\r\n\r\n    if (this._all && this._all.length) {\r\n      handler = this._all.slice();\r\n      if (al > 3) {\r\n        args = new Array(al);\r\n        for (j = 1; j < al; j++) args[j] = arguments[j];\r\n      }\r\n\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler[i].call(this, type);\r\n          break;\r\n        case 2:\r\n          handler[i].call(this, type, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler[i].call(this, type, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          handler[i].apply(this, args);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    } else {\r\n      handler = this._events[type];\r\n      if (typeof handler === 'function') {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler.call(this);\r\n          break;\r\n        case 2:\r\n          handler.call(this, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler.call(this, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          args = new Array(al - 1);\r\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n          handler.apply(this, args);\r\n        }\r\n        return true;\r\n      } else if (handler) {\r\n        // need to make copy of handlers because list can change in the middle\r\n        // of emit call\r\n        handler = handler.slice();\r\n      }\r\n    }\r\n\r\n    if (handler && handler.length) {\r\n      if (al > 3) {\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n      }\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler[i].call(this);\r\n          break;\r\n        case 2:\r\n          handler[i].call(this, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler[i].call(this, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          handler[i].apply(this, args);\r\n        }\r\n      }\r\n      return true;\r\n    } else if (!this._all && type === 'error') {\r\n      if (arguments[1] instanceof Error) {\r\n        throw arguments[1]; // Unhandled 'error' event\r\n      } else {\r\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n      return false;\r\n    }\r\n\r\n    return !!this._all;\r\n  };\r\n\r\n  EventEmitter.prototype.emitAsync = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this.newListener) {\r\n        if (!this._events.newListener) { return Promise.resolve([false]); }\r\n    }\r\n\r\n    var promises= [];\r\n\r\n    var al = arguments.length;\r\n    var args,l,i,j;\r\n    var handler;\r\n\r\n    if (this._all) {\r\n      if (al > 3) {\r\n        args = new Array(al);\r\n        for (j = 1; j < al; j++) args[j] = arguments[j];\r\n      }\r\n      for (i = 0, l = this._all.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          promises.push(this._all[i].call(this, type));\r\n          break;\r\n        case 2:\r\n          promises.push(this._all[i].call(this, type, arguments[1]));\r\n          break;\r\n        case 3:\r\n          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\r\n          break;\r\n        default:\r\n          promises.push(this._all[i].apply(this, args));\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    } else {\r\n      handler = this._events[type];\r\n    }\r\n\r\n    if (typeof handler === 'function') {\r\n      this.event = type;\r\n      switch (al) {\r\n      case 1:\r\n        promises.push(handler.call(this));\r\n        break;\r\n      case 2:\r\n        promises.push(handler.call(this, arguments[1]));\r\n        break;\r\n      case 3:\r\n        promises.push(handler.call(this, arguments[1], arguments[2]));\r\n        break;\r\n      default:\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n        promises.push(handler.apply(this, args));\r\n      }\r\n    } else if (handler && handler.length) {\r\n      if (al > 3) {\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n      }\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          promises.push(handler[i].call(this));\r\n          break;\r\n        case 2:\r\n          promises.push(handler[i].call(this, arguments[1]));\r\n          break;\r\n        case 3:\r\n          promises.push(handler[i].call(this, arguments[1], arguments[2]));\r\n          break;\r\n        default:\r\n          promises.push(handler[i].apply(this, args));\r\n        }\r\n      }\r\n    } else if (!this._all && type === 'error') {\r\n      if (arguments[1] instanceof Error) {\r\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\r\n      } else {\r\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n    }\r\n\r\n    return Promise.all(promises);\r\n  };\r\n\r\n  EventEmitter.prototype.on = function(type, listener) {\r\n\r\n    if (typeof type === 'function') {\r\n      this.onAny(type);\r\n      return this;\r\n    }\r\n\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('on only accepts instances of Function');\r\n    }\r\n    this._events || init.call(this);\r\n\r\n    // To avoid recursion in the case that type == \"newListeners\"! Before\r\n    // adding it to the listeners, first emit \"newListeners\".\r\n    this.emit('newListener', type, listener);\r\n\r\n    if(this.wildcard) {\r\n      growListenerTree.call(this, type, listener);\r\n      return this;\r\n    }\r\n\r\n    if (!this._events[type]) {\r\n      // Optimize the case of one listener. Don't need the extra array object.\r\n      this._events[type] = listener;\r\n    }\r\n    else if(typeof this._events[type] === 'function') {\r\n      // Adding the second element, need to change to array.\r\n      this._events[type] = [this._events[type], listener];\r\n    }\r\n    else if (isArray(this._events[type])) {\r\n      // If we've already got an array, just append.\r\n      this._events[type].push(listener);\r\n\r\n      // Check for listener leak\r\n      if (!this._events[type].warned) {\r\n\r\n        var m = defaultMaxListeners;\r\n\r\n        if (typeof this._events.maxListeners !== 'undefined') {\r\n          m = this._events.maxListeners;\r\n        }\r\n\r\n        if (m > 0 && this._events[type].length > m) {\r\n\r\n          this._events[type].warned = true;\r\n          console.error('(node) warning: possible EventEmitter memory ' +\r\n                        'leak detected. %d listeners added. ' +\r\n                        'Use emitter.setMaxListeners() to increase limit.',\r\n                        this._events[type].length);\r\n          if(console.trace){\r\n            console.trace();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.onAny = function(fn) {\r\n\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('onAny only accepts instances of Function');\r\n    }\r\n\r\n    if(!this._all) {\r\n      this._all = [];\r\n    }\r\n\r\n    // Add the function to the event listener collection.\r\n    this._all.push(fn);\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\r\n  EventEmitter.prototype.off = function(type, listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('removeListener only takes instances of Function');\r\n    }\r\n\r\n    var handlers,leafs=[];\r\n\r\n    if(this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n    }\r\n    else {\r\n      // does not use listeners(), so no side effect of creating _events[type]\r\n      if (!this._events[type]) return this;\r\n      handlers = this._events[type];\r\n      leafs.push({_listeners:handlers});\r\n    }\r\n\r\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n      var leaf = leafs[iLeaf];\r\n      handlers = leaf._listeners;\r\n      if (isArray(handlers)) {\r\n\r\n        var position = -1;\r\n\r\n        for (var i = 0, length = handlers.length; i < length; i++) {\r\n          if (handlers[i] === listener ||\r\n            (handlers[i].listener && handlers[i].listener === listener) ||\r\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\r\n            position = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (position < 0) {\r\n          continue;\r\n        }\r\n\r\n        if(this.wildcard) {\r\n          leaf._listeners.splice(position, 1);\r\n        }\r\n        else {\r\n          this._events[type].splice(position, 1);\r\n        }\r\n\r\n        if (handlers.length === 0) {\r\n          if(this.wildcard) {\r\n            delete leaf._listeners;\r\n          }\r\n          else {\r\n            delete this._events[type];\r\n          }\r\n        }\r\n\r\n        this.emit(\"removeListener\", type, listener);\r\n\r\n        return this;\r\n      }\r\n      else if (handlers === listener ||\r\n        (handlers.listener && handlers.listener === listener) ||\r\n        (handlers._origin && handlers._origin === listener)) {\r\n        if(this.wildcard) {\r\n          delete leaf._listeners;\r\n        }\r\n        else {\r\n          delete this._events[type];\r\n        }\r\n\r\n        this.emit(\"removeListener\", type, listener);\r\n      }\r\n    }\r\n\r\n    function recursivelyGarbageCollect(root) {\r\n      if (root === undefined) {\r\n        return;\r\n      }\r\n      var keys = Object.keys(root);\r\n      for (var i in keys) {\r\n        var key = keys[i];\r\n        var obj = root[key];\r\n        if ((obj instanceof Function) || (typeof obj !== \"object\"))\r\n          continue;\r\n        if (Object.keys(obj).length > 0) {\r\n          recursivelyGarbageCollect(root[key]);\r\n        }\r\n        if (Object.keys(obj).length === 0) {\r\n          delete root[key];\r\n        }\r\n      }\r\n    }\r\n    recursivelyGarbageCollect(this.listenerTree);\r\n\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.offAny = function(fn) {\r\n    var i = 0, l = 0, fns;\r\n    if (fn && this._all && this._all.length > 0) {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++) {\r\n        if(fn === fns[i]) {\r\n          fns.splice(i, 1);\r\n          this.emit(\"removeListenerAny\", fn);\r\n          return this;\r\n        }\r\n      }\r\n    } else {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++)\r\n        this.emit(\"removeListenerAny\", fns[i]);\r\n      this._all = [];\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\r\n\r\n  EventEmitter.prototype.removeAllListeners = function(type) {\r\n    if (arguments.length === 0) {\r\n      !this._events || init.call(this);\r\n      return this;\r\n    }\r\n\r\n    if(this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n\r\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n        var leaf = leafs[iLeaf];\r\n        leaf._listeners = null;\r\n      }\r\n    }\r\n    else {\r\n      if (!this._events || !this._events[type]) return this;\r\n      this._events[type] = null;\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.listeners = function(type) {\r\n    if(this.wildcard) {\r\n      var handlers = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\r\n      return handlers;\r\n    }\r\n\r\n    this._events || init.call(this);\r\n\r\n    if (!this._events[type]) this._events[type] = [];\r\n    if (!isArray(this._events[type])) {\r\n      this._events[type] = [this._events[type]];\r\n    }\r\n    return this._events[type];\r\n  };\r\n\r\n  EventEmitter.prototype.listenersAny = function() {\r\n\r\n    if(this._all) {\r\n      return this._all;\r\n    }\r\n    else {\r\n      return [];\r\n    }\r\n\r\n  };\r\n\r\n  if (typeof define === 'function' && define.amd) {\r\n     // AMD. Register as an anonymous module.\r\n    define(function() {\r\n      return EventEmitter;\r\n    });\r\n  } else if (typeof exports === 'object') {\r\n    // CommonJS\r\n    module.exports = EventEmitter;\r\n  }\r\n  else {\r\n    // Browser global.\r\n    window.EventEmitter2 = EventEmitter;\r\n  }\r\n}();\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}