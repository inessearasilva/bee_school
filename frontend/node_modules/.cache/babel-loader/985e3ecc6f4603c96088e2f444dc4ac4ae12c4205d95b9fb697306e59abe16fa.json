{"ast":null,"code":"const replaceValuesJDT = (jdt, composition) => {\n  if (!composition) {\n    // handle the case where composition is undefined or null\n    return jdt;\n  }\n\n  // make a copy of the jdt\n  let newJDT = {\n    ...jdt\n  };\n\n  // regular expression to remove everything in the composition except the itemPath\n  const regex = /((?!value|start|end|date|time|unit).)*/g;\n\n  // get all itemPaths from the composition using the regular expression\n  const compositionKeys = Object.keys(composition).map(key => key.match(regex)[0].slice(0, -1));\n\n  // array to hold the values of selected options\n  const selectedOptionValues = [];\n\n  // iterate through each itemPath in the composition\n  for (let index in compositionKeys) {\n    let itemPath = compositionKeys[index];\n\n    // get the corresponding item in the JDT\n    let obj = objPath.get(newJDT, itemPath);\n\n    // if the item is found, replace its value with the value from the composition\n    if (obj !== undefined) {\n      switch (obj.dataType) {\n        case \"DV_DATE_TIME\":\n          obj.value.date = composition[itemPath.concat(\".value.date\")];\n          obj.value.time = composition[itemPath.concat(\".value.time\")];\n          break;\n        case \"DV_DURATION\":\n        case \"DV_QUANTITY\":\n          obj.value.value = composition[itemPath.concat(\".value.value\")];\n          obj.value.unit = composition[itemPath.concat(\".value.unit\")];\n          break;\n        case \"DV_INTERVAL<DV_DATE>\":\n        case \"DV_INTERVAL<DV_COUNT>\":\n        case \"DV_INTERVAL<DV_TIME>\":\n          obj.value.start = composition[itemPath.concat(\".value.start\")];\n          obj.value.end = composition[itemPath.concat(\".value.end\")];\n          break;\n        case \"DV_INTERVAL<DV_DATE_TIME>\":\n          obj.value.date.start = composition[itemPath.concat(\".value.date.start\")];\n          obj.value.date.end = composition[itemPath.concat(\".value.date.end\")];\n          obj.value.time.start = composition[itemPath.concat(\".value.time.start\")];\n          obj.value.time.end = composition[itemPath.concat(\".value.time.end\")];\n          break;\n        case \"DV_INTERVAL<DV_QUANTITY>\":\n          obj.value.value.start = composition[itemPath.concat(\".value.value.start\")];\n          obj.value.value.end = composition[itemPath.concat(\".value.value.end\")];\n          obj.value.unit = composition[itemPath.concat(\".value.unit\")];\n          break;\n        default:\n          // for all other data types, replace the value property\n          obj.value = composition[itemPath.concat(\".value\")];\n\n          // if the value property is a number, add it to the selectedOptionValues array\n          if (typeof obj.value === \"number\") {\n            selectedOptionValues.push(obj.value);\n          }\n      }\n    }\n  }\n\n  // calculate the total score by summing the values of selected options\n  const totalScore = selectedOptionValues.reduce((acc, curr) => acc + curr, 0);\n\n  // update the Total Score item in the JDT with the calculated value\n  objPath.set(newJDT, \"items.0.0.items.12.value\", totalScore);\n  return newJDT;\n};\nexport { replaceValuesJDT };","map":{"version":3,"names":["replaceValuesJDT","jdt","composition","newJDT","regex","compositionKeys","Object","keys","map","key","match","slice","selectedOptionValues","index","itemPath","obj","objPath","get","undefined","dataType","value","date","concat","time","unit","start","end","push","totalScore","reduce","acc","curr","set"],"sources":["C:/Users/ines_/fisiosys/frontend/src/views/dashboard/SavedValues.js"],"sourcesContent":["const replaceValuesJDT = (jdt, composition) => {\r\n    if (!composition) {\r\n      // handle the case where composition is undefined or null\r\n      return jdt;\r\n    }\r\n  \r\n    // make a copy of the jdt\r\n    let newJDT = { ...jdt };\r\n  \r\n    // regular expression to remove everything in the composition except the itemPath\r\n    const regex = /((?!value|start|end|date|time|unit).)*/g;\r\n  \r\n    // get all itemPaths from the composition using the regular expression\r\n    const compositionKeys = Object.keys(composition).map((key) =>\r\n      key.match(regex)[0].slice(0, -1)\r\n    );\r\n  \r\n    // array to hold the values of selected options\r\n    const selectedOptionValues = [];\r\n  \r\n    // iterate through each itemPath in the composition\r\n    for (let index in compositionKeys) {\r\n      let itemPath = compositionKeys[index];\r\n  \r\n      // get the corresponding item in the JDT\r\n      let obj = objPath.get(newJDT, itemPath);\r\n  \r\n      // if the item is found, replace its value with the value from the composition\r\n      if (obj !== undefined) {\r\n        switch (obj.dataType) {\r\n          case \"DV_DATE_TIME\":\r\n            obj.value.date = composition[itemPath.concat(\".value.date\")];\r\n            obj.value.time = composition[itemPath.concat(\".value.time\")];\r\n            break;\r\n          case \"DV_DURATION\":\r\n          case \"DV_QUANTITY\":\r\n            obj.value.value = composition[itemPath.concat(\".value.value\")];\r\n            obj.value.unit = composition[itemPath.concat(\".value.unit\")];\r\n            break;\r\n          case \"DV_INTERVAL<DV_DATE>\":\r\n          case \"DV_INTERVAL<DV_COUNT>\":\r\n          case \"DV_INTERVAL<DV_TIME>\":\r\n            obj.value.start = composition[itemPath.concat(\".value.start\")];\r\n            obj.value.end = composition[itemPath.concat(\".value.end\")];\r\n            break;\r\n          case \"DV_INTERVAL<DV_DATE_TIME>\":\r\n            obj.value.date.start = composition[itemPath.concat(\".value.date.start\")];\r\n            obj.value.date.end = composition[itemPath.concat(\".value.date.end\")];\r\n            obj.value.time.start = composition[itemPath.concat(\".value.time.start\")];\r\n            obj.value.time.end = composition[itemPath.concat(\".value.time.end\")];\r\n            break;\r\n          case \"DV_INTERVAL<DV_QUANTITY>\":\r\n            obj.value.value.start = composition[itemPath.concat(\".value.value.start\")];\r\n            obj.value.value.end = composition[itemPath.concat(\".value.value.end\")];\r\n            obj.value.unit = composition[itemPath.concat(\".value.unit\")];\r\n            break;\r\n          default:\r\n            // for all other data types, replace the value property\r\n            obj.value = composition[itemPath.concat(\".value\")];\r\n            \r\n            // if the value property is a number, add it to the selectedOptionValues array\r\n            if (typeof obj.value === \"number\") {\r\n              selectedOptionValues.push(obj.value);\r\n            }\r\n        }\r\n      }\r\n    }\r\n  \r\n    // calculate the total score by summing the values of selected options\r\n    const totalScore = selectedOptionValues.reduce((acc, curr) => acc + curr, 0);\r\n  \r\n    // update the Total Score item in the JDT with the calculated value\r\n    objPath.set(newJDT, \"items.0.0.items.12.value\", totalScore);\r\n  \r\n    return newJDT;\r\n  };\r\n  \r\n  export { replaceValuesJDT };\r\n  "],"mappings":"AAAA,MAAMA,gBAAgB,GAAG,CAACC,GAAG,EAAEC,WAAW,KAAK;EAC3C,IAAI,CAACA,WAAW,EAAE;IAChB;IACA,OAAOD,GAAG;EACZ;;EAEA;EACA,IAAIE,MAAM,GAAG;IAAE,GAAGF;EAAI,CAAC;;EAEvB;EACA,MAAMG,KAAK,GAAG,yCAAyC;;EAEvD;EACA,MAAMC,eAAe,GAAGC,MAAM,CAACC,IAAI,CAACL,WAAW,CAAC,CAACM,GAAG,CAAEC,GAAG,IACvDA,GAAG,CAACC,KAAK,CAACN,KAAK,CAAC,CAAC,CAAC,CAAC,CAACO,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CACjC;;EAED;EACA,MAAMC,oBAAoB,GAAG,EAAE;;EAE/B;EACA,KAAK,IAAIC,KAAK,IAAIR,eAAe,EAAE;IACjC,IAAIS,QAAQ,GAAGT,eAAe,CAACQ,KAAK,CAAC;;IAErC;IACA,IAAIE,GAAG,GAAGC,OAAO,CAACC,GAAG,CAACd,MAAM,EAAEW,QAAQ,CAAC;;IAEvC;IACA,IAAIC,GAAG,KAAKG,SAAS,EAAE;MACrB,QAAQH,GAAG,CAACI,QAAQ;QAClB,KAAK,cAAc;UACjBJ,GAAG,CAACK,KAAK,CAACC,IAAI,GAAGnB,WAAW,CAACY,QAAQ,CAACQ,MAAM,CAAC,aAAa,CAAC,CAAC;UAC5DP,GAAG,CAACK,KAAK,CAACG,IAAI,GAAGrB,WAAW,CAACY,QAAQ,CAACQ,MAAM,CAAC,aAAa,CAAC,CAAC;UAC5D;QACF,KAAK,aAAa;QAClB,KAAK,aAAa;UAChBP,GAAG,CAACK,KAAK,CAACA,KAAK,GAAGlB,WAAW,CAACY,QAAQ,CAACQ,MAAM,CAAC,cAAc,CAAC,CAAC;UAC9DP,GAAG,CAACK,KAAK,CAACI,IAAI,GAAGtB,WAAW,CAACY,QAAQ,CAACQ,MAAM,CAAC,aAAa,CAAC,CAAC;UAC5D;QACF,KAAK,sBAAsB;QAC3B,KAAK,uBAAuB;QAC5B,KAAK,sBAAsB;UACzBP,GAAG,CAACK,KAAK,CAACK,KAAK,GAAGvB,WAAW,CAACY,QAAQ,CAACQ,MAAM,CAAC,cAAc,CAAC,CAAC;UAC9DP,GAAG,CAACK,KAAK,CAACM,GAAG,GAAGxB,WAAW,CAACY,QAAQ,CAACQ,MAAM,CAAC,YAAY,CAAC,CAAC;UAC1D;QACF,KAAK,2BAA2B;UAC9BP,GAAG,CAACK,KAAK,CAACC,IAAI,CAACI,KAAK,GAAGvB,WAAW,CAACY,QAAQ,CAACQ,MAAM,CAAC,mBAAmB,CAAC,CAAC;UACxEP,GAAG,CAACK,KAAK,CAACC,IAAI,CAACK,GAAG,GAAGxB,WAAW,CAACY,QAAQ,CAACQ,MAAM,CAAC,iBAAiB,CAAC,CAAC;UACpEP,GAAG,CAACK,KAAK,CAACG,IAAI,CAACE,KAAK,GAAGvB,WAAW,CAACY,QAAQ,CAACQ,MAAM,CAAC,mBAAmB,CAAC,CAAC;UACxEP,GAAG,CAACK,KAAK,CAACG,IAAI,CAACG,GAAG,GAAGxB,WAAW,CAACY,QAAQ,CAACQ,MAAM,CAAC,iBAAiB,CAAC,CAAC;UACpE;QACF,KAAK,0BAA0B;UAC7BP,GAAG,CAACK,KAAK,CAACA,KAAK,CAACK,KAAK,GAAGvB,WAAW,CAACY,QAAQ,CAACQ,MAAM,CAAC,oBAAoB,CAAC,CAAC;UAC1EP,GAAG,CAACK,KAAK,CAACA,KAAK,CAACM,GAAG,GAAGxB,WAAW,CAACY,QAAQ,CAACQ,MAAM,CAAC,kBAAkB,CAAC,CAAC;UACtEP,GAAG,CAACK,KAAK,CAACI,IAAI,GAAGtB,WAAW,CAACY,QAAQ,CAACQ,MAAM,CAAC,aAAa,CAAC,CAAC;UAC5D;QACF;UACE;UACAP,GAAG,CAACK,KAAK,GAAGlB,WAAW,CAACY,QAAQ,CAACQ,MAAM,CAAC,QAAQ,CAAC,CAAC;;UAElD;UACA,IAAI,OAAOP,GAAG,CAACK,KAAK,KAAK,QAAQ,EAAE;YACjCR,oBAAoB,CAACe,IAAI,CAACZ,GAAG,CAACK,KAAK,CAAC;UACtC;MAAC;IAEP;EACF;;EAEA;EACA,MAAMQ,UAAU,GAAGhB,oBAAoB,CAACiB,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAKD,GAAG,GAAGC,IAAI,EAAE,CAAC,CAAC;;EAE5E;EACAf,OAAO,CAACgB,GAAG,CAAC7B,MAAM,EAAE,0BAA0B,EAAEyB,UAAU,CAAC;EAE3D,OAAOzB,MAAM;AACf,CAAC;AAED,SAASH,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}