{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * \r\n * @emails oncall+draft_js\r\n */\n'use strict';\n\nvar DraftModifier = require(\"./DraftModifier\");\nvar EditorState = require(\"./EditorState\");\nvar UserAgent = require(\"fbjs/lib/UserAgent\");\nvar getEntityKeyForSelection = require(\"./getEntityKeyForSelection\");\nvar isEventHandled = require(\"./isEventHandled\");\nvar isSelectionAtLeafStart = require(\"./isSelectionAtLeafStart\");\nvar nullthrows = require(\"fbjs/lib/nullthrows\");\nvar setImmediate = require(\"fbjs/lib/setImmediate\"); // When nothing is focused, Firefox regards two characters, `'` and `/`, as\n// commands that should open and focus the \"quickfind\" search bar. This should\n// *never* happen while a contenteditable is focused, but as of v28, it\n// sometimes does, even when the keypress event target is the contenteditable.\n// This breaks the input. Special case these characters to ensure that when\n// they are typed, we prevent default on the event to make sure not to\n// trigger quickfind.\n\nvar FF_QUICKFIND_CHAR = \"'\";\nvar FF_QUICKFIND_LINK_CHAR = '/';\nvar isFirefox = UserAgent.isBrowser('Firefox');\nfunction mustPreventDefaultForCharacter(character) {\n  return isFirefox && (character == FF_QUICKFIND_CHAR || character == FF_QUICKFIND_LINK_CHAR);\n}\n/**\r\n * Replace the current selection with the specified text string, with the\r\n * inline style and entity key applied to the newly inserted text.\r\n */\n\nfunction replaceText(editorState, text, inlineStyle, entityKey, forceSelection) {\n  var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), text, inlineStyle, entityKey);\n  return EditorState.push(editorState, contentState, 'insert-characters', forceSelection);\n}\n/**\r\n * When `onBeforeInput` executes, the browser is attempting to insert a\r\n * character into the editor. Apply this character data to the document,\r\n * allowing native insertion if possible.\r\n *\r\n * Native insertion is encouraged in order to limit re-rendering and to\r\n * preserve spellcheck highlighting, which disappears or flashes if re-render\r\n * occurs on the relevant text nodes.\r\n */\n\nfunction editOnBeforeInput(editor, e) {\n  if (editor._pendingStateFromBeforeInput !== undefined) {\n    editor.update(editor._pendingStateFromBeforeInput);\n    editor._pendingStateFromBeforeInput = undefined;\n  }\n  var editorState = editor._latestEditorState;\n  var chars = e.data; // In some cases (ex: IE ideographic space insertion) no character data\n  // is provided. There's nothing to do when this happens.\n\n  if (!chars) {\n    return;\n  } // Allow the top-level component to handle the insertion manually. This is\n  // useful when triggering interesting behaviors for a character insertion,\n  // Simple examples: replacing a raw text ':)' with a smile emoji or image\n  // decorator, or setting a block to be a list item after typing '- ' at the\n  // start of the block.\n\n  if (editor.props.handleBeforeInput && isEventHandled(editor.props.handleBeforeInput(chars, editorState, e.timeStamp))) {\n    e.preventDefault();\n    return;\n  } // If selection is collapsed, conditionally allow native behavior. This\n  // reduces re-renders and preserves spellcheck highlighting. If the selection\n  // is not collapsed, we will re-render.\n\n  var selection = editorState.getSelection();\n  var selectionStart = selection.getStartOffset();\n  var anchorKey = selection.getAnchorKey();\n  if (!selection.isCollapsed()) {\n    e.preventDefault();\n    editor.update(replaceText(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection()), true));\n    return;\n  }\n  var newEditorState = replaceText(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection()), false); // Bunch of different cases follow where we need to prevent native insertion.\n\n  var mustPreventNative = false;\n  if (!mustPreventNative) {\n    // Browsers tend to insert text in weird places in the DOM when typing at\n    // the start of a leaf, so we'll handle it ourselves.\n    mustPreventNative = isSelectionAtLeafStart(editor._latestCommittedEditorState);\n  }\n  if (!mustPreventNative) {\n    // Let's say we have a decorator that highlights hashtags. In many cases\n    // we need to prevent native behavior and rerender ourselves --\n    // particularly, any case *except* where the inserted characters end up\n    // anywhere except exactly where you put them.\n    //\n    // Using [] to denote a decorated leaf, some examples:\n    //\n    // 1. 'hi #' and append 'f'\n    // desired rendering: 'hi [#f]'\n    // native rendering would be: 'hi #f' (incorrect)\n    //\n    // 2. 'x [#foo]' and insert '#' before 'f'\n    // desired rendering: 'x #[#foo]'\n    // native rendering would be: 'x [##foo]' (incorrect)\n    //\n    // 3. '[#foobar]' and insert ' ' between 'foo' and 'bar'\n    // desired rendering: '[#foo] bar'\n    // native rendering would be: '[#foo bar]' (incorrect)\n    //\n    // 4. '[#foo]' and delete '#' [won't use this beforeinput codepath though]\n    // desired rendering: 'foo'\n    // native rendering would be: '[foo]' (incorrect)\n    //\n    // 5. '[#foo]' and append 'b'\n    // desired rendering: '[#foob]'\n    // native rendering would be: '[#foob]'\n    // (native insertion here would be ok for decorators like simple spans,\n    // but not more complex decorators. To be safe, we need to prevent it.)\n    //\n    // It is safe to allow native insertion if and only if the full list of\n    // decorator ranges matches what we expect native insertion to give, and\n    // the range lengths have not changed. We don't need to compare the content\n    // because the only possible mutation to consider here is inserting plain\n    // text and decorators can't affect text content.\n    var oldBlockTree = editorState.getBlockTree(anchorKey);\n    var newBlockTree = newEditorState.getBlockTree(anchorKey);\n    mustPreventNative = oldBlockTree.size !== newBlockTree.size || oldBlockTree.zip(newBlockTree).some(function (_ref) {\n      var oldLeafSet = _ref[0],\n        newLeafSet = _ref[1];\n      // selectionStart is guaranteed to be selectionEnd here\n      var oldStart = oldLeafSet.get('start');\n      var adjustedStart = oldStart + (oldStart >= selectionStart ? chars.length : 0);\n      var oldEnd = oldLeafSet.get('end');\n      var adjustedEnd = oldEnd + (oldEnd >= selectionStart ? chars.length : 0);\n      var newStart = newLeafSet.get('start');\n      var newEnd = newLeafSet.get('end');\n      var newDecoratorKey = newLeafSet.get('decoratorKey');\n      return (\n        // Different decorators\n        oldLeafSet.get('decoratorKey') !== newDecoratorKey ||\n        // Different number of inline styles\n        oldLeafSet.get('leaves').size !== newLeafSet.get('leaves').size ||\n        // Different effective decorator position\n        adjustedStart !== newStart || adjustedEnd !== newEnd ||\n        // Decorator already existed and its length changed\n        newDecoratorKey != null && newEnd - newStart !== oldEnd - oldStart\n      );\n    });\n  }\n  if (!mustPreventNative) {\n    mustPreventNative = mustPreventDefaultForCharacter(chars);\n  }\n  if (!mustPreventNative) {\n    mustPreventNative = nullthrows(newEditorState.getDirectionMap()).get(anchorKey) !== nullthrows(editorState.getDirectionMap()).get(anchorKey);\n  }\n  if (mustPreventNative) {\n    e.preventDefault();\n    newEditorState = EditorState.set(newEditorState, {\n      forceSelection: true\n    });\n    editor.update(newEditorState);\n    return;\n  } // We made it all the way! Let the browser do its thing and insert the char.\n\n  newEditorState = EditorState.set(newEditorState, {\n    nativelyRenderedContent: newEditorState.getCurrentContent()\n  }); // The native event is allowed to occur. To allow user onChange handlers to\n  // change the inserted text, we wait until the text is actually inserted\n  // before we actually update our state. That way when we rerender, the text\n  // we see in the DOM will already have been inserted properly.\n\n  editor._pendingStateFromBeforeInput = newEditorState;\n  setImmediate(function () {\n    if (editor._pendingStateFromBeforeInput !== undefined) {\n      editor.update(editor._pendingStateFromBeforeInput);\n      editor._pendingStateFromBeforeInput = undefined;\n    }\n  });\n}\nmodule.exports = editOnBeforeInput;","map":{"version":3,"names":["DraftModifier","require","EditorState","UserAgent","getEntityKeyForSelection","isEventHandled","isSelectionAtLeafStart","nullthrows","setImmediate","FF_QUICKFIND_CHAR","FF_QUICKFIND_LINK_CHAR","isFirefox","isBrowser","mustPreventDefaultForCharacter","character","replaceText","editorState","text","inlineStyle","entityKey","forceSelection","contentState","getCurrentContent","getSelection","push","editOnBeforeInput","editor","e","_pendingStateFromBeforeInput","undefined","update","_latestEditorState","chars","data","props","handleBeforeInput","timeStamp","preventDefault","selection","selectionStart","getStartOffset","anchorKey","getAnchorKey","isCollapsed","getCurrentInlineStyle","newEditorState","mustPreventNative","_latestCommittedEditorState","oldBlockTree","getBlockTree","newBlockTree","size","zip","some","_ref","oldLeafSet","newLeafSet","oldStart","get","adjustedStart","length","oldEnd","adjustedEnd","newStart","newEnd","newDecoratorKey","getDirectionMap","set","nativelyRenderedContent","module","exports"],"sources":["C:/Users/ines_/fisiosys/frontend/node_modules/protected-aidaforms/node_modules/draft-js/lib/editOnBeforeInput.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * \r\n * @emails oncall+draft_js\r\n */\r\n'use strict';\r\n\r\nvar DraftModifier = require(\"./DraftModifier\");\r\n\r\nvar EditorState = require(\"./EditorState\");\r\n\r\nvar UserAgent = require(\"fbjs/lib/UserAgent\");\r\n\r\nvar getEntityKeyForSelection = require(\"./getEntityKeyForSelection\");\r\n\r\nvar isEventHandled = require(\"./isEventHandled\");\r\n\r\nvar isSelectionAtLeafStart = require(\"./isSelectionAtLeafStart\");\r\n\r\nvar nullthrows = require(\"fbjs/lib/nullthrows\");\r\n\r\nvar setImmediate = require(\"fbjs/lib/setImmediate\"); // When nothing is focused, Firefox regards two characters, `'` and `/`, as\r\n// commands that should open and focus the \"quickfind\" search bar. This should\r\n// *never* happen while a contenteditable is focused, but as of v28, it\r\n// sometimes does, even when the keypress event target is the contenteditable.\r\n// This breaks the input. Special case these characters to ensure that when\r\n// they are typed, we prevent default on the event to make sure not to\r\n// trigger quickfind.\r\n\r\n\r\nvar FF_QUICKFIND_CHAR = \"'\";\r\nvar FF_QUICKFIND_LINK_CHAR = '/';\r\nvar isFirefox = UserAgent.isBrowser('Firefox');\r\n\r\nfunction mustPreventDefaultForCharacter(character) {\r\n  return isFirefox && (character == FF_QUICKFIND_CHAR || character == FF_QUICKFIND_LINK_CHAR);\r\n}\r\n/**\r\n * Replace the current selection with the specified text string, with the\r\n * inline style and entity key applied to the newly inserted text.\r\n */\r\n\r\n\r\nfunction replaceText(editorState, text, inlineStyle, entityKey, forceSelection) {\r\n  var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), text, inlineStyle, entityKey);\r\n  return EditorState.push(editorState, contentState, 'insert-characters', forceSelection);\r\n}\r\n/**\r\n * When `onBeforeInput` executes, the browser is attempting to insert a\r\n * character into the editor. Apply this character data to the document,\r\n * allowing native insertion if possible.\r\n *\r\n * Native insertion is encouraged in order to limit re-rendering and to\r\n * preserve spellcheck highlighting, which disappears or flashes if re-render\r\n * occurs on the relevant text nodes.\r\n */\r\n\r\n\r\nfunction editOnBeforeInput(editor, e) {\r\n  if (editor._pendingStateFromBeforeInput !== undefined) {\r\n    editor.update(editor._pendingStateFromBeforeInput);\r\n    editor._pendingStateFromBeforeInput = undefined;\r\n  }\r\n\r\n  var editorState = editor._latestEditorState;\r\n  var chars = e.data; // In some cases (ex: IE ideographic space insertion) no character data\r\n  // is provided. There's nothing to do when this happens.\r\n\r\n  if (!chars) {\r\n    return;\r\n  } // Allow the top-level component to handle the insertion manually. This is\r\n  // useful when triggering interesting behaviors for a character insertion,\r\n  // Simple examples: replacing a raw text ':)' with a smile emoji or image\r\n  // decorator, or setting a block to be a list item after typing '- ' at the\r\n  // start of the block.\r\n\r\n\r\n  if (editor.props.handleBeforeInput && isEventHandled(editor.props.handleBeforeInput(chars, editorState, e.timeStamp))) {\r\n    e.preventDefault();\r\n    return;\r\n  } // If selection is collapsed, conditionally allow native behavior. This\r\n  // reduces re-renders and preserves spellcheck highlighting. If the selection\r\n  // is not collapsed, we will re-render.\r\n\r\n\r\n  var selection = editorState.getSelection();\r\n  var selectionStart = selection.getStartOffset();\r\n  var anchorKey = selection.getAnchorKey();\r\n\r\n  if (!selection.isCollapsed()) {\r\n    e.preventDefault();\r\n    editor.update(replaceText(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection()), true));\r\n    return;\r\n  }\r\n\r\n  var newEditorState = replaceText(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection()), false); // Bunch of different cases follow where we need to prevent native insertion.\r\n\r\n  var mustPreventNative = false;\r\n\r\n  if (!mustPreventNative) {\r\n    // Browsers tend to insert text in weird places in the DOM when typing at\r\n    // the start of a leaf, so we'll handle it ourselves.\r\n    mustPreventNative = isSelectionAtLeafStart(editor._latestCommittedEditorState);\r\n  }\r\n\r\n  if (!mustPreventNative) {\r\n    // Let's say we have a decorator that highlights hashtags. In many cases\r\n    // we need to prevent native behavior and rerender ourselves --\r\n    // particularly, any case *except* where the inserted characters end up\r\n    // anywhere except exactly where you put them.\r\n    //\r\n    // Using [] to denote a decorated leaf, some examples:\r\n    //\r\n    // 1. 'hi #' and append 'f'\r\n    // desired rendering: 'hi [#f]'\r\n    // native rendering would be: 'hi #f' (incorrect)\r\n    //\r\n    // 2. 'x [#foo]' and insert '#' before 'f'\r\n    // desired rendering: 'x #[#foo]'\r\n    // native rendering would be: 'x [##foo]' (incorrect)\r\n    //\r\n    // 3. '[#foobar]' and insert ' ' between 'foo' and 'bar'\r\n    // desired rendering: '[#foo] bar'\r\n    // native rendering would be: '[#foo bar]' (incorrect)\r\n    //\r\n    // 4. '[#foo]' and delete '#' [won't use this beforeinput codepath though]\r\n    // desired rendering: 'foo'\r\n    // native rendering would be: '[foo]' (incorrect)\r\n    //\r\n    // 5. '[#foo]' and append 'b'\r\n    // desired rendering: '[#foob]'\r\n    // native rendering would be: '[#foob]'\r\n    // (native insertion here would be ok for decorators like simple spans,\r\n    // but not more complex decorators. To be safe, we need to prevent it.)\r\n    //\r\n    // It is safe to allow native insertion if and only if the full list of\r\n    // decorator ranges matches what we expect native insertion to give, and\r\n    // the range lengths have not changed. We don't need to compare the content\r\n    // because the only possible mutation to consider here is inserting plain\r\n    // text and decorators can't affect text content.\r\n    var oldBlockTree = editorState.getBlockTree(anchorKey);\r\n    var newBlockTree = newEditorState.getBlockTree(anchorKey);\r\n    mustPreventNative = oldBlockTree.size !== newBlockTree.size || oldBlockTree.zip(newBlockTree).some(function (_ref) {\r\n      var oldLeafSet = _ref[0],\r\n          newLeafSet = _ref[1];\r\n      // selectionStart is guaranteed to be selectionEnd here\r\n      var oldStart = oldLeafSet.get('start');\r\n      var adjustedStart = oldStart + (oldStart >= selectionStart ? chars.length : 0);\r\n      var oldEnd = oldLeafSet.get('end');\r\n      var adjustedEnd = oldEnd + (oldEnd >= selectionStart ? chars.length : 0);\r\n      var newStart = newLeafSet.get('start');\r\n      var newEnd = newLeafSet.get('end');\r\n      var newDecoratorKey = newLeafSet.get('decoratorKey');\r\n      return (// Different decorators\r\n        oldLeafSet.get('decoratorKey') !== newDecoratorKey || // Different number of inline styles\r\n        oldLeafSet.get('leaves').size !== newLeafSet.get('leaves').size || // Different effective decorator position\r\n        adjustedStart !== newStart || adjustedEnd !== newEnd || // Decorator already existed and its length changed\r\n        newDecoratorKey != null && newEnd - newStart !== oldEnd - oldStart\r\n      );\r\n    });\r\n  }\r\n\r\n  if (!mustPreventNative) {\r\n    mustPreventNative = mustPreventDefaultForCharacter(chars);\r\n  }\r\n\r\n  if (!mustPreventNative) {\r\n    mustPreventNative = nullthrows(newEditorState.getDirectionMap()).get(anchorKey) !== nullthrows(editorState.getDirectionMap()).get(anchorKey);\r\n  }\r\n\r\n  if (mustPreventNative) {\r\n    e.preventDefault();\r\n    newEditorState = EditorState.set(newEditorState, {\r\n      forceSelection: true\r\n    });\r\n    editor.update(newEditorState);\r\n    return;\r\n  } // We made it all the way! Let the browser do its thing and insert the char.\r\n\r\n\r\n  newEditorState = EditorState.set(newEditorState, {\r\n    nativelyRenderedContent: newEditorState.getCurrentContent()\r\n  }); // The native event is allowed to occur. To allow user onChange handlers to\r\n  // change the inserted text, we wait until the text is actually inserted\r\n  // before we actually update our state. That way when we rerender, the text\r\n  // we see in the DOM will already have been inserted properly.\r\n\r\n  editor._pendingStateFromBeforeInput = newEditorState;\r\n  setImmediate(function () {\r\n    if (editor._pendingStateFromBeforeInput !== undefined) {\r\n      editor.update(editor._pendingStateFromBeforeInput);\r\n      editor._pendingStateFromBeforeInput = undefined;\r\n    }\r\n  });\r\n}\r\n\r\nmodule.exports = editOnBeforeInput;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}