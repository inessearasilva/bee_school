{"ast":null,"code":"import axios from \"axios\";\nimport { getEnvUrl } from \"../../../environment/index\";\nconst makeDLMRequest = async (token, idJDT, ruleID, inputVariables) => {\n  try {\n    const res = await axios({\n      method: \"post\",\n      url: `${getEnvUrl('aidadlmengine', '4023')}/dlmEngine`,\n      // url: 'http://172.21.220.49:4023/dlmEngine',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: \"Bearer \" + token\n      },\n      data: {\n        id: idJDT,\n        idRule: ruleID,\n        inputVariables: inputVariables\n      }\n    });\n    const response = res.data;\n    let itemPath, value, action; // 1º Verificar se há regras a cumprir\n\n    if (response && Object.keys(response).length === 0 && response.constructor === Object) {\n      return;\n    } else {\n      let rules = [];\n      response.events.forEach(e => {\n        let rule; // 2º Ir buscar o itemPath do campo que vai ser afetado\n\n        itemPath = e.item; // 3º Extrair o valor da acção\n\n        action = e.action; // 4º Verificar se é uma acção que está associada a um payload (valor) e nesse caso extrair o valor\n\n        let hasValue = Object.keys(e).length > 2 ? true : false;\n        value = hasValue && e.value;\n        rule = {\n          itemPath,\n          action,\n          value\n        };\n        rules.push(rule);\n      });\n      return rules;\n    }\n  } catch (e) {\n    console.log(e);\n    return;\n  }\n};\nconst createInputVariables = (itemPath, value, oldInputs) => {\n  let inputs = {};\n  Object.assign(inputs, oldInputs); // value do tipo Objeto -> envia o objeto\n\n  if (value !== undefined) {\n    if (value instanceof Object) {\n      inputs[itemPath] = value;\n    } // value do tipo Array -> envia um array com cada value\n    else if (Array.isArray(value) && value.length > 0) {\n      let v = [];\n      value.forEach(val => {\n        v.push(val);\n      });\n      inputs[itemPath] = v;\n    } // restantes casos\n    else {\n      inputs[itemPath] = value;\n    }\n  }\n  return inputs;\n};\nconst pathLabeltoNormalPath = pathLabel => {\n  let pathLabelParts = pathLabel.split(\"-\");\n  let itemPathParts = pathLabelParts.filter(p => p === \"items\" || !isNaN(p));\n  let newItemPath = itemPathParts.join(\".\");\n  return newItemPath;\n};\nconst checkDLMRules = async (token, updateIsDlmFinished, idJDT, dlmRules, templateRules, itemPath, pathLabel, values) => {\n  let inputs = {};\n  let response = []; // 1º - verificar se existem regras DLM associadas a este item\n\n  if (Array.isArray(dlmRules) && dlmRules.length > 0) {\n    for (const rule of dlmRules) {\n      for (const r of templateRules) {\n        if (r[0].ruleID === rule) {\n          // 2º - se existirem regras, ir buscar as respetivas condições\n          let conditions = r[0].inputVariables;\n          if (Array.isArray(conditions) && conditions.length > 0) {\n            // 3º - ir buscar o itemPath e o value actual de cada condição\n            inputs = {};\n            conditions.forEach(item => {\n              let val1 = item.replaceAll(\".\", \"-\") + \"-value\"; //itemPathLabel\n              // let val2 = item.replaceAll(\".\", \"-\") + \"-value-date\";\n              // let val3 = item.replaceAll(\".\", \"-\") + \"-value-time\";\n              // if (values[val1] !== \"\" && values[val2] !== \"\" && values[val3] !== \"\") {\n\n              if (values[val1] !== \"\") {\n                // 4º transformar o pathLabel num path normal e adicionar aos inputs\n                let path = pathLabeltoNormalPath(val1);\n                inputs = createInputVariables(path, values[val1], inputs);\n              }\n            }); // só se tiver os inputs todos preenchidos é que faz o pedido\n\n            if (Object.keys(inputs).length === conditions.length) {\n              updateIsDlmFinished(false);\n              let res = await makeDLMRequest(token, idJDT, rule, inputs);\n              res !== undefined && response.push(res);\n            }\n          }\n        }\n      }\n    }\n  }\n  return response;\n};\nexport { checkDLMRules };","map":{"version":3,"names":["axios","getEnvUrl","makeDLMRequest","token","idJDT","ruleID","inputVariables","res","method","url","headers","Authorization","data","id","idRule","response","itemPath","value","action","Object","keys","length","constructor","rules","events","forEach","e","rule","item","hasValue","push","console","log","createInputVariables","oldInputs","inputs","assign","undefined","Array","isArray","v","val","pathLabeltoNormalPath","pathLabel","pathLabelParts","split","itemPathParts","filter","p","isNaN","newItemPath","join","checkDLMRules","updateIsDlmFinished","dlmRules","templateRules","values","r","conditions","val1","replaceAll","path"],"sources":["C:/Users/ines_/fisiosys/fisiosys/frontend/node_modules/protected-aidaforms/dist/assets/functions/HandleDLM/checkDLMRules.js"],"sourcesContent":["import axios from \"axios\";\r\nimport { getEnvUrl } from \"../../../environment/index\";\r\n\r\nconst makeDLMRequest = async (token, idJDT, ruleID, inputVariables) => {\r\n  try {\r\n    const res = await axios({\r\n      method: \"post\",\r\n      url: `${getEnvUrl('aidadlmengine', '4023')}/dlmEngine`,\r\n      // url: 'http://172.21.220.49:4023/dlmEngine',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        Authorization: \"Bearer \" + token\r\n      },\r\n      data: {\r\n        id: idJDT,\r\n        idRule: ruleID,\r\n        inputVariables: inputVariables\r\n      }\r\n    });\r\n    const response = res.data;\r\n    let itemPath, value, action; // 1º Verificar se há regras a cumprir\r\n\r\n    if (response && Object.keys(response).length === 0 && response.constructor === Object) {\r\n      return;\r\n    } else {\r\n      let rules = [];\r\n      response.events.forEach(e => {\r\n        let rule; // 2º Ir buscar o itemPath do campo que vai ser afetado\r\n\r\n        itemPath = e.item; // 3º Extrair o valor da acção\r\n\r\n        action = e.action; // 4º Verificar se é uma acção que está associada a um payload (valor) e nesse caso extrair o valor\r\n\r\n        let hasValue = Object.keys(e).length > 2 ? true : false;\r\n        value = hasValue && e.value;\r\n        rule = {\r\n          itemPath,\r\n          action,\r\n          value\r\n        };\r\n        rules.push(rule);\r\n      });\r\n      return rules;\r\n    }\r\n  } catch (e) {\r\n    console.log(e);\r\n    return;\r\n  }\r\n};\r\n\r\nconst createInputVariables = (itemPath, value, oldInputs) => {\r\n  let inputs = {};\r\n  Object.assign(inputs, oldInputs); // value do tipo Objeto -> envia o objeto\r\n\r\n  if (value !== undefined) {\r\n    if (value instanceof Object) {\r\n      inputs[itemPath] = value;\r\n    } // value do tipo Array -> envia um array com cada value\r\n    else if (Array.isArray(value) && value.length > 0) {\r\n        let v = [];\r\n        value.forEach(val => {\r\n          v.push(val);\r\n        });\r\n        inputs[itemPath] = v;\r\n      } // restantes casos\r\n      else {\r\n          inputs[itemPath] = value;\r\n        }\r\n  }\r\n\r\n  return inputs;\r\n};\r\n\r\nconst pathLabeltoNormalPath = pathLabel => {\r\n  let pathLabelParts = pathLabel.split(\"-\");\r\n  let itemPathParts = pathLabelParts.filter(p => p === \"items\" || !isNaN(p));\r\n  let newItemPath = itemPathParts.join(\".\");\r\n  return newItemPath;\r\n};\r\n\r\nconst checkDLMRules = async (token, updateIsDlmFinished, idJDT, dlmRules, templateRules, itemPath, pathLabel, values) => {\r\n  let inputs = {};\r\n  let response = []; // 1º - verificar se existem regras DLM associadas a este item\r\n\r\n  if (Array.isArray(dlmRules) && dlmRules.length > 0) {\r\n    for (const rule of dlmRules) {\r\n      for (const r of templateRules) {\r\n        if (r[0].ruleID === rule) {\r\n          // 2º - se existirem regras, ir buscar as respetivas condições\r\n          let conditions = r[0].inputVariables;\r\n\r\n          if (Array.isArray(conditions) && conditions.length > 0) {\r\n            // 3º - ir buscar o itemPath e o value actual de cada condição\r\n            inputs = {};\r\n            conditions.forEach(item => {\r\n              let val1 = item.replaceAll(\".\", \"-\") + \"-value\"; //itemPathLabel\r\n              // let val2 = item.replaceAll(\".\", \"-\") + \"-value-date\";\r\n              // let val3 = item.replaceAll(\".\", \"-\") + \"-value-time\";\r\n              // if (values[val1] !== \"\" && values[val2] !== \"\" && values[val3] !== \"\") {\r\n\r\n              if (values[val1] !== \"\") {\r\n                // 4º transformar o pathLabel num path normal e adicionar aos inputs\r\n                let path = pathLabeltoNormalPath(val1);\r\n                inputs = createInputVariables(path, values[val1], inputs);\r\n              }\r\n            }); // só se tiver os inputs todos preenchidos é que faz o pedido\r\n\r\n            if (Object.keys(inputs).length === conditions.length) {\r\n              updateIsDlmFinished(false);\r\n              let res = await makeDLMRequest(token, idJDT, rule, inputs);\r\n              res !== undefined && response.push(res);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return response;\r\n};\r\n\r\nexport { checkDLMRules };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}