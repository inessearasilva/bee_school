{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * \r\n * @emails oncall+draft_js\r\n */\n'use strict';\n\nvar CharacterMetadata = require(\"./CharacterMetadata\");\nvar findRangesImmutable = require(\"./findRangesImmutable\");\nvar invariant = require(\"fbjs/lib/invariant\");\nfunction removeEntitiesAtEdges(contentState, selectionState) {\n  var blockMap = contentState.getBlockMap();\n  var entityMap = contentState.getEntityMap();\n  var updatedBlocks = {};\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var startBlock = blockMap.get(startKey);\n  var updatedStart = removeForBlock(entityMap, startBlock, startOffset);\n  if (updatedStart !== startBlock) {\n    updatedBlocks[startKey] = updatedStart;\n  }\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset();\n  var endBlock = blockMap.get(endKey);\n  if (startKey === endKey) {\n    endBlock = updatedStart;\n  }\n  var updatedEnd = removeForBlock(entityMap, endBlock, endOffset);\n  if (updatedEnd !== endBlock) {\n    updatedBlocks[endKey] = updatedEnd;\n  }\n  if (!Object.keys(updatedBlocks).length) {\n    return contentState.set('selectionAfter', selectionState);\n  }\n  return contentState.merge({\n    blockMap: blockMap.merge(updatedBlocks),\n    selectionAfter: selectionState\n  });\n}\n/**\r\n * Given a list of characters and an offset that is in the middle of an entity,\r\n * returns the start and end of the entity that is overlapping the offset.\r\n * Note: This method requires that the offset be in an entity range.\r\n */\n\nfunction getRemovalRange(characters, entityKey, offset) {\n  var removalRange; // Iterates through a list looking for ranges of matching items\n  // based on the 'isEqual' callback.\n  // Then instead of returning the result, call the 'found' callback\n  // with each range.\n  // Then filters those ranges based on the 'filter' callback\n  //\n  // Here we use it to find ranges of characters with the same entity key.\n\n  findRangesImmutable(characters,\n  // the list to iterate through\n  function (a, b) {\n    return a.getEntity() === b.getEntity();\n  },\n  // 'isEqual' callback\n  function (element) {\n    return element.getEntity() === entityKey;\n  },\n  // 'filter' callback\n  function (start, end) {\n    // 'found' callback\n    if (start <= offset && end >= offset) {\n      // this entity overlaps the offset index\n      removalRange = {\n        start: start,\n        end: end\n      };\n    }\n  });\n  !(typeof removalRange === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Removal range must exist within character list.') : invariant(false) : void 0;\n  return removalRange;\n}\nfunction removeForBlock(entityMap, block, offset) {\n  var chars = block.getCharacterList();\n  var charBefore = offset > 0 ? chars.get(offset - 1) : undefined;\n  var charAfter = offset < chars.count() ? chars.get(offset) : undefined;\n  var entityBeforeCursor = charBefore ? charBefore.getEntity() : undefined;\n  var entityAfterCursor = charAfter ? charAfter.getEntity() : undefined;\n  if (entityAfterCursor && entityAfterCursor === entityBeforeCursor) {\n    var entity = entityMap.__get(entityAfterCursor);\n    if (entity.getMutability() !== 'MUTABLE') {\n      var _getRemovalRange = getRemovalRange(chars, entityAfterCursor, offset),\n        start = _getRemovalRange.start,\n        end = _getRemovalRange.end;\n      var current;\n      while (start < end) {\n        current = chars.get(start);\n        chars = chars.set(start, CharacterMetadata.applyEntity(current, null));\n        start++;\n      }\n      return block.set('characterList', chars);\n    }\n  }\n  return block;\n}\nmodule.exports = removeEntitiesAtEdges;","map":{"version":3,"names":["CharacterMetadata","require","findRangesImmutable","invariant","removeEntitiesAtEdges","contentState","selectionState","blockMap","getBlockMap","entityMap","getEntityMap","updatedBlocks","startKey","getStartKey","startOffset","getStartOffset","startBlock","get","updatedStart","removeForBlock","endKey","getEndKey","endOffset","getEndOffset","endBlock","updatedEnd","Object","keys","length","set","merge","selectionAfter","getRemovalRange","characters","entityKey","offset","removalRange","a","b","getEntity","element","start","end","process","env","NODE_ENV","block","chars","getCharacterList","charBefore","undefined","charAfter","count","entityBeforeCursor","entityAfterCursor","entity","__get","getMutability","_getRemovalRange","current","applyEntity","module","exports"],"sources":["C:/Users/ines_/fisiosys/frontend/node_modules/protected-aidaforms/node_modules/draft-js/lib/removeEntitiesAtEdges.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * \r\n * @emails oncall+draft_js\r\n */\r\n'use strict';\r\n\r\nvar CharacterMetadata = require(\"./CharacterMetadata\");\r\n\r\nvar findRangesImmutable = require(\"./findRangesImmutable\");\r\n\r\nvar invariant = require(\"fbjs/lib/invariant\");\r\n\r\nfunction removeEntitiesAtEdges(contentState, selectionState) {\r\n  var blockMap = contentState.getBlockMap();\r\n  var entityMap = contentState.getEntityMap();\r\n  var updatedBlocks = {};\r\n  var startKey = selectionState.getStartKey();\r\n  var startOffset = selectionState.getStartOffset();\r\n  var startBlock = blockMap.get(startKey);\r\n  var updatedStart = removeForBlock(entityMap, startBlock, startOffset);\r\n\r\n  if (updatedStart !== startBlock) {\r\n    updatedBlocks[startKey] = updatedStart;\r\n  }\r\n\r\n  var endKey = selectionState.getEndKey();\r\n  var endOffset = selectionState.getEndOffset();\r\n  var endBlock = blockMap.get(endKey);\r\n\r\n  if (startKey === endKey) {\r\n    endBlock = updatedStart;\r\n  }\r\n\r\n  var updatedEnd = removeForBlock(entityMap, endBlock, endOffset);\r\n\r\n  if (updatedEnd !== endBlock) {\r\n    updatedBlocks[endKey] = updatedEnd;\r\n  }\r\n\r\n  if (!Object.keys(updatedBlocks).length) {\r\n    return contentState.set('selectionAfter', selectionState);\r\n  }\r\n\r\n  return contentState.merge({\r\n    blockMap: blockMap.merge(updatedBlocks),\r\n    selectionAfter: selectionState\r\n  });\r\n}\r\n/**\r\n * Given a list of characters and an offset that is in the middle of an entity,\r\n * returns the start and end of the entity that is overlapping the offset.\r\n * Note: This method requires that the offset be in an entity range.\r\n */\r\n\r\n\r\nfunction getRemovalRange(characters, entityKey, offset) {\r\n  var removalRange; // Iterates through a list looking for ranges of matching items\r\n  // based on the 'isEqual' callback.\r\n  // Then instead of returning the result, call the 'found' callback\r\n  // with each range.\r\n  // Then filters those ranges based on the 'filter' callback\r\n  //\r\n  // Here we use it to find ranges of characters with the same entity key.\r\n\r\n  findRangesImmutable(characters, // the list to iterate through\r\n  function (a, b) {\r\n    return a.getEntity() === b.getEntity();\r\n  }, // 'isEqual' callback\r\n  function (element) {\r\n    return element.getEntity() === entityKey;\r\n  }, // 'filter' callback\r\n  function (start, end) {\r\n    // 'found' callback\r\n    if (start <= offset && end >= offset) {\r\n      // this entity overlaps the offset index\r\n      removalRange = {\r\n        start: start,\r\n        end: end\r\n      };\r\n    }\r\n  });\r\n  !(typeof removalRange === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Removal range must exist within character list.') : invariant(false) : void 0;\r\n  return removalRange;\r\n}\r\n\r\nfunction removeForBlock(entityMap, block, offset) {\r\n  var chars = block.getCharacterList();\r\n  var charBefore = offset > 0 ? chars.get(offset - 1) : undefined;\r\n  var charAfter = offset < chars.count() ? chars.get(offset) : undefined;\r\n  var entityBeforeCursor = charBefore ? charBefore.getEntity() : undefined;\r\n  var entityAfterCursor = charAfter ? charAfter.getEntity() : undefined;\r\n\r\n  if (entityAfterCursor && entityAfterCursor === entityBeforeCursor) {\r\n    var entity = entityMap.__get(entityAfterCursor);\r\n\r\n    if (entity.getMutability() !== 'MUTABLE') {\r\n      var _getRemovalRange = getRemovalRange(chars, entityAfterCursor, offset),\r\n          start = _getRemovalRange.start,\r\n          end = _getRemovalRange.end;\r\n\r\n      var current;\r\n\r\n      while (start < end) {\r\n        current = chars.get(start);\r\n        chars = chars.set(start, CharacterMetadata.applyEntity(current, null));\r\n        start++;\r\n      }\r\n\r\n      return block.set('characterList', chars);\r\n    }\r\n  }\r\n\r\n  return block;\r\n}\r\n\r\nmodule.exports = removeEntitiesAtEdges;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,IAAIA,iBAAiB,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AAEtD,IAAIC,mBAAmB,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AAE1D,IAAIE,SAAS,GAAGF,OAAO,CAAC,oBAAoB,CAAC;AAE7C,SAASG,qBAAqB,CAACC,YAAY,EAAEC,cAAc,EAAE;EAC3D,IAAIC,QAAQ,GAAGF,YAAY,CAACG,WAAW,EAAE;EACzC,IAAIC,SAAS,GAAGJ,YAAY,CAACK,YAAY,EAAE;EAC3C,IAAIC,aAAa,GAAG,CAAC,CAAC;EACtB,IAAIC,QAAQ,GAAGN,cAAc,CAACO,WAAW,EAAE;EAC3C,IAAIC,WAAW,GAAGR,cAAc,CAACS,cAAc,EAAE;EACjD,IAAIC,UAAU,GAAGT,QAAQ,CAACU,GAAG,CAACL,QAAQ,CAAC;EACvC,IAAIM,YAAY,GAAGC,cAAc,CAACV,SAAS,EAAEO,UAAU,EAAEF,WAAW,CAAC;EAErE,IAAII,YAAY,KAAKF,UAAU,EAAE;IAC/BL,aAAa,CAACC,QAAQ,CAAC,GAAGM,YAAY;EACxC;EAEA,IAAIE,MAAM,GAAGd,cAAc,CAACe,SAAS,EAAE;EACvC,IAAIC,SAAS,GAAGhB,cAAc,CAACiB,YAAY,EAAE;EAC7C,IAAIC,QAAQ,GAAGjB,QAAQ,CAACU,GAAG,CAACG,MAAM,CAAC;EAEnC,IAAIR,QAAQ,KAAKQ,MAAM,EAAE;IACvBI,QAAQ,GAAGN,YAAY;EACzB;EAEA,IAAIO,UAAU,GAAGN,cAAc,CAACV,SAAS,EAAEe,QAAQ,EAAEF,SAAS,CAAC;EAE/D,IAAIG,UAAU,KAAKD,QAAQ,EAAE;IAC3Bb,aAAa,CAACS,MAAM,CAAC,GAAGK,UAAU;EACpC;EAEA,IAAI,CAACC,MAAM,CAACC,IAAI,CAAChB,aAAa,CAAC,CAACiB,MAAM,EAAE;IACtC,OAAOvB,YAAY,CAACwB,GAAG,CAAC,gBAAgB,EAAEvB,cAAc,CAAC;EAC3D;EAEA,OAAOD,YAAY,CAACyB,KAAK,CAAC;IACxBvB,QAAQ,EAAEA,QAAQ,CAACuB,KAAK,CAACnB,aAAa,CAAC;IACvCoB,cAAc,EAAEzB;EAClB,CAAC,CAAC;AACJ;AACA;AACA;AACA;AACA;AACA;;AAGA,SAAS0B,eAAe,CAACC,UAAU,EAAEC,SAAS,EAAEC,MAAM,EAAE;EACtD,IAAIC,YAAY,CAAC,CAAC;EAClB;EACA;EACA;EACA;EACA;EACA;;EAEAlC,mBAAmB,CAAC+B,UAAU;EAAE;EAChC,UAAUI,CAAC,EAAEC,CAAC,EAAE;IACd,OAAOD,CAAC,CAACE,SAAS,EAAE,KAAKD,CAAC,CAACC,SAAS,EAAE;EACxC,CAAC;EAAE;EACH,UAAUC,OAAO,EAAE;IACjB,OAAOA,OAAO,CAACD,SAAS,EAAE,KAAKL,SAAS;EAC1C,CAAC;EAAE;EACH,UAAUO,KAAK,EAAEC,GAAG,EAAE;IACpB;IACA,IAAID,KAAK,IAAIN,MAAM,IAAIO,GAAG,IAAIP,MAAM,EAAE;MACpC;MACAC,YAAY,GAAG;QACbK,KAAK,EAAEA,KAAK;QACZC,GAAG,EAAEA;MACP,CAAC;IACH;EACF,CAAC,CAAC;EACF,EAAE,OAAON,YAAY,KAAK,QAAQ,CAAC,GAAGO,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAG1C,SAAS,CAAC,KAAK,EAAE,iDAAiD,CAAC,GAAGA,SAAS,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;EAC7K,OAAOiC,YAAY;AACrB;AAEA,SAASjB,cAAc,CAACV,SAAS,EAAEqC,KAAK,EAAEX,MAAM,EAAE;EAChD,IAAIY,KAAK,GAAGD,KAAK,CAACE,gBAAgB,EAAE;EACpC,IAAIC,UAAU,GAAGd,MAAM,GAAG,CAAC,GAAGY,KAAK,CAAC9B,GAAG,CAACkB,MAAM,GAAG,CAAC,CAAC,GAAGe,SAAS;EAC/D,IAAIC,SAAS,GAAGhB,MAAM,GAAGY,KAAK,CAACK,KAAK,EAAE,GAAGL,KAAK,CAAC9B,GAAG,CAACkB,MAAM,CAAC,GAAGe,SAAS;EACtE,IAAIG,kBAAkB,GAAGJ,UAAU,GAAGA,UAAU,CAACV,SAAS,EAAE,GAAGW,SAAS;EACxE,IAAII,iBAAiB,GAAGH,SAAS,GAAGA,SAAS,CAACZ,SAAS,EAAE,GAAGW,SAAS;EAErE,IAAII,iBAAiB,IAAIA,iBAAiB,KAAKD,kBAAkB,EAAE;IACjE,IAAIE,MAAM,GAAG9C,SAAS,CAAC+C,KAAK,CAACF,iBAAiB,CAAC;IAE/C,IAAIC,MAAM,CAACE,aAAa,EAAE,KAAK,SAAS,EAAE;MACxC,IAAIC,gBAAgB,GAAG1B,eAAe,CAACe,KAAK,EAAEO,iBAAiB,EAAEnB,MAAM,CAAC;QACpEM,KAAK,GAAGiB,gBAAgB,CAACjB,KAAK;QAC9BC,GAAG,GAAGgB,gBAAgB,CAAChB,GAAG;MAE9B,IAAIiB,OAAO;MAEX,OAAOlB,KAAK,GAAGC,GAAG,EAAE;QAClBiB,OAAO,GAAGZ,KAAK,CAAC9B,GAAG,CAACwB,KAAK,CAAC;QAC1BM,KAAK,GAAGA,KAAK,CAAClB,GAAG,CAACY,KAAK,EAAEzC,iBAAiB,CAAC4D,WAAW,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;QACtElB,KAAK,EAAE;MACT;MAEA,OAAOK,KAAK,CAACjB,GAAG,CAAC,eAAe,EAAEkB,KAAK,CAAC;IAC1C;EACF;EAEA,OAAOD,KAAK;AACd;AAEAe,MAAM,CAACC,OAAO,GAAG1D,qBAAqB"},"metadata":{},"sourceType":"script","externalDependencies":[]}