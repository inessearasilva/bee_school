{"ast":null,"code":"import { handleConditionValidation } from \"./handleConditionValidation\"; // quando aparecer uma condição verdadeira, parar o ciclo e mandar isTrue = true\n\nconst handleOrOperator = (conditionsArray, values) => {\n  let i;\n  let isTrue = false;\n  for (i = 0; i < conditionsArray.length; i++) {\n    const condition = conditionsArray[i];\n    const path = condition[\"$ItemPath\"].split(\".\").join(\"-\");\n    const value = values[path];\n    const conditionValidation = handleConditionValidation(condition, value);\n    if (conditionValidation) {\n      isTrue = true;\n      break;\n    }\n  }\n  return isTrue;\n}; // quando aparecer uma condição false, parar o ciclo e mandar isTrue = false\n\nconst handleAndOperator = (conditionsArray, values) => {\n  let i;\n  let isTrue = true;\n  for (i = 0; i < conditionsArray.length; i++) {\n    const condition = conditionsArray[i];\n    const path = condition[\"$ItemPath\"].split(\".\").join(\"-\");\n    const value = values[path];\n    const conditionValidation = handleConditionValidation(condition, value);\n    if (!conditionValidation) {\n      isTrue = false;\n      break;\n    }\n  }\n  return isTrue;\n};\nconst handleRuleValidation = (rule, values) => {\n  let isTrue;\n  if (rule[\"$or\"]) {\n    isTrue = handleOrOperator(rule[\"$or\"], values);\n  } else if (rule[\"$and\"]) {\n    isTrue = handleAndOperator(rule[\"$and\"], values);\n  }\n  return isTrue;\n};\nconst handleRules = (item, values, ruleType) => {\n  let isTrue;\n  if (ruleType === \"visibility\") {\n    if (Array.isArray(item.ruleVisibility)) {\n      if (item.ruleVisibility.length !== 0) {\n        let i;\n        let breakOccurred = false;\n        for (i = 0; i < item.ruleVisibility.length; i++) {\n          const rule = item.ruleVisibility[i];\n          let visibility = handleRuleValidation(rule, values);\n          if (!visibility) {\n            // se uma das regras falhar, então acaba o ciclo e o item não pode estar visível\n            breakOccurred = true;\n            break;\n          }\n        }\n        if (breakOccurred) {\n          isTrue = false;\n        } else {\n          isTrue = true;\n        }\n      } else {\n        isTrue = true;\n      }\n    } else {\n      isTrue = true;\n    }\n  } else if (ruleType === \"mandatory\") {\n    if (Array.isArray(item.ruleMandatory)) {\n      if (item.ruleMandatory.length !== 0) {\n        let i;\n        let breakOccurred = false;\n        for (i = 0; i < item.ruleMandatory.length; i++) {\n          const rule = item.ruleMandatory[i];\n          let mandatory = handleRuleValidation(rule, values);\n          if (!mandatory) {\n            // se uma das regras falhar, então acaba o ciclo e o item não é obrigatório\n            breakOccurred = true;\n            break;\n          }\n        }\n        if (breakOccurred) {\n          isTrue = false;\n        } else {\n          isTrue = true;\n        }\n      } else {\n        isTrue = false;\n      }\n    } else {\n      isTrue = false;\n    }\n  }\n  return isTrue;\n};\nexport { handleRules };","map":{"version":3,"names":["handleConditionValidation","handleOrOperator","conditionsArray","values","i","isTrue","length","condition","path","split","join","value","conditionValidation","handleAndOperator","handleRuleValidation","rule","handleRules","item","ruleType","Array","isArray","ruleVisibility","breakOccurred","visibility","ruleMandatory","mandatory"],"sources":["C:/Users/ines_/fisiosys/frontend/node_modules/protected-aidaforms/dist/assets/functions/HandleRules/handleRules.js"],"sourcesContent":["import { handleConditionValidation } from \"./handleConditionValidation\"; // quando aparecer uma condição verdadeira, parar o ciclo e mandar isTrue = true\n\nconst handleOrOperator = (conditionsArray, values) => {\n  let i;\n  let isTrue = false;\n\n  for (i = 0; i < conditionsArray.length; i++) {\n    const condition = conditionsArray[i];\n    const path = condition[\"$ItemPath\"].split(\".\").join(\"-\");\n    const value = values[path];\n    const conditionValidation = handleConditionValidation(condition, value);\n\n    if (conditionValidation) {\n      isTrue = true;\n      break;\n    }\n  }\n\n  return isTrue;\n}; // quando aparecer uma condição false, parar o ciclo e mandar isTrue = false\n\n\nconst handleAndOperator = (conditionsArray, values) => {\n  let i;\n  let isTrue = true;\n\n  for (i = 0; i < conditionsArray.length; i++) {\n    const condition = conditionsArray[i];\n    const path = condition[\"$ItemPath\"].split(\".\").join(\"-\");\n    const value = values[path];\n    const conditionValidation = handleConditionValidation(condition, value);\n\n    if (!conditionValidation) {\n      isTrue = false;\n      break;\n    }\n  }\n\n  return isTrue;\n};\n\nconst handleRuleValidation = (rule, values) => {\n  let isTrue;\n\n  if (rule[\"$or\"]) {\n    isTrue = handleOrOperator(rule[\"$or\"], values);\n  } else if (rule[\"$and\"]) {\n    isTrue = handleAndOperator(rule[\"$and\"], values);\n  }\n\n  return isTrue;\n};\n\nconst handleRules = (item, values, ruleType) => {\n  let isTrue;\n\n  if (ruleType === \"visibility\") {\n    if (Array.isArray(item.ruleVisibility)) {\n      if (item.ruleVisibility.length !== 0) {\n        let i;\n        let breakOccurred = false;\n\n        for (i = 0; i < item.ruleVisibility.length; i++) {\n          const rule = item.ruleVisibility[i];\n          let visibility = handleRuleValidation(rule, values);\n\n          if (!visibility) {\n            // se uma das regras falhar, então acaba o ciclo e o item não pode estar visível\n            breakOccurred = true;\n            break;\n          }\n        }\n\n        if (breakOccurred) {\n          isTrue = false;\n        } else {\n          isTrue = true;\n        }\n      } else {\n        isTrue = true;\n      }\n    } else {\n      isTrue = true;\n    }\n  } else if (ruleType === \"mandatory\") {\n    if (Array.isArray(item.ruleMandatory)) {\n      if (item.ruleMandatory.length !== 0) {\n        let i;\n        let breakOccurred = false;\n\n        for (i = 0; i < item.ruleMandatory.length; i++) {\n          const rule = item.ruleMandatory[i];\n          let mandatory = handleRuleValidation(rule, values);\n\n          if (!mandatory) {\n            // se uma das regras falhar, então acaba o ciclo e o item não é obrigatório\n            breakOccurred = true;\n            break;\n          }\n        }\n\n        if (breakOccurred) {\n          isTrue = false;\n        } else {\n          isTrue = true;\n        }\n      } else {\n        isTrue = false;\n      }\n    } else {\n      isTrue = false;\n    }\n  }\n\n  return isTrue;\n};\n\nexport { handleRules };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}