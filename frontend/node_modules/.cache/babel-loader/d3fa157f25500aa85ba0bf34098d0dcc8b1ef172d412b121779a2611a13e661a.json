{"ast":null,"code":"import { orderObjectByValue } from \"../Order/orderObjectByValue\"; // Tendo em conta que temos: items únicos, items Any (mesmo field com mais do que um datatype) e sections (tem vários items)\n\nconst handleOrder = (isSection, isSectionHover, dragPath, hoverPath, dragOrder, hoverOrder, showLabelDrag, showLabelHover, isAnyDrag, isAnyHover, formOrder) => {\n  const immutableObj = orderObjectByValue(formOrder); // To guarantee the paths are by ascendent order while doing forEach\n\n  let objOrder = {\n    ...immutableObj\n  };\n  if (isSection) {\n    // Drag is a section\n    if (isSectionHover) {\n      // Drag and drop are both sections\n      let countSubItemsHover = 0;\n      let countSubItemsDrag = 0;\n      Object.keys(immutableObj).forEach(path => {\n        if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\n          countSubItemsDrag += 1;\n        } else if (path.indexOf(hoverPath + \".\") > -1 && path !== hoverPath) {\n          countSubItemsHover += 1;\n        }\n      });\n      if (dragOrder > hoverOrder) {\n        // Move up section\n        objOrder[dragPath] = hoverOrder;\n        let i = 0;\n        let j = 0;\n        let k = 0;\n        Object.keys(immutableObj).forEach(path => {\n          // Items are subitems of the drag section\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItemsDrag) {\n            i += 1;\n            objOrder[path] = hoverOrder + i;\n          } // Items are subitems of the hover section \n          else if (immutableObj[path] >= hoverOrder && immutableObj[path] <= hoverOrder + countSubItemsHover) {\n            j += 1;\n            objOrder[path] = hoverOrder + countSubItemsDrag + j;\n          } // Items are not subitems of either sections\n          else if (immutableObj[path] > hoverOrder + countSubItemsHover && immutableObj[path] < dragOrder) {\n            k += 1;\n            objOrder[path] = hoverOrder + countSubItemsDrag + 1 + countSubItemsHover + k;\n          }\n        });\n      } else if (dragOrder < hoverOrder) {\n        // Move down section\n        let newDragOrder = countSubItemsHover + hoverOrder - countSubItemsDrag;\n        objOrder[dragPath] = newDragOrder;\n        let i = 0;\n        let j = 0;\n        let k = 0;\n        Object.keys(immutableObj).forEach(path => {\n          // Items are subitems of the drag section\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItemsDrag) {\n            i += 1;\n            objOrder[path] = newDragOrder + i;\n          } // Items are subitems of the hover section \n          else if (immutableObj[path] >= hoverOrder && immutableObj[path] <= hoverOrder + countSubItemsHover) {\n            j += 1; // dragOrder - 1 + ((hoverOrder - (dragOrder + countSubItemsDrag)) - 1) + j \n\n            objOrder[path] = hoverOrder - countSubItemsDrag - 2 + j;\n          } // Items are not subitems of either sections\n          else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder + countSubItemsDrag) {\n            k += 1;\n            objOrder[path] = dragOrder - 1 + k;\n          }\n        });\n      }\n    } else if (!isSectionHover && isAnyHover === false) {\n      // Drag is a section and drop is a item \n      let countSubItems = 0;\n      Object.keys(immutableObj).forEach(path => {\n        if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\n          countSubItems += 1;\n        }\n      });\n      if (dragOrder > hoverOrder) {\n        // Move up section\n        objOrder[dragPath] = hoverOrder;\n        let i = 0;\n        Object.keys(immutableObj).forEach(path => {\n          // Items are not subitems of the section\n          if (immutableObj[path] < dragOrder && immutableObj[path] >= hoverOrder) {\n            objOrder[path] = immutableObj[path] + (countSubItems + 1);\n          } // Items are subitems of the section\n          else if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItems) {\n            i += 1;\n            objOrder[path] = hoverOrder + i;\n          }\n        });\n      } else if (dragOrder < hoverOrder) {\n        // Move down section\n        let newDragOrder = hoverOrder - countSubItems;\n        objOrder[dragPath] = newDragOrder;\n        let i = 0;\n        Object.keys(immutableObj).forEach(path => {\n          // Items are not subitems of the section\n          if (immutableObj[path] > dragOrder + countSubItems && immutableObj[path] <= hoverOrder) {\n            objOrder[path] = immutableObj[path] - (countSubItems + 1);\n          } // Items are subitems of the section\n          else if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItems) {\n            i += 1;\n            objOrder[path] = newDragOrder + i;\n          }\n        });\n      }\n    } else if (isAnyHover === true && showLabelHover === true) {\n      // Drag is a section and drop is an Any item\n      if (dragOrder > hoverOrder) {\n        // Move up section\n        let countSubItemsDrag = 0; // Doesn't include the title\n\n        Object.keys(immutableObj).forEach(path => {\n          if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\n            countSubItemsDrag += 1;\n          }\n        });\n        objOrder[dragPath] = hoverOrder;\n        let i = 0;\n        Object.keys(immutableObj).forEach(path => {\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItemsDrag) {\n            i += 1;\n            objOrder[path] = hoverOrder + i;\n          } else if (immutableObj[path] < dragOrder && immutableObj[path] >= hoverOrder) {\n            objOrder[path] = immutableObj[path] + (countSubItemsDrag + 1);\n          }\n        });\n      } else if (dragOrder < hoverOrder) {\n        // Move down section\n        let countSubItemsDrag = 0; // Doesn't include the title\n\n        let anyItemsHover = []; // Includes the first item\n\n        let countAnyItemsHover = 0; // Includes the first item\n\n        Object.keys(immutableObj).forEach(path => {\n          let query = hoverPath.split('.');\n          query.pop();\n          if (path.indexOf(query.join('.') + \".\") > -1) {\n            anyItemsHover.push(path);\n            countAnyItemsHover += 1;\n          }\n          if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\n            countSubItemsDrag += 1;\n          }\n        });\n        let newDragOrder = hoverOrder - countSubItemsDrag + countAnyItemsHover - 1;\n        objOrder[dragPath] = newDragOrder;\n        let i = 0;\n        let j = 0;\n        let k = 0;\n        Object.keys(immutableObj).forEach(path => {\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItemsDrag) {\n            i += 1;\n            objOrder[path] = newDragOrder + i;\n          } else if (anyItemsHover.indexOf(path) > -1) {\n            j += 1;\n            objOrder[path] = hoverOrder - countSubItemsDrag - 2 + j;\n          } else if (immutableObj[path] > dragOrder + countSubItemsDrag && immutableObj[path] < hoverOrder) {\n            k += 1;\n            objOrder[path] = dragOrder - 1 + k;\n          }\n        });\n      }\n    }\n  } else if (!isSection) {\n    // Drag is not a section\n    // It means the client is dragging a RM component\n    // Falta considerar e testar com items Any\n    // Falta considerar o caso em que o Drop é uma secção\n    if (dragOrder === undefined) {\n      objOrder[dragPath] = hoverOrder;\n      Object.keys(immutableObj).forEach(path => {\n        if (immutableObj[path] >= hoverOrder) {\n          objOrder[path] = immutableObj[path] + 1; //move item up\n        }\n      });\n    } // Move up item\n    else if (dragOrder > hoverOrder) {\n      if (isAnyDrag === true && showLabelDrag === true) {\n        // Drag is an Any item => Drop can be anything\n        let anyItems = []; // Doesn't include first item\n\n        let countAnyItems = 0; // Doesn't include first item\n        // verificar se há um anyItem\n\n        Object.keys(immutableObj).forEach(path => {\n          let query = dragPath.split('.');\n          query.pop(); // comparar se no order existe algum path que contenha o caminho anterior - significa que é um anyItem\n\n          if (path.indexOf(query.join('.') + \".\") > -1 && path !== dragPath) {\n            anyItems.push(path);\n            countAnyItems += 1;\n          }\n        });\n        objOrder[dragPath] = hoverOrder;\n        let i = 0;\n        Object.keys(immutableObj).forEach(path => {\n          // se for o AnyItem, o valor do order - objOrder - fica o hoverOrder + o nº de anyItems encontrados até àquele path\n          if (anyItems.indexOf(path) > -1) {\n            i += 1;\n            objOrder[path] = hoverOrder + i;\n          } // se não for AnyItem, o valor do order - objOrder - fica o valor que tinha + o nº de anyItems + 1\n          else if (immutableObj[path] >= hoverOrder && immutableObj[path] < dragOrder) {\n            objOrder[path] = immutableObj[path] + countAnyItems + 1;\n          }\n        });\n      } else {\n        // Drag is a normal item (not Any item) => Drop can be anything\n        objOrder[dragPath] = hoverOrder;\n        Object.keys(immutableObj).forEach(path => {\n          if (immutableObj[path] >= hoverOrder && immutableObj[path] < dragOrder) {\n            objOrder[path] = immutableObj[path] + 1;\n          }\n        });\n      }\n    } // Move down item\n    else if (dragOrder < hoverOrder) {\n      if (isAnyDrag === true && showLabelDrag === true) {\n        // Drag is an Any item\n        if (!isSectionHover && isAnyHover === true && showLabelHover === true) {\n          // Drop is an Any item\n          let anyItemsDrag = []; // Doesn't include the first item\n\n          let countAnyItemsDrag = 0; // Doesn't include the first item\n\n          let anyItemsHover = []; // Includes the first item\n\n          let countAnyItemsHover = 0; // Includes the first item\n\n          Object.keys(immutableObj).forEach(path => {\n            let queryDrag = dragPath.split('.');\n            queryDrag.pop();\n            let queryHover = hoverPath.split('.');\n            queryHover.pop();\n            if (path.indexOf(queryDrag.join('.') + \".\") > -1 && path !== dragPath) {\n              anyItemsDrag.push(path);\n              countAnyItemsDrag += 1;\n            }\n            if (path.indexOf(queryHover.join('.') + \".\") > -1) {\n              anyItemsHover.push(path);\n              countAnyItemsHover += 1;\n            }\n          });\n          let newDragOrder = countAnyItemsHover + hoverOrder - countAnyItemsDrag - 1;\n          objOrder[dragPath] = newDragOrder;\n          let i = 0;\n          let j = 0;\n          let k = 0;\n          Object.keys(immutableObj).forEach(path => {\n            if (anyItemsDrag.indexOf(path) > -1) {\n              i += 1;\n              objOrder[path] = newDragOrder + i;\n            } else if (anyItemsHover.indexOf(path) > -1) {\n              j += 1;\n              objOrder[path] = hoverOrder - countAnyItemsDrag - 2 + j;\n            } else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder + countAnyItemsDrag) {\n              k += 1;\n              objOrder[path] = dragOrder - 1 + k;\n            }\n          });\n        } else if (isSectionHover) {\n          // Drop is a section\n          let anyItemsDrag = []; // Doesn't include first item\n\n          let countAnyItemsDrag = 0; // Doesn't include first item\n\n          let subItemsHover = []; // Doesn't include section title\n\n          let countSubItemsHover = 0; // Doesn't include section title\n\n          Object.keys(immutableObj).forEach(path => {\n            let queryDrag = dragPath.split('.');\n            queryDrag.pop();\n            if (path.indexOf(queryDrag.join('.') + \".\") > -1 && path !== dragPath) {\n              anyItemsDrag.push(path);\n              countAnyItemsDrag += 1;\n            }\n            if (path.indexOf(hoverPath + \".\") > -1 && path !== hoverPath) {\n              subItemsHover.push(path);\n              countSubItemsHover += 1;\n            }\n          });\n          let newDragOrder = countSubItemsHover + 1 + hoverOrder - countAnyItemsDrag - 1;\n          objOrder[dragPath] = newDragOrder;\n          let i = 0;\n          let j = 0;\n          let k = 0;\n          Object.keys(immutableObj).forEach(path => {\n            if (anyItemsDrag.indexOf(path) > -1) {\n              i += 1;\n              objOrder[path] = newDragOrder + i;\n            } else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder + countAnyItemsDrag) {\n              k += 1;\n              objOrder[path] = dragOrder - 1 + k;\n            } else if (immutableObj[path] >= hoverOrder && immutableObj[path] <= hoverOrder + countSubItemsHover) {\n              j += 1;\n              objOrder[path] = hoverOrder - countAnyItemsDrag - 2 + j;\n            }\n          });\n        } else if (!isSectionHover && isAnyHover === false) {\n          // Drop is not a section => normal item\n          let anyItems = [];\n          let countAnyItems = 0;\n          Object.keys(immutableObj).forEach(path => {\n            let query = dragPath.split('.');\n            query.pop();\n            if (path.indexOf(query.join('.') + \".\") > -1 && path !== dragPath) {\n              anyItems.push(path);\n              countAnyItems += 1;\n            }\n          });\n          let newDragOrder = hoverOrder - countAnyItems;\n          objOrder[dragPath] = newDragOrder;\n          let i = 0;\n          let j = 0;\n          Object.keys(immutableObj).forEach(path => {\n            if (anyItems.indexOf(path) > -1) {\n              i += 1;\n              objOrder[path] = newDragOrder + i;\n            } else if (immutableObj[path] <= hoverOrder && immutableObj[path] > dragOrder + countAnyItems) {\n              j += 1;\n              objOrder[path] = dragOrder + j - 1;\n            }\n          });\n        }\n      } else {\n        // Drag is a normal item (not Any item or a section)\n        if (!isSectionHover && isAnyHover === true && showLabelHover === true) {\n          // Drop is an Any item\n          let anyItemsHover = []; // Includes the first item\n\n          let countAnyItemsHover = 0; // Includes the first item\n\n          Object.keys(immutableObj).forEach(path => {\n            let query = hoverPath.split('.');\n            query.pop();\n            if (path.indexOf(query.join('.') + \".\") > -1) {\n              anyItemsHover.push(path);\n              countAnyItemsHover += 1;\n            }\n          });\n          let newDragOrder = countAnyItemsHover + hoverOrder - 1;\n          objOrder[dragPath] = newDragOrder;\n          let i = 0;\n          let j = 0;\n          Object.keys(immutableObj).forEach(path => {\n            if (immutableObj[path] > dragOrder && immutableObj[path] < hoverOrder) {\n              i += 1;\n              objOrder[path] = dragOrder - 1 + i;\n            } else if (anyItemsHover.indexOf(path) > -1) {\n              j += 1;\n              objOrder[path] = hoverOrder - 2 + j;\n            }\n          });\n        } else if (!isSectionHover && isAnyHover === false) {\n          // Drop is not a section => is a normal item\n          objOrder[dragPath] = hoverOrder;\n          Object.keys(immutableObj).forEach(path => {\n            if (immutableObj[path] <= hoverOrder && immutableObj[path] > dragOrder) {\n              objOrder[path] = immutableObj[path] - 1;\n            }\n          });\n        } else if (isSectionHover) {\n          // Drop is a section\n          let subItemsHover = []; // Doesn't include the section title\n\n          let countSubItemsHover = 0; // Doesn't include the section title\n          // ir buscar todos os subItems da secção onde está a ser feito o drop\n\n          Object.keys(immutableObj).forEach(path => {\n            if (path.indexOf(hoverPath + \".\") > -1 && path !== hoverPath) {\n              subItemsHover.push(path);\n              countSubItemsHover += 1;\n            }\n          });\n          let newDragOrder = countSubItemsHover + hoverOrder;\n          objOrder[dragPath] = newDragOrder;\n          let i = 0;\n          let j = 0;\n          Object.keys(immutableObj).forEach(path => {\n            if (subItemsHover.indexOf(path) > -1) {\n              i += 1;\n              objOrder[path] = hoverOrder - 2 + i;\n            } else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder) {\n              j += 1;\n              objOrder[path] = dragOrder - 1 + j;\n            }\n          });\n        }\n      }\n    }\n  }\n  return objOrder;\n};\nexport { handleOrder };","map":{"version":3,"names":["orderObjectByValue","handleOrder","isSection","isSectionHover","dragPath","hoverPath","dragOrder","hoverOrder","showLabelDrag","showLabelHover","isAnyDrag","isAnyHover","formOrder","immutableObj","objOrder","countSubItemsHover","countSubItemsDrag","Object","keys","forEach","path","indexOf","i","j","k","newDragOrder","countSubItems","anyItemsHover","countAnyItemsHover","query","split","pop","join","push","undefined","anyItems","countAnyItems","anyItemsDrag","countAnyItemsDrag","queryDrag","queryHover","subItemsHover"],"sources":["C:/Users/ines_/fisiosys/fisiosys/frontend/node_modules/protected-aidaforms/dist/assets/functions/HandleOrder/HandleOrder.js"],"sourcesContent":["import { orderObjectByValue } from \"../Order/orderObjectByValue\"; // Tendo em conta que temos: items únicos, items Any (mesmo field com mais do que um datatype) e sections (tem vários items)\r\n\r\nconst handleOrder = (isSection, isSectionHover, dragPath, hoverPath, dragOrder, hoverOrder, showLabelDrag, showLabelHover, isAnyDrag, isAnyHover, formOrder) => {\r\n  const immutableObj = orderObjectByValue(formOrder); // To guarantee the paths are by ascendent order while doing forEach\r\n\r\n  let objOrder = { ...immutableObj\r\n  };\r\n\r\n  if (isSection) {\r\n    // Drag is a section\r\n    if (isSectionHover) {\r\n      // Drag and drop are both sections\r\n      let countSubItemsHover = 0;\r\n      let countSubItemsDrag = 0;\r\n      Object.keys(immutableObj).forEach(path => {\r\n        if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\r\n          countSubItemsDrag += 1;\r\n        } else if (path.indexOf(hoverPath + \".\") > -1 && path !== hoverPath) {\r\n          countSubItemsHover += 1;\r\n        }\r\n      });\r\n\r\n      if (dragOrder > hoverOrder) {\r\n        // Move up section\r\n        objOrder[dragPath] = hoverOrder;\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = 0;\r\n        Object.keys(immutableObj).forEach(path => {\r\n          // Items are subitems of the drag section\r\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItemsDrag) {\r\n            i += 1;\r\n            objOrder[path] = hoverOrder + i;\r\n          } // Items are subitems of the hover section \r\n          else if (immutableObj[path] >= hoverOrder && immutableObj[path] <= hoverOrder + countSubItemsHover) {\r\n              j += 1;\r\n              objOrder[path] = hoverOrder + countSubItemsDrag + j;\r\n            } // Items are not subitems of either sections\r\n            else if (immutableObj[path] > hoverOrder + countSubItemsHover && immutableObj[path] < dragOrder) {\r\n                k += 1;\r\n                objOrder[path] = hoverOrder + countSubItemsDrag + 1 + countSubItemsHover + k;\r\n              }\r\n        });\r\n      } else if (dragOrder < hoverOrder) {\r\n        // Move down section\r\n        let newDragOrder = countSubItemsHover + hoverOrder - countSubItemsDrag;\r\n        objOrder[dragPath] = newDragOrder;\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = 0;\r\n        Object.keys(immutableObj).forEach(path => {\r\n          // Items are subitems of the drag section\r\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItemsDrag) {\r\n            i += 1;\r\n            objOrder[path] = newDragOrder + i;\r\n          } // Items are subitems of the hover section \r\n          else if (immutableObj[path] >= hoverOrder && immutableObj[path] <= hoverOrder + countSubItemsHover) {\r\n              j += 1; // dragOrder - 1 + ((hoverOrder - (dragOrder + countSubItemsDrag)) - 1) + j \r\n\r\n              objOrder[path] = hoverOrder - countSubItemsDrag - 2 + j;\r\n            } // Items are not subitems of either sections\r\n            else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder + countSubItemsDrag) {\r\n                k += 1;\r\n                objOrder[path] = dragOrder - 1 + k;\r\n              }\r\n        });\r\n      }\r\n    } else if (!isSectionHover && isAnyHover === false) {\r\n      // Drag is a section and drop is a item \r\n      let countSubItems = 0;\r\n      Object.keys(immutableObj).forEach(path => {\r\n        if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\r\n          countSubItems += 1;\r\n        }\r\n      });\r\n\r\n      if (dragOrder > hoverOrder) {\r\n        // Move up section\r\n        objOrder[dragPath] = hoverOrder;\r\n        let i = 0;\r\n        Object.keys(immutableObj).forEach(path => {\r\n          // Items are not subitems of the section\r\n          if (immutableObj[path] < dragOrder && immutableObj[path] >= hoverOrder) {\r\n            objOrder[path] = immutableObj[path] + (countSubItems + 1);\r\n          } // Items are subitems of the section\r\n          else if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItems) {\r\n              i += 1;\r\n              objOrder[path] = hoverOrder + i;\r\n            }\r\n        });\r\n      } else if (dragOrder < hoverOrder) {\r\n        // Move down section\r\n        let newDragOrder = hoverOrder - countSubItems;\r\n        objOrder[dragPath] = newDragOrder;\r\n        let i = 0;\r\n        Object.keys(immutableObj).forEach(path => {\r\n          // Items are not subitems of the section\r\n          if (immutableObj[path] > dragOrder + countSubItems && immutableObj[path] <= hoverOrder) {\r\n            objOrder[path] = immutableObj[path] - (countSubItems + 1);\r\n          } // Items are subitems of the section\r\n          else if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItems) {\r\n              i += 1;\r\n              objOrder[path] = newDragOrder + i;\r\n            }\r\n        });\r\n      }\r\n    } else if (isAnyHover === true && showLabelHover === true) {\r\n      // Drag is a section and drop is an Any item\r\n      if (dragOrder > hoverOrder) {\r\n        // Move up section\r\n        let countSubItemsDrag = 0; // Doesn't include the title\r\n\r\n        Object.keys(immutableObj).forEach(path => {\r\n          if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\r\n            countSubItemsDrag += 1;\r\n          }\r\n        });\r\n        objOrder[dragPath] = hoverOrder;\r\n        let i = 0;\r\n        Object.keys(immutableObj).forEach(path => {\r\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItemsDrag) {\r\n            i += 1;\r\n            objOrder[path] = hoverOrder + i;\r\n          } else if (immutableObj[path] < dragOrder && immutableObj[path] >= hoverOrder) {\r\n            objOrder[path] = immutableObj[path] + (countSubItemsDrag + 1);\r\n          }\r\n        });\r\n      } else if (dragOrder < hoverOrder) {\r\n        // Move down section\r\n        let countSubItemsDrag = 0; // Doesn't include the title\r\n\r\n        let anyItemsHover = []; // Includes the first item\r\n\r\n        let countAnyItemsHover = 0; // Includes the first item\r\n\r\n        Object.keys(immutableObj).forEach(path => {\r\n          let query = hoverPath.split('.');\r\n          query.pop();\r\n\r\n          if (path.indexOf(query.join('.') + \".\") > -1) {\r\n            anyItemsHover.push(path);\r\n            countAnyItemsHover += 1;\r\n          }\r\n\r\n          if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\r\n            countSubItemsDrag += 1;\r\n          }\r\n        });\r\n        let newDragOrder = hoverOrder - countSubItemsDrag + countAnyItemsHover - 1;\r\n        objOrder[dragPath] = newDragOrder;\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = 0;\r\n        Object.keys(immutableObj).forEach(path => {\r\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItemsDrag) {\r\n            i += 1;\r\n            objOrder[path] = newDragOrder + i;\r\n          } else if (anyItemsHover.indexOf(path) > -1) {\r\n            j += 1;\r\n            objOrder[path] = hoverOrder - countSubItemsDrag - 2 + j;\r\n          } else if (immutableObj[path] > dragOrder + countSubItemsDrag && immutableObj[path] < hoverOrder) {\r\n            k += 1;\r\n            objOrder[path] = dragOrder - 1 + k;\r\n          }\r\n        });\r\n      }\r\n    }\r\n  } else if (!isSection) {\r\n    // Drag is not a section\r\n    // It means the client is dragging a RM component\r\n    // Falta considerar e testar com items Any\r\n    // Falta considerar o caso em que o Drop é uma secção\r\n    if (dragOrder === undefined) {\r\n      objOrder[dragPath] = hoverOrder;\r\n      Object.keys(immutableObj).forEach(path => {\r\n        if (immutableObj[path] >= hoverOrder) {\r\n          objOrder[path] = immutableObj[path] + 1; //move item up\r\n        }\r\n      });\r\n    } // Move up item\r\n    else if (dragOrder > hoverOrder) {\r\n        if (isAnyDrag === true && showLabelDrag === true) {\r\n          // Drag is an Any item => Drop can be anything\r\n          let anyItems = []; // Doesn't include first item\r\n\r\n          let countAnyItems = 0; // Doesn't include first item\r\n          // verificar se há um anyItem\r\n\r\n          Object.keys(immutableObj).forEach(path => {\r\n            let query = dragPath.split('.');\r\n            query.pop(); // comparar se no order existe algum path que contenha o caminho anterior - significa que é um anyItem\r\n\r\n            if (path.indexOf(query.join('.') + \".\") > -1 && path !== dragPath) {\r\n              anyItems.push(path);\r\n              countAnyItems += 1;\r\n            }\r\n          });\r\n          objOrder[dragPath] = hoverOrder;\r\n          let i = 0;\r\n          Object.keys(immutableObj).forEach(path => {\r\n            // se for o AnyItem, o valor do order - objOrder - fica o hoverOrder + o nº de anyItems encontrados até àquele path\r\n            if (anyItems.indexOf(path) > -1) {\r\n              i += 1;\r\n              objOrder[path] = hoverOrder + i;\r\n            } // se não for AnyItem, o valor do order - objOrder - fica o valor que tinha + o nº de anyItems + 1\r\n            else if (immutableObj[path] >= hoverOrder && immutableObj[path] < dragOrder) {\r\n                objOrder[path] = immutableObj[path] + countAnyItems + 1;\r\n              }\r\n          });\r\n        } else {\r\n          // Drag is a normal item (not Any item) => Drop can be anything\r\n          objOrder[dragPath] = hoverOrder;\r\n          Object.keys(immutableObj).forEach(path => {\r\n            if (immutableObj[path] >= hoverOrder && immutableObj[path] < dragOrder) {\r\n              objOrder[path] = immutableObj[path] + 1;\r\n            }\r\n          });\r\n        }\r\n      } // Move down item\r\n      else if (dragOrder < hoverOrder) {\r\n          if (isAnyDrag === true && showLabelDrag === true) {\r\n            // Drag is an Any item\r\n            if (!isSectionHover && isAnyHover === true && showLabelHover === true) {\r\n              // Drop is an Any item\r\n              let anyItemsDrag = []; // Doesn't include the first item\r\n\r\n              let countAnyItemsDrag = 0; // Doesn't include the first item\r\n\r\n              let anyItemsHover = []; // Includes the first item\r\n\r\n              let countAnyItemsHover = 0; // Includes the first item\r\n\r\n              Object.keys(immutableObj).forEach(path => {\r\n                let queryDrag = dragPath.split('.');\r\n                queryDrag.pop();\r\n                let queryHover = hoverPath.split('.');\r\n                queryHover.pop();\r\n\r\n                if (path.indexOf(queryDrag.join('.') + \".\") > -1 && path !== dragPath) {\r\n                  anyItemsDrag.push(path);\r\n                  countAnyItemsDrag += 1;\r\n                }\r\n\r\n                if (path.indexOf(queryHover.join('.') + \".\") > -1) {\r\n                  anyItemsHover.push(path);\r\n                  countAnyItemsHover += 1;\r\n                }\r\n              });\r\n              let newDragOrder = countAnyItemsHover + hoverOrder - countAnyItemsDrag - 1;\r\n              objOrder[dragPath] = newDragOrder;\r\n              let i = 0;\r\n              let j = 0;\r\n              let k = 0;\r\n              Object.keys(immutableObj).forEach(path => {\r\n                if (anyItemsDrag.indexOf(path) > -1) {\r\n                  i += 1;\r\n                  objOrder[path] = newDragOrder + i;\r\n                } else if (anyItemsHover.indexOf(path) > -1) {\r\n                  j += 1;\r\n                  objOrder[path] = hoverOrder - countAnyItemsDrag - 2 + j;\r\n                } else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder + countAnyItemsDrag) {\r\n                  k += 1;\r\n                  objOrder[path] = dragOrder - 1 + k;\r\n                }\r\n              });\r\n            } else if (isSectionHover) {\r\n              // Drop is a section\r\n              let anyItemsDrag = []; // Doesn't include first item\r\n\r\n              let countAnyItemsDrag = 0; // Doesn't include first item\r\n\r\n              let subItemsHover = []; // Doesn't include section title\r\n\r\n              let countSubItemsHover = 0; // Doesn't include section title\r\n\r\n              Object.keys(immutableObj).forEach(path => {\r\n                let queryDrag = dragPath.split('.');\r\n                queryDrag.pop();\r\n\r\n                if (path.indexOf(queryDrag.join('.') + \".\") > -1 && path !== dragPath) {\r\n                  anyItemsDrag.push(path);\r\n                  countAnyItemsDrag += 1;\r\n                }\r\n\r\n                if (path.indexOf(hoverPath + \".\") > -1 && path !== hoverPath) {\r\n                  subItemsHover.push(path);\r\n                  countSubItemsHover += 1;\r\n                }\r\n              });\r\n              let newDragOrder = countSubItemsHover + 1 + hoverOrder - countAnyItemsDrag - 1;\r\n              objOrder[dragPath] = newDragOrder;\r\n              let i = 0;\r\n              let j = 0;\r\n              let k = 0;\r\n              Object.keys(immutableObj).forEach(path => {\r\n                if (anyItemsDrag.indexOf(path) > -1) {\r\n                  i += 1;\r\n                  objOrder[path] = newDragOrder + i;\r\n                } else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder + countAnyItemsDrag) {\r\n                  k += 1;\r\n                  objOrder[path] = dragOrder - 1 + k;\r\n                } else if (immutableObj[path] >= hoverOrder && immutableObj[path] <= hoverOrder + countSubItemsHover) {\r\n                  j += 1;\r\n                  objOrder[path] = hoverOrder - countAnyItemsDrag - 2 + j;\r\n                }\r\n              });\r\n            } else if (!isSectionHover && isAnyHover === false) {\r\n              // Drop is not a section => normal item\r\n              let anyItems = [];\r\n              let countAnyItems = 0;\r\n              Object.keys(immutableObj).forEach(path => {\r\n                let query = dragPath.split('.');\r\n                query.pop();\r\n\r\n                if (path.indexOf(query.join('.') + \".\") > -1 && path !== dragPath) {\r\n                  anyItems.push(path);\r\n                  countAnyItems += 1;\r\n                }\r\n              });\r\n              let newDragOrder = hoverOrder - countAnyItems;\r\n              objOrder[dragPath] = newDragOrder;\r\n              let i = 0;\r\n              let j = 0;\r\n              Object.keys(immutableObj).forEach(path => {\r\n                if (anyItems.indexOf(path) > -1) {\r\n                  i += 1;\r\n                  objOrder[path] = newDragOrder + i;\r\n                } else if (immutableObj[path] <= hoverOrder && immutableObj[path] > dragOrder + countAnyItems) {\r\n                  j += 1;\r\n                  objOrder[path] = dragOrder + j - 1;\r\n                }\r\n              });\r\n            }\r\n          } else {\r\n            // Drag is a normal item (not Any item or a section)\r\n            if (!isSectionHover && isAnyHover === true && showLabelHover === true) {\r\n              // Drop is an Any item\r\n              let anyItemsHover = []; // Includes the first item\r\n\r\n              let countAnyItemsHover = 0; // Includes the first item\r\n\r\n              Object.keys(immutableObj).forEach(path => {\r\n                let query = hoverPath.split('.');\r\n                query.pop();\r\n\r\n                if (path.indexOf(query.join('.') + \".\") > -1) {\r\n                  anyItemsHover.push(path);\r\n                  countAnyItemsHover += 1;\r\n                }\r\n              });\r\n              let newDragOrder = countAnyItemsHover + hoverOrder - 1;\r\n              objOrder[dragPath] = newDragOrder;\r\n              let i = 0;\r\n              let j = 0;\r\n              Object.keys(immutableObj).forEach(path => {\r\n                if (immutableObj[path] > dragOrder && immutableObj[path] < hoverOrder) {\r\n                  i += 1;\r\n                  objOrder[path] = dragOrder - 1 + i;\r\n                } else if (anyItemsHover.indexOf(path) > -1) {\r\n                  j += 1;\r\n                  objOrder[path] = hoverOrder - 2 + j;\r\n                }\r\n              });\r\n            } else if (!isSectionHover && isAnyHover === false) {\r\n              // Drop is not a section => is a normal item\r\n              objOrder[dragPath] = hoverOrder;\r\n              Object.keys(immutableObj).forEach(path => {\r\n                if (immutableObj[path] <= hoverOrder && immutableObj[path] > dragOrder) {\r\n                  objOrder[path] = immutableObj[path] - 1;\r\n                }\r\n              });\r\n            } else if (isSectionHover) {\r\n              // Drop is a section\r\n              let subItemsHover = []; // Doesn't include the section title\r\n\r\n              let countSubItemsHover = 0; // Doesn't include the section title\r\n              // ir buscar todos os subItems da secção onde está a ser feito o drop\r\n\r\n              Object.keys(immutableObj).forEach(path => {\r\n                if (path.indexOf(hoverPath + \".\") > -1 && path !== hoverPath) {\r\n                  subItemsHover.push(path);\r\n                  countSubItemsHover += 1;\r\n                }\r\n              });\r\n              let newDragOrder = countSubItemsHover + hoverOrder;\r\n              objOrder[dragPath] = newDragOrder;\r\n              let i = 0;\r\n              let j = 0;\r\n              Object.keys(immutableObj).forEach(path => {\r\n                if (subItemsHover.indexOf(path) > -1) {\r\n                  i += 1;\r\n                  objOrder[path] = hoverOrder - 2 + i;\r\n                } else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder) {\r\n                  j += 1;\r\n                  objOrder[path] = dragOrder - 1 + j;\r\n                }\r\n              });\r\n            }\r\n          }\r\n        }\r\n  }\r\n\r\n  return objOrder;\r\n};\r\n\r\nexport { handleOrder };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}