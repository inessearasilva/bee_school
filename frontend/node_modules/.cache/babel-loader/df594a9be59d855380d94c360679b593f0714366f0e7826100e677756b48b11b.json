{"ast":null,"code":"'use strict';\n\nconst {\n  webidl\n} = require('../fetch/webidl');\nconst {\n  DOMException\n} = require('../fetch/constants');\nconst {\n  URLSerializer\n} = require('../fetch/dataURL');\nconst {\n  staticPropertyDescriptors,\n  states,\n  opcodes,\n  emptyBuffer\n} = require('./constants');\nconst {\n  kWebSocketURL,\n  kReadyState,\n  kController,\n  kBinaryType,\n  kResponse,\n  kSentClose,\n  kByteParser\n} = require('./symbols');\nconst {\n  isEstablished,\n  isClosing,\n  isValidSubprotocol,\n  failWebsocketConnection,\n  fireEvent\n} = require('./util');\nconst {\n  establishWebSocketConnection\n} = require('./connection');\nconst {\n  WebsocketFrameSend\n} = require('./frame');\nconst {\n  ByteParser\n} = require('./receiver');\nconst {\n  kEnumerableProperty,\n  isBlobLike\n} = require('../core/util');\nconst {\n  getGlobalDispatcher\n} = require('../global');\nconst {\n  types\n} = require('util');\nlet experimentalWarned = false;\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  };\n  #bufferedAmount = 0;\n  #protocol = '';\n  #extensions = '';\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor(url) {\n    let protocols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    super();\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'WebSocket constructor'\n    });\n    if (!experimentalWarned) {\n      experimentalWarned = true;\n      process.emitWarning('WebSockets are experimental, expect them to change at any time.', {\n        code: 'UNDICI-WS'\n      });\n    }\n    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols);\n    url = webidl.converters.USVString(url);\n    protocols = options.protocols;\n\n    // 1. Let urlRecord be the result of applying the URL parser to url.\n    let urlRecord;\n    try {\n      urlRecord = new URL(url);\n    } catch (e) {\n      // 2. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError');\n    }\n\n    // 3. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a\n    //    \"SyntaxError\" DOMException.\n    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n      throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, 'SyntaxError');\n    }\n\n    // 4. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n    //    DOMException.\n    if (urlRecord.hash) {\n      throw new DOMException('Got fragment', 'SyntaxError');\n    }\n\n    // 5. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols];\n    }\n\n    // 6. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');\n    }\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');\n    }\n\n    // 7. Set this's url to urlRecord.\n    this[kWebSocketURL] = urlRecord;\n\n    // 8. Let client be this's relevant settings object.\n\n    // 9. Run this step in parallel:\n\n    //    1. Establish a WebSocket connection given urlRecord, protocols,\n    //       and client.\n    this[kController] = establishWebSocketConnection(urlRecord, protocols, this, response => this.#onConnectionEstablished(response), options);\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this[kReadyState] = WebSocket.CONNECTING;\n\n    // The extensions attribute must initially return the empty string.\n\n    // The protocol attribute must initially return the empty string.\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this[kBinaryType] = 'blob';\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close() {\n    let code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    webidl.brandCheck(this, WebSocket);\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, {\n        clamp: true\n      });\n    }\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason);\n    }\n\n    // 1. If code is present, but is neither an integer equal to 1000 nor an\n    //    integer in the range 3000 to 4999, inclusive, throw an\n    //    \"InvalidAccessError\" DOMException.\n    if (code !== undefined) {\n      if (code !== 1000 && (code < 3000 || code > 4999)) {\n        throw new DOMException('invalid code', 'InvalidAccessError');\n      }\n    }\n    let reasonByteLength = 0;\n\n    // 2. If reason is present, then run these substeps:\n    if (reason !== undefined) {\n      // 1. Let reasonBytes be the result of encoding reason.\n      // 2. If reasonBytes is longer than 123 bytes, then throw a\n      //    \"SyntaxError\" DOMException.\n      reasonByteLength = Buffer.byteLength(reason);\n      if (reasonByteLength > 123) {\n        throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, 'SyntaxError');\n      }\n    }\n\n    // 3. Run the first matching steps from the following list:\n    if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {\n      // If this's ready state is CLOSING (2) or CLOSED (3)\n      // Do nothing.\n    } else if (!isEstablished(this)) {\n      // If the WebSocket connection is not yet established\n      // Fail the WebSocket connection and set this's ready state\n      // to CLOSING (2).\n      failWebsocketConnection(this, 'Connection was closed before it was established.');\n      this[kReadyState] = WebSocket.CLOSING;\n    } else if (!isClosing(this)) {\n      // If the WebSocket closing handshake has not yet been started\n      // Start the WebSocket closing handshake and set this's ready\n      // state to CLOSING (2).\n      // - If neither code nor reason is present, the WebSocket Close\n      //   message must not have a body.\n      // - If code is present, then the status code to use in the\n      //   WebSocket Close message must be the integer given by code.\n      // - If reason is also present, then reasonBytes must be\n      //   provided in the Close message after the status code.\n\n      const frame = new WebsocketFrameSend();\n\n      // If neither code nor reason is present, the WebSocket Close\n      // message must not have a body.\n\n      // If code is present, then the status code to use in the\n      // WebSocket Close message must be the integer given by code.\n      if (code !== undefined && reason === undefined) {\n        frame.frameData = Buffer.allocUnsafe(2);\n        frame.frameData.writeUInt16BE(code, 0);\n      } else if (code !== undefined && reason !== undefined) {\n        // If reason is also present, then reasonBytes must be\n        // provided in the Close message after the status code.\n        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);\n        frame.frameData.writeUInt16BE(code, 0);\n        // the body MAY contain UTF-8-encoded data with value /reason/\n        frame.frameData.write(reason, 2, 'utf-8');\n      } else {\n        frame.frameData = emptyBuffer;\n      }\n\n      /** @type {import('stream').Duplex} */\n      const socket = this[kResponse].socket;\n      socket.write(frame.createFrame(opcodes.CLOSE), err => {\n        if (!err) {\n          this[kSentClose] = true;\n        }\n      });\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this[kReadyState] = states.CLOSING;\n    } else {\n      // Otherwise\n      // Set this's ready state to CLOSING (2).\n      this[kReadyState] = WebSocket.CLOSING;\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send(data) {\n    webidl.brandCheck(this, WebSocket);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'WebSocket.send'\n    });\n    data = webidl.converters.WebSocketSendData(data);\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (this[kReadyState] === WebSocket.CONNECTING) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError');\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this) || isClosing(this)) {\n      return;\n    }\n\n    /** @type {import('stream').Duplex} */\n    const socket = this[kResponse].socket;\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const value = Buffer.from(data);\n      const frame = new WebsocketFrameSend(value);\n      const buffer = frame.createFrame(opcodes.TEXT);\n      this.#bufferedAmount += value.byteLength;\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength;\n      });\n    } else if (types.isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      const value = Buffer.from(data);\n      const frame = new WebsocketFrameSend(value);\n      const buffer = frame.createFrame(opcodes.BINARY);\n      this.#bufferedAmount += value.byteLength;\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength;\n      });\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of data’s buffer in bytes.\n\n      const ab = Buffer.from(data, data.byteOffset, data.byteLength);\n      const frame = new WebsocketFrameSend(ab);\n      const buffer = frame.createFrame(opcodes.BINARY);\n      this.#bufferedAmount += ab.byteLength;\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= ab.byteLength;\n      });\n    } else if (isBlobLike(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob object’s raw data, in bytes.\n\n      const frame = new WebsocketFrameSend();\n      data.arrayBuffer().then(ab => {\n        const value = Buffer.from(ab);\n        frame.frameData = value;\n        const buffer = frame.createFrame(opcodes.BINARY);\n        this.#bufferedAmount += value.byteLength;\n        socket.write(buffer, () => {\n          this.#bufferedAmount -= value.byteLength;\n        });\n      });\n    }\n  }\n  get readyState() {\n    webidl.brandCheck(this, WebSocket);\n\n    // The readyState getter steps are to return this's ready state.\n    return this[kReadyState];\n  }\n  get bufferedAmount() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#bufferedAmount;\n  }\n  get url() {\n    webidl.brandCheck(this, WebSocket);\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this[kWebSocketURL]);\n  }\n  get extensions() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#extensions;\n  }\n  get protocol() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#protocol;\n  }\n  get onopen() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.open;\n  }\n  set onopen(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open);\n    }\n    if (typeof fn === 'function') {\n      this.#events.open = fn;\n      this.addEventListener('open', fn);\n    } else {\n      this.#events.open = null;\n    }\n  }\n  get onerror() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.error;\n  }\n  set onerror(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error);\n    }\n    if (typeof fn === 'function') {\n      this.#events.error = fn;\n      this.addEventListener('error', fn);\n    } else {\n      this.#events.error = null;\n    }\n  }\n  get onclose() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.close;\n  }\n  set onclose(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close);\n    }\n    if (typeof fn === 'function') {\n      this.#events.close = fn;\n      this.addEventListener('close', fn);\n    } else {\n      this.#events.close = null;\n    }\n  }\n  get onmessage() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.message;\n  }\n  set onmessage(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message);\n    }\n    if (typeof fn === 'function') {\n      this.#events.message = fn;\n      this.addEventListener('message', fn);\n    } else {\n      this.#events.message = null;\n    }\n  }\n  get binaryType() {\n    webidl.brandCheck(this, WebSocket);\n    return this[kBinaryType];\n  }\n  set binaryType(type) {\n    webidl.brandCheck(this, WebSocket);\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this[kBinaryType] = 'blob';\n    } else {\n      this[kBinaryType] = type;\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */\n  #onConnectionEstablished(response) {\n    // processResponse is called when the \"response’s header list has been received and initialized.\"\n    // once this happens, the connection is open\n    this[kResponse] = response;\n    const parser = new ByteParser(this);\n    parser.on('drain', function onParserDrain() {\n      this.ws[kResponse].socket.resume();\n    });\n    response.socket.ws = this;\n    this[kByteParser] = parser;\n\n    // 1. Change the ready state to OPEN (1).\n    this[kReadyState] = states.OPEN;\n\n    // 2. Change the extensions attribute’s value to the extensions in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n    const extensions = response.headersList.get('sec-websocket-extensions');\n    if (extensions !== null) {\n      this.#extensions = extensions;\n    }\n\n    // 3. Change the protocol attribute’s value to the subprotocol in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n    const protocol = response.headersList.get('sec-websocket-protocol');\n    if (protocol !== null) {\n      this.#protocol = protocol;\n    }\n\n    // 4. Fire an event named open at the WebSocket object.\n    fireEvent('open', this);\n  }\n}\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n});\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n});\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(webidl.converters.DOMString);\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V);\n  }\n  return webidl.converters.DOMString(V);\n};\n\n// This implements the propsal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([{\n  key: 'protocols',\n  converter: webidl.converters['DOMString or sequence<DOMString>'],\n  get defaultValue() {\n    return [];\n  }\n}, {\n  key: 'dispatcher',\n  converter: V => V,\n  get defaultValue() {\n    return getGlobalDispatcher();\n  }\n}, {\n  key: 'headers',\n  converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n}]);\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {\n    return webidl.converters.WebSocketInit(V);\n  }\n  return {\n    protocols: webidl.converters['DOMString or sequence<DOMString>'](V)\n  };\n};\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (isBlobLike(V)) {\n      return webidl.converters.Blob(V, {\n        strict: false\n      });\n    }\n    if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {\n      return webidl.converters.BufferSource(V);\n    }\n  }\n  return webidl.converters.USVString(V);\n};\nmodule.exports = {\n  WebSocket\n};","map":{"version":3,"names":["webidl","require","DOMException","URLSerializer","staticPropertyDescriptors","states","opcodes","emptyBuffer","kWebSocketURL","kReadyState","kController","kBinaryType","kResponse","kSentClose","kByteParser","isEstablished","isClosing","isValidSubprotocol","failWebsocketConnection","fireEvent","establishWebSocketConnection","WebsocketFrameSend","ByteParser","kEnumerableProperty","isBlobLike","getGlobalDispatcher","types","experimentalWarned","WebSocket","EventTarget","events","open","error","close","message","bufferedAmount","protocol","extensions","constructor","url","protocols","argumentLengthCheck","arguments","header","process","emitWarning","code","options","converters","USVString","urlRecord","URL","e","hash","length","Set","map","p","toLowerCase","size","every","response","onConnectionEstablished","CONNECTING","undefined","reason","brandCheck","clamp","reasonByteLength","Buffer","byteLength","CLOSING","CLOSED","frame","frameData","allocUnsafe","writeUInt16BE","write","socket","createFrame","CLOSE","err","send","data","WebSocketSendData","value","from","buffer","TEXT","isArrayBuffer","BINARY","ArrayBuffer","isView","ab","byteOffset","arrayBuffer","then","readyState","onopen","fn","removeEventListener","addEventListener","onerror","onclose","onmessage","binaryType","type","parser","on","onParserDrain","ws","resume","OPEN","headersList","get","prototype","Object","defineProperties","Symbol","toStringTag","writable","enumerable","configurable","sequenceConverter","DOMString","V","util","Type","iterator","WebSocketInit","dictionaryConverter","key","converter","defaultValue","nullableConverter","HeadersInit","Blob","strict","isAnyArrayBuffer","BufferSource","module","exports"],"sources":["C:/Users/ines_/bee_v2/bee_school/frontend/node_modules/undici/lib/websocket/websocket.js"],"sourcesContent":["'use strict'\n\nconst { webidl } = require('../fetch/webidl')\nconst { DOMException } = require('../fetch/constants')\nconst { URLSerializer } = require('../fetch/dataURL')\nconst { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require('./constants')\nconst {\n  kWebSocketURL,\n  kReadyState,\n  kController,\n  kBinaryType,\n  kResponse,\n  kSentClose,\n  kByteParser\n} = require('./symbols')\nconst { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require('./util')\nconst { establishWebSocketConnection } = require('./connection')\nconst { WebsocketFrameSend } = require('./frame')\nconst { ByteParser } = require('./receiver')\nconst { kEnumerableProperty, isBlobLike } = require('../core/util')\nconst { getGlobalDispatcher } = require('../global')\nconst { types } = require('util')\n\nlet experimentalWarned = false\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  }\n\n  #bufferedAmount = 0\n  #protocol = ''\n  #extensions = ''\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor (url, protocols = []) {\n    super()\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket constructor' })\n\n    if (!experimentalWarned) {\n      experimentalWarned = true\n      process.emitWarning('WebSockets are experimental, expect them to change at any time.', {\n        code: 'UNDICI-WS'\n      })\n    }\n\n    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols)\n\n    url = webidl.converters.USVString(url)\n    protocols = options.protocols\n\n    // 1. Let urlRecord be the result of applying the URL parser to url.\n    let urlRecord\n\n    try {\n      urlRecord = new URL(url)\n    } catch (e) {\n      // 2. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 3. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a\n    //    \"SyntaxError\" DOMException.\n    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n      throw new DOMException(\n        `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,\n        'SyntaxError'\n      )\n    }\n\n    // 4. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n    //    DOMException.\n    if (urlRecord.hash) {\n      throw new DOMException('Got fragment', 'SyntaxError')\n    }\n\n    // 5. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols]\n    }\n\n    // 6. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 7. Set this's url to urlRecord.\n    this[kWebSocketURL] = urlRecord\n\n    // 8. Let client be this's relevant settings object.\n\n    // 9. Run this step in parallel:\n\n    //    1. Establish a WebSocket connection given urlRecord, protocols,\n    //       and client.\n    this[kController] = establishWebSocketConnection(\n      urlRecord,\n      protocols,\n      this,\n      (response) => this.#onConnectionEstablished(response),\n      options\n    )\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this[kReadyState] = WebSocket.CONNECTING\n\n    // The extensions attribute must initially return the empty string.\n\n    // The protocol attribute must initially return the empty string.\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this[kBinaryType] = 'blob'\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close (code = undefined, reason = undefined) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, { clamp: true })\n    }\n\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason)\n    }\n\n    // 1. If code is present, but is neither an integer equal to 1000 nor an\n    //    integer in the range 3000 to 4999, inclusive, throw an\n    //    \"InvalidAccessError\" DOMException.\n    if (code !== undefined) {\n      if (code !== 1000 && (code < 3000 || code > 4999)) {\n        throw new DOMException('invalid code', 'InvalidAccessError')\n      }\n    }\n\n    let reasonByteLength = 0\n\n    // 2. If reason is present, then run these substeps:\n    if (reason !== undefined) {\n      // 1. Let reasonBytes be the result of encoding reason.\n      // 2. If reasonBytes is longer than 123 bytes, then throw a\n      //    \"SyntaxError\" DOMException.\n      reasonByteLength = Buffer.byteLength(reason)\n\n      if (reasonByteLength > 123) {\n        throw new DOMException(\n          `Reason must be less than 123 bytes; received ${reasonByteLength}`,\n          'SyntaxError'\n        )\n      }\n    }\n\n    // 3. Run the first matching steps from the following list:\n    if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {\n      // If this's ready state is CLOSING (2) or CLOSED (3)\n      // Do nothing.\n    } else if (!isEstablished(this)) {\n      // If the WebSocket connection is not yet established\n      // Fail the WebSocket connection and set this's ready state\n      // to CLOSING (2).\n      failWebsocketConnection(this, 'Connection was closed before it was established.')\n      this[kReadyState] = WebSocket.CLOSING\n    } else if (!isClosing(this)) {\n      // If the WebSocket closing handshake has not yet been started\n      // Start the WebSocket closing handshake and set this's ready\n      // state to CLOSING (2).\n      // - If neither code nor reason is present, the WebSocket Close\n      //   message must not have a body.\n      // - If code is present, then the status code to use in the\n      //   WebSocket Close message must be the integer given by code.\n      // - If reason is also present, then reasonBytes must be\n      //   provided in the Close message after the status code.\n\n      const frame = new WebsocketFrameSend()\n\n      // If neither code nor reason is present, the WebSocket Close\n      // message must not have a body.\n\n      // If code is present, then the status code to use in the\n      // WebSocket Close message must be the integer given by code.\n      if (code !== undefined && reason === undefined) {\n        frame.frameData = Buffer.allocUnsafe(2)\n        frame.frameData.writeUInt16BE(code, 0)\n      } else if (code !== undefined && reason !== undefined) {\n        // If reason is also present, then reasonBytes must be\n        // provided in the Close message after the status code.\n        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength)\n        frame.frameData.writeUInt16BE(code, 0)\n        // the body MAY contain UTF-8-encoded data with value /reason/\n        frame.frameData.write(reason, 2, 'utf-8')\n      } else {\n        frame.frameData = emptyBuffer\n      }\n\n      /** @type {import('stream').Duplex} */\n      const socket = this[kResponse].socket\n\n      socket.write(frame.createFrame(opcodes.CLOSE), (err) => {\n        if (!err) {\n          this[kSentClose] = true\n        }\n      })\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this[kReadyState] = states.CLOSING\n    } else {\n      // Otherwise\n      // Set this's ready state to CLOSING (2).\n      this[kReadyState] = WebSocket.CLOSING\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send (data) {\n    webidl.brandCheck(this, WebSocket)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket.send' })\n\n    data = webidl.converters.WebSocketSendData(data)\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (this[kReadyState] === WebSocket.CONNECTING) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError')\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this) || isClosing(this)) {\n      return\n    }\n\n    /** @type {import('stream').Duplex} */\n    const socket = this[kResponse].socket\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const value = Buffer.from(data)\n      const frame = new WebsocketFrameSend(value)\n      const buffer = frame.createFrame(opcodes.TEXT)\n\n      this.#bufferedAmount += value.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength\n      })\n    } else if (types.isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      const value = Buffer.from(data)\n      const frame = new WebsocketFrameSend(value)\n      const buffer = frame.createFrame(opcodes.BINARY)\n\n      this.#bufferedAmount += value.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength\n      })\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of data’s buffer in bytes.\n\n      const ab = Buffer.from(data, data.byteOffset, data.byteLength)\n\n      const frame = new WebsocketFrameSend(ab)\n      const buffer = frame.createFrame(opcodes.BINARY)\n\n      this.#bufferedAmount += ab.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= ab.byteLength\n      })\n    } else if (isBlobLike(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob object’s raw data, in bytes.\n\n      const frame = new WebsocketFrameSend()\n\n      data.arrayBuffer().then((ab) => {\n        const value = Buffer.from(ab)\n        frame.frameData = value\n        const buffer = frame.createFrame(opcodes.BINARY)\n\n        this.#bufferedAmount += value.byteLength\n        socket.write(buffer, () => {\n          this.#bufferedAmount -= value.byteLength\n        })\n      })\n    }\n  }\n\n  get readyState () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The readyState getter steps are to return this's ready state.\n    return this[kReadyState]\n  }\n\n  get bufferedAmount () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#bufferedAmount\n  }\n\n  get url () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this[kWebSocketURL])\n  }\n\n  get extensions () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#extensions\n  }\n\n  get protocol () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#protocol\n  }\n\n  get onopen () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.open = fn\n      this.addEventListener('open', fn)\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this.#events.error = null\n    }\n  }\n\n  get onclose () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.close\n  }\n\n  set onclose (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.close = fn\n      this.addEventListener('close', fn)\n    } else {\n      this.#events.close = null\n    }\n  }\n\n  get onmessage () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.message = fn\n      this.addEventListener('message', fn)\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get binaryType () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this[kBinaryType]\n  }\n\n  set binaryType (type) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this[kBinaryType] = 'blob'\n    } else {\n      this[kBinaryType] = type\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */\n  #onConnectionEstablished (response) {\n    // processResponse is called when the \"response’s header list has been received and initialized.\"\n    // once this happens, the connection is open\n    this[kResponse] = response\n\n    const parser = new ByteParser(this)\n    parser.on('drain', function onParserDrain () {\n      this.ws[kResponse].socket.resume()\n    })\n\n    response.socket.ws = this\n    this[kByteParser] = parser\n\n    // 1. Change the ready state to OPEN (1).\n    this[kReadyState] = states.OPEN\n\n    // 2. Change the extensions attribute’s value to the extensions in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n    const extensions = response.headersList.get('sec-websocket-extensions')\n\n    if (extensions !== null) {\n      this.#extensions = extensions\n    }\n\n    // 3. Change the protocol attribute’s value to the subprotocol in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n    const protocol = response.headersList.get('sec-websocket-protocol')\n\n    if (protocol !== null) {\n      this.#protocol = protocol\n    }\n\n    // 4. Fire an event named open at the WebSocket object.\n    fireEvent('open', this)\n  }\n}\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED\n\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n})\n\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(\n  webidl.converters.DOMString\n)\n\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V)\n  }\n\n  return webidl.converters.DOMString(V)\n}\n\n// This implements the propsal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n  {\n    key: 'protocols',\n    converter: webidl.converters['DOMString or sequence<DOMString>'],\n    get defaultValue () {\n      return []\n    }\n  },\n  {\n    key: 'dispatcher',\n    converter: (V) => V,\n    get defaultValue () {\n      return getGlobalDispatcher()\n    }\n  },\n  {\n    key: 'headers',\n    converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n  }\n])\n\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {\n    return webidl.converters.WebSocketInit(V)\n  }\n\n  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }\n}\n\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (isBlobLike(V)) {\n      return webidl.converters.Blob(V, { strict: false })\n    }\n\n    if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {\n      return webidl.converters.BufferSource(V)\n    }\n  }\n\n  return webidl.converters.USVString(V)\n}\n\nmodule.exports = {\n  WebSocket\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}