{"ast":null,"code":"const fieldTarget = {\n  // Only perform the action when the item is dropped, not when hovered.\n  // Otherwise, multiple errors arise in this case.\n  drop(props, monitor) {\n    const dragPath = monitor.getItem().path;\n    const hoverPath = props.path;\n    const dragOrder = monitor.getItem().order;\n    const hoverOrder = props.order;\n    const dragGroupID = monitor.getItem().groupID;\n    const hoverGroupID = props.groupID;\n    const isSectionDrag = monitor.getItem().isSection;\n    const isSectionHover = props.isSection;\n    const showLabelDrag = monitor.getItem().showLabel;\n    const showLabelHover = props.showLabel;\n    const isAnyDrag = monitor.getItem().isAny;\n    const isAnyHover = props.isAny;\n    const isRMComponent = monitor.getItem().isRM; // se for um componente RM, após ser arrastado para uma área válida, é preciso:\n    // 1. transformar no componente correspondente\n    // 2. rearranjar a ordem dos componentes\n    // 3. actualizar o formRM com o componente colocado\n\n    if (isRMComponent) {\n      const dragPathRM = monitor.getItem().pathRM !== undefined ? monitor.getItem().pathRM : monitor.getItem().data.parentPath;\n      const itemPathRM = \"rm.\".concat(monitor.getItem().data.itemPath); // obter o tamanho do itemPath pai do componente RM (path pai -> path da secção à qual o campo do RM pertence)\n\n      let itemPathLength = dragPathRM === \"root\" ? \"items.0.0\".length : dragPathRM.length; // obter o itemPath da secção para a qual o componente está a ser arrastado, extraíndo apenas a parte correspondente ao tamanho do itemPath\n\n      let dropSectionPath = hoverPath.indexOf(\"rm\") > -1 ? props.item.parentPath : hoverPath.substring(0, itemPathLength);\n      const componentRM = monitor.getItem().data;\n      if (monitor.getItem().handleRM !== undefined) {\n        monitor.getItem().handleRM(componentRM, isSectionHover, itemPathRM, hoverPath, dragOrder, hoverOrder, showLabelHover, isAnyHover, dropSectionPath, props.groupID);\n        return;\n      }\n    } // Don't replace items with themselves\n\n    if (dragPath === hoverPath) {\n      return;\n    } // Don't replace items with different groupIDs\n\n    if (dragGroupID !== hoverGroupID) {\n      return;\n    } // Don't move an item of an Any field if it is not the first item\n\n    if (showLabelDrag === false) {\n      const arrayPathDrag = dragPath.split(\".\");\n      arrayPathDrag.pop(); // Só posso ordenar se o quero trocar pelo um dos seus itens any\n\n      if (hoverPath.indexOf(arrayPathDrag.join(\".\") + \".\") > -1) {\n        props.handleFormOrder(\"anyItens\", isSectionDrag, isSectionHover, dragPath, hoverPath, dragOrder, hoverOrder, showLabelDrag, showLabelHover, isAnyDrag, isAnyHover);\n        return;\n      } else {\n        return;\n      }\n    } // Don't drop your field if it is not the first item of an Any field\n\n    if (showLabelHover === false) {\n      const arrayPathHover = hoverPath.split(\".\");\n      arrayPathHover.pop(); // Só posso ordenar se o quero trocar pelo um dos seus itens any\n\n      if (dragPath.indexOf(arrayPathHover.join(\".\") + \".\") > -1) {\n        props.handleFormOrder(\"anyItens\", isSectionDrag, isSectionHover, dragPath, hoverPath, dragOrder, hoverOrder, showLabelDrag, showLabelHover, isAnyDrag, isAnyHover);\n        return;\n      } else {\n        return;\n      }\n    } // Time to actually perform the action\n\n    props.handleFormOrder(\"general\", isSectionDrag, isSectionHover, dragPath, hoverPath, dragOrder, hoverOrder, showLabelDrag, showLabelHover, isAnyDrag, isAnyHover);\n  },\n  canDrop(props, monitor) {\n    const dragPath = monitor.getItem().path;\n    const hoverPath = props.path;\n    const dragGroupID = monitor.getItem().groupID;\n    const hoverGroupID = props.groupID;\n    const showLabelDrag = monitor.getItem().showLabel;\n    const showLabelHover = props.showLabel;\n    const isRMComponent = monitor.getItem().isRM; // se o componente a arrastar for do tipo RM, é preciso ir buscar o path da secção para a qual se está a arrastar o componente\n    // e compará-lo com o path do rmJDT\n\n    if (isRMComponent) {\n      const dragPathRM = monitor.getItem().pathRM !== undefined ? monitor.getItem().pathRM : monitor.getItem().data.parentPath; // obter o tamanho do itemPath do componente RM (path pai - path da secção à qual o RM pertence)\n\n      let itemPathLength = dragPathRM !== undefined ? dragPathRM.length : monitor.getItem().data.parentPath.length; // obter o itemPath da secção para a qual o componente está a ser arrastado, extraíndo apenas a parte correspondente ao tamanho do itemPath\n\n      let dropSectionPath = hoverPath.indexOf(\"rm\") > -1 ? props.item.parentPath : hoverPath.substring(0, itemPathLength); // se forem items do RM correspondentes à secção principal i.e. quando o dragPathRM é \"root\"\n      // estes apenas podem ser arrastados ao nível das outras subsecções que têm sempre o groupID=2\n\n      if (dragPathRM === \"root\" && hoverGroupID === 2) {\n        return true;\n      } // se o path pai do componente RM for igual ao path da secção pai para a qual o componente está a ser arrastado,\n      // significa que estão na mesma secção\n      else if (dropSectionPath === dragPathRM) {\n        return true;\n      } // caso contrário, não podem ser arrastados\n      else {\n        return false;\n      }\n    } // Don't replace items with themselves\n\n    if (dragPath === hoverPath) {\n      return false;\n    } // Don't replace items with different groupIDs\n\n    if (dragGroupID !== hoverGroupID) {\n      return false;\n    } // Don't move an item of an Any field if it is not the first item\n\n    if (showLabelDrag === false) {\n      const arrayPathDrag = dragPath.split(\".\");\n      arrayPathDrag.pop();\n      if (hoverPath.indexOf(arrayPathDrag.join(\".\") + \".\") > -1) {\n        return true;\n      } else {\n        return false;\n      }\n    } // Don't drop your field if it is not the first item of an Any field\n\n    if (showLabelHover === false) {\n      const arrayPathHover = hoverPath.split(\".\");\n      arrayPathHover.pop();\n      if (dragPath.indexOf(arrayPathHover.join(\".\") + \".\") > -1) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    return true;\n  }\n};\nexport { fieldTarget };","map":{"version":3,"names":["fieldTarget","drop","props","monitor","dragPath","getItem","path","hoverPath","dragOrder","order","hoverOrder","dragGroupID","groupID","hoverGroupID","isSectionDrag","isSection","isSectionHover","showLabelDrag","showLabel","showLabelHover","isAnyDrag","isAny","isAnyHover","isRMComponent","isRM","dragPathRM","pathRM","undefined","data","parentPath","itemPathRM","concat","itemPath","itemPathLength","length","dropSectionPath","indexOf","item","substring","componentRM","handleRM","arrayPathDrag","split","pop","join","handleFormOrder","arrayPathHover","canDrop"],"sources":["C:/Users/ines_/Desktop/fisiosys/fisiosys/frontend/node_modules/protected-aidaforms/dist/components/FormDesigner/SpecificationMethods/Target/fieldTarget.js"],"sourcesContent":["const fieldTarget = {\r\n  // Only perform the action when the item is dropped, not when hovered.\r\n  // Otherwise, multiple errors arise in this case.\r\n  drop(props, monitor) {\r\n    const dragPath = monitor.getItem().path;\r\n    const hoverPath = props.path;\r\n    const dragOrder = monitor.getItem().order;\r\n    const hoverOrder = props.order;\r\n    const dragGroupID = monitor.getItem().groupID;\r\n    const hoverGroupID = props.groupID;\r\n    const isSectionDrag = monitor.getItem().isSection;\r\n    const isSectionHover = props.isSection;\r\n    const showLabelDrag = monitor.getItem().showLabel;\r\n    const showLabelHover = props.showLabel;\r\n    const isAnyDrag = monitor.getItem().isAny;\r\n    const isAnyHover = props.isAny;\r\n    const isRMComponent = monitor.getItem().isRM; // se for um componente RM, após ser arrastado para uma área válida, é preciso:\r\n    // 1. transformar no componente correspondente\r\n    // 2. rearranjar a ordem dos componentes\r\n    // 3. actualizar o formRM com o componente colocado\r\n\r\n    if (isRMComponent) {\r\n      const dragPathRM = monitor.getItem().pathRM !== undefined ? monitor.getItem().pathRM : monitor.getItem().data.parentPath;\r\n      const itemPathRM = \"rm.\".concat(monitor.getItem().data.itemPath); // obter o tamanho do itemPath pai do componente RM (path pai -> path da secção à qual o campo do RM pertence)\r\n\r\n      let itemPathLength = dragPathRM === \"root\" ? \"items.0.0\".length : dragPathRM.length; // obter o itemPath da secção para a qual o componente está a ser arrastado, extraíndo apenas a parte correspondente ao tamanho do itemPath\r\n\r\n      let dropSectionPath = hoverPath.indexOf(\"rm\") > -1 ? props.item.parentPath : hoverPath.substring(0, itemPathLength);\r\n      const componentRM = monitor.getItem().data;\r\n\r\n      if (monitor.getItem().handleRM !== undefined) {\r\n        monitor.getItem().handleRM(componentRM, isSectionHover, itemPathRM, hoverPath, dragOrder, hoverOrder, showLabelHover, isAnyHover, dropSectionPath, props.groupID);\r\n        return;\r\n      }\r\n    } // Don't replace items with themselves\r\n\r\n\r\n    if (dragPath === hoverPath) {\r\n      return;\r\n    } // Don't replace items with different groupIDs\r\n\r\n\r\n    if (dragGroupID !== hoverGroupID) {\r\n      return;\r\n    } // Don't move an item of an Any field if it is not the first item\r\n\r\n\r\n    if (showLabelDrag === false) {\r\n      const arrayPathDrag = dragPath.split(\".\");\r\n      arrayPathDrag.pop(); // Só posso ordenar se o quero trocar pelo um dos seus itens any\r\n\r\n      if (hoverPath.indexOf(arrayPathDrag.join(\".\") + \".\") > -1) {\r\n        props.handleFormOrder(\"anyItens\", isSectionDrag, isSectionHover, dragPath, hoverPath, dragOrder, hoverOrder, showLabelDrag, showLabelHover, isAnyDrag, isAnyHover);\r\n        return;\r\n      } else {\r\n        return;\r\n      }\r\n    } // Don't drop your field if it is not the first item of an Any field\r\n\r\n\r\n    if (showLabelHover === false) {\r\n      const arrayPathHover = hoverPath.split(\".\");\r\n      arrayPathHover.pop(); // Só posso ordenar se o quero trocar pelo um dos seus itens any\r\n\r\n      if (dragPath.indexOf(arrayPathHover.join(\".\") + \".\") > -1) {\r\n        props.handleFormOrder(\"anyItens\", isSectionDrag, isSectionHover, dragPath, hoverPath, dragOrder, hoverOrder, showLabelDrag, showLabelHover, isAnyDrag, isAnyHover);\r\n        return;\r\n      } else {\r\n        return;\r\n      }\r\n    } // Time to actually perform the action\r\n\r\n\r\n    props.handleFormOrder(\"general\", isSectionDrag, isSectionHover, dragPath, hoverPath, dragOrder, hoverOrder, showLabelDrag, showLabelHover, isAnyDrag, isAnyHover);\r\n  },\r\n\r\n  canDrop(props, monitor) {\r\n    const dragPath = monitor.getItem().path;\r\n    const hoverPath = props.path;\r\n    const dragGroupID = monitor.getItem().groupID;\r\n    const hoverGroupID = props.groupID;\r\n    const showLabelDrag = monitor.getItem().showLabel;\r\n    const showLabelHover = props.showLabel;\r\n    const isRMComponent = monitor.getItem().isRM; // se o componente a arrastar for do tipo RM, é preciso ir buscar o path da secção para a qual se está a arrastar o componente\r\n    // e compará-lo com o path do rmJDT\r\n\r\n    if (isRMComponent) {\r\n      const dragPathRM = monitor.getItem().pathRM !== undefined ? monitor.getItem().pathRM : monitor.getItem().data.parentPath; // obter o tamanho do itemPath do componente RM (path pai - path da secção à qual o RM pertence)\r\n\r\n      let itemPathLength = dragPathRM !== undefined ? dragPathRM.length : monitor.getItem().data.parentPath.length; // obter o itemPath da secção para a qual o componente está a ser arrastado, extraíndo apenas a parte correspondente ao tamanho do itemPath\r\n\r\n      let dropSectionPath = hoverPath.indexOf(\"rm\") > -1 ? props.item.parentPath : hoverPath.substring(0, itemPathLength); // se forem items do RM correspondentes à secção principal i.e. quando o dragPathRM é \"root\"\r\n      // estes apenas podem ser arrastados ao nível das outras subsecções que têm sempre o groupID=2\r\n\r\n      if (dragPathRM === \"root\" && hoverGroupID === 2) {\r\n        return true;\r\n      } // se o path pai do componente RM for igual ao path da secção pai para a qual o componente está a ser arrastado,\r\n      // significa que estão na mesma secção\r\n      else if (dropSectionPath === dragPathRM) {\r\n          return true;\r\n        } // caso contrário, não podem ser arrastados\r\n        else {\r\n            return false;\r\n          }\r\n    } // Don't replace items with themselves\r\n\r\n\r\n    if (dragPath === hoverPath) {\r\n      return false;\r\n    } // Don't replace items with different groupIDs\r\n\r\n\r\n    if (dragGroupID !== hoverGroupID) {\r\n      return false;\r\n    } // Don't move an item of an Any field if it is not the first item\r\n\r\n\r\n    if (showLabelDrag === false) {\r\n      const arrayPathDrag = dragPath.split(\".\");\r\n      arrayPathDrag.pop();\r\n\r\n      if (hoverPath.indexOf(arrayPathDrag.join(\".\") + \".\") > -1) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } // Don't drop your field if it is not the first item of an Any field\r\n\r\n\r\n    if (showLabelHover === false) {\r\n      const arrayPathHover = hoverPath.split(\".\");\r\n      arrayPathHover.pop();\r\n\r\n      if (dragPath.indexOf(arrayPathHover.join(\".\") + \".\") > -1) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n};\r\nexport { fieldTarget };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}