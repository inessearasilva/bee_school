{"ast":null,"code":"import _objectSpread from \"C:/Users/ines_/fisiosys/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { orderObjectByValue } from \"../Order/orderObjectByValue\"; // Tendo em conta que temos: items únicos, items Any (mesmo field com mais do que um datatype) e sections (tem vários items)\n\nvar handleOrder = function handleOrder(isSection, isSectionHover, dragPath, hoverPath, dragOrder, hoverOrder, showLabelDrag, showLabelHover, isAnyDrag, isAnyHover, formOrder) {\n  var immutableObj = orderObjectByValue(formOrder); // To guarantee the paths are by ascendent order while doing forEach\n\n  var objOrder = _objectSpread({}, immutableObj);\n  if (isSection) {\n    // Drag is a section\n    if (isSectionHover) {\n      // Drag and drop are both sections\n      var countSubItemsHover = 0;\n      var countSubItemsDrag = 0;\n      Object.keys(immutableObj).forEach(function (path) {\n        if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\n          countSubItemsDrag += 1;\n        } else if (path.indexOf(hoverPath + \".\") > -1 && path !== hoverPath) {\n          countSubItemsHover += 1;\n        }\n      });\n      if (dragOrder > hoverOrder) {\n        // Move up section\n        objOrder[dragPath] = hoverOrder;\n        var i = 0;\n        var j = 0;\n        var k = 0;\n        Object.keys(immutableObj).forEach(function (path) {\n          // Items are subitems of the drag section\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItemsDrag) {\n            i += 1;\n            objOrder[path] = hoverOrder + i;\n          } // Items are subitems of the hover section \n          else if (immutableObj[path] >= hoverOrder && immutableObj[path] <= hoverOrder + countSubItemsHover) {\n            j += 1;\n            objOrder[path] = hoverOrder + countSubItemsDrag + j;\n          } // Items are not subitems of either sections\n          else if (immutableObj[path] > hoverOrder + countSubItemsHover && immutableObj[path] < dragOrder) {\n            k += 1;\n            objOrder[path] = hoverOrder + countSubItemsDrag + 1 + countSubItemsHover + k;\n          }\n        });\n      } else if (dragOrder < hoverOrder) {\n        // Move down section\n        var newDragOrder = countSubItemsHover + hoverOrder - countSubItemsDrag;\n        objOrder[dragPath] = newDragOrder;\n        var _i = 0;\n        var _j = 0;\n        var _k = 0;\n        Object.keys(immutableObj).forEach(function (path) {\n          // Items are subitems of the drag section\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItemsDrag) {\n            _i += 1;\n            objOrder[path] = newDragOrder + _i;\n          } // Items are subitems of the hover section \n          else if (immutableObj[path] >= hoverOrder && immutableObj[path] <= hoverOrder + countSubItemsHover) {\n            _j += 1; // dragOrder - 1 + ((hoverOrder - (dragOrder + countSubItemsDrag)) - 1) + j \n\n            objOrder[path] = hoverOrder - countSubItemsDrag - 2 + _j;\n          } // Items are not subitems of either sections\n          else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder + countSubItemsDrag) {\n            _k += 1;\n            objOrder[path] = dragOrder - 1 + _k;\n          }\n        });\n      }\n    } else if (!isSectionHover && isAnyHover === false) {\n      // Drag is a section and drop is a item \n      var countSubItems = 0;\n      Object.keys(immutableObj).forEach(function (path) {\n        if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\n          countSubItems += 1;\n        }\n      });\n      if (dragOrder > hoverOrder) {\n        // Move up section\n        objOrder[dragPath] = hoverOrder;\n        var _i2 = 0;\n        Object.keys(immutableObj).forEach(function (path) {\n          // Items are not subitems of the section\n          if (immutableObj[path] < dragOrder && immutableObj[path] >= hoverOrder) {\n            objOrder[path] = immutableObj[path] + (countSubItems + 1);\n          } // Items are subitems of the section\n          else if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItems) {\n            _i2 += 1;\n            objOrder[path] = hoverOrder + _i2;\n          }\n        });\n      } else if (dragOrder < hoverOrder) {\n        // Move down section\n        var _newDragOrder = hoverOrder - countSubItems;\n        objOrder[dragPath] = _newDragOrder;\n        var _i3 = 0;\n        Object.keys(immutableObj).forEach(function (path) {\n          // Items are not subitems of the section\n          if (immutableObj[path] > dragOrder + countSubItems && immutableObj[path] <= hoverOrder) {\n            objOrder[path] = immutableObj[path] - (countSubItems + 1);\n          } // Items are subitems of the section\n          else if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItems) {\n            _i3 += 1;\n            objOrder[path] = _newDragOrder + _i3;\n          }\n        });\n      }\n    } else if (isAnyHover === true && showLabelHover === true) {\n      // Drag is a section and drop is an Any item\n      if (dragOrder > hoverOrder) {\n        // Move up section\n        var _countSubItemsDrag = 0; // Doesn't include the title\n\n        Object.keys(immutableObj).forEach(function (path) {\n          if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\n            _countSubItemsDrag += 1;\n          }\n        });\n        objOrder[dragPath] = hoverOrder;\n        var _i4 = 0;\n        Object.keys(immutableObj).forEach(function (path) {\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + _countSubItemsDrag) {\n            _i4 += 1;\n            objOrder[path] = hoverOrder + _i4;\n          } else if (immutableObj[path] < dragOrder && immutableObj[path] >= hoverOrder) {\n            objOrder[path] = immutableObj[path] + (_countSubItemsDrag + 1);\n          }\n        });\n      } else if (dragOrder < hoverOrder) {\n        // Move down section\n        var _countSubItemsDrag2 = 0; // Doesn't include the title\n\n        var anyItemsHover = []; // Includes the first item\n\n        var countAnyItemsHover = 0; // Includes the first item\n\n        Object.keys(immutableObj).forEach(function (path) {\n          var query = hoverPath.split('.');\n          query.pop();\n          if (path.indexOf(query.join('.') + \".\") > -1) {\n            anyItemsHover.push(path);\n            countAnyItemsHover += 1;\n          }\n          if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\n            _countSubItemsDrag2 += 1;\n          }\n        });\n        var _newDragOrder2 = hoverOrder - _countSubItemsDrag2 + countAnyItemsHover - 1;\n        objOrder[dragPath] = _newDragOrder2;\n        var _i5 = 0;\n        var _j2 = 0;\n        var _k2 = 0;\n        Object.keys(immutableObj).forEach(function (path) {\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + _countSubItemsDrag2) {\n            _i5 += 1;\n            objOrder[path] = _newDragOrder2 + _i5;\n          } else if (anyItemsHover.indexOf(path) > -1) {\n            _j2 += 1;\n            objOrder[path] = hoverOrder - _countSubItemsDrag2 - 2 + _j2;\n          } else if (immutableObj[path] > dragOrder + _countSubItemsDrag2 && immutableObj[path] < hoverOrder) {\n            _k2 += 1;\n            objOrder[path] = dragOrder - 1 + _k2;\n          }\n        });\n      }\n    }\n  } else if (!isSection) {\n    // Drag is not a section\n    // It means the client is dragging a RM component\n    // Falta considerar e testar com items Any\n    // Falta considerar o caso em que o Drop é uma secção\n    if (dragOrder === undefined) {\n      objOrder[dragPath] = hoverOrder;\n      Object.keys(immutableObj).forEach(function (path) {\n        if (immutableObj[path] >= hoverOrder) {\n          objOrder[path] = immutableObj[path] + 1; //move item up\n        }\n      });\n    } // Move up item\n    else if (dragOrder > hoverOrder) {\n      if (isAnyDrag === true && showLabelDrag === true) {\n        // Drag is an Any item => Drop can be anything\n        var anyItems = []; // Doesn't include first item\n\n        var countAnyItems = 0; // Doesn't include first item\n        // verificar se há um anyItem\n\n        Object.keys(immutableObj).forEach(function (path) {\n          var query = dragPath.split('.');\n          query.pop(); // comparar se no order existe algum path que contenha o caminho anterior - significa que é um anyItem\n\n          if (path.indexOf(query.join('.') + \".\") > -1 && path !== dragPath) {\n            anyItems.push(path);\n            countAnyItems += 1;\n          }\n        });\n        objOrder[dragPath] = hoverOrder;\n        var _i6 = 0;\n        Object.keys(immutableObj).forEach(function (path) {\n          // se for o AnyItem, o valor do order - objOrder - fica o hoverOrder + o nº de anyItems encontrados até àquele path\n          if (anyItems.indexOf(path) > -1) {\n            _i6 += 1;\n            objOrder[path] = hoverOrder + _i6;\n          } // se não for AnyItem, o valor do order - objOrder - fica o valor que tinha + o nº de anyItems + 1\n          else if (immutableObj[path] >= hoverOrder && immutableObj[path] < dragOrder) {\n            objOrder[path] = immutableObj[path] + countAnyItems + 1;\n          }\n        });\n      } else {\n        // Drag is a normal item (not Any item) => Drop can be anything\n        objOrder[dragPath] = hoverOrder;\n        Object.keys(immutableObj).forEach(function (path) {\n          if (immutableObj[path] >= hoverOrder && immutableObj[path] < dragOrder) {\n            objOrder[path] = immutableObj[path] + 1;\n          }\n        });\n      }\n    } // Move down item\n    else if (dragOrder < hoverOrder) {\n      if (isAnyDrag === true && showLabelDrag === true) {\n        // Drag is an Any item\n        if (!isSectionHover && isAnyHover === true && showLabelHover === true) {\n          // Drop is an Any item\n          var anyItemsDrag = []; // Doesn't include the first item\n\n          var countAnyItemsDrag = 0; // Doesn't include the first item\n\n          var _anyItemsHover = []; // Includes the first item\n\n          var _countAnyItemsHover = 0; // Includes the first item\n\n          Object.keys(immutableObj).forEach(function (path) {\n            var queryDrag = dragPath.split('.');\n            queryDrag.pop();\n            var queryHover = hoverPath.split('.');\n            queryHover.pop();\n            if (path.indexOf(queryDrag.join('.') + \".\") > -1 && path !== dragPath) {\n              anyItemsDrag.push(path);\n              countAnyItemsDrag += 1;\n            }\n            if (path.indexOf(queryHover.join('.') + \".\") > -1) {\n              _anyItemsHover.push(path);\n              _countAnyItemsHover += 1;\n            }\n          });\n          var _newDragOrder3 = _countAnyItemsHover + hoverOrder - countAnyItemsDrag - 1;\n          objOrder[dragPath] = _newDragOrder3;\n          var _i7 = 0;\n          var _j3 = 0;\n          var _k3 = 0;\n          Object.keys(immutableObj).forEach(function (path) {\n            if (anyItemsDrag.indexOf(path) > -1) {\n              _i7 += 1;\n              objOrder[path] = _newDragOrder3 + _i7;\n            } else if (_anyItemsHover.indexOf(path) > -1) {\n              _j3 += 1;\n              objOrder[path] = hoverOrder - countAnyItemsDrag - 2 + _j3;\n            } else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder + countAnyItemsDrag) {\n              _k3 += 1;\n              objOrder[path] = dragOrder - 1 + _k3;\n            }\n          });\n        } else if (isSectionHover) {\n          // Drop is a section\n          var _anyItemsDrag = []; // Doesn't include first item\n\n          var _countAnyItemsDrag = 0; // Doesn't include first item\n\n          var subItemsHover = []; // Doesn't include section title\n\n          var _countSubItemsHover = 0; // Doesn't include section title\n\n          Object.keys(immutableObj).forEach(function (path) {\n            var queryDrag = dragPath.split('.');\n            queryDrag.pop();\n            if (path.indexOf(queryDrag.join('.') + \".\") > -1 && path !== dragPath) {\n              _anyItemsDrag.push(path);\n              _countAnyItemsDrag += 1;\n            }\n            if (path.indexOf(hoverPath + \".\") > -1 && path !== hoverPath) {\n              subItemsHover.push(path);\n              _countSubItemsHover += 1;\n            }\n          });\n          var _newDragOrder4 = _countSubItemsHover + 1 + hoverOrder - _countAnyItemsDrag - 1;\n          objOrder[dragPath] = _newDragOrder4;\n          var _i8 = 0;\n          var _j4 = 0;\n          var _k4 = 0;\n          Object.keys(immutableObj).forEach(function (path) {\n            if (_anyItemsDrag.indexOf(path) > -1) {\n              _i8 += 1;\n              objOrder[path] = _newDragOrder4 + _i8;\n            } else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder + _countAnyItemsDrag) {\n              _k4 += 1;\n              objOrder[path] = dragOrder - 1 + _k4;\n            } else if (immutableObj[path] >= hoverOrder && immutableObj[path] <= hoverOrder + _countSubItemsHover) {\n              _j4 += 1;\n              objOrder[path] = hoverOrder - _countAnyItemsDrag - 2 + _j4;\n            }\n          });\n        } else if (!isSectionHover && isAnyHover === false) {\n          // Drop is not a section => normal item\n          var _anyItems = [];\n          var _countAnyItems = 0;\n          Object.keys(immutableObj).forEach(function (path) {\n            var query = dragPath.split('.');\n            query.pop();\n            if (path.indexOf(query.join('.') + \".\") > -1 && path !== dragPath) {\n              _anyItems.push(path);\n              _countAnyItems += 1;\n            }\n          });\n          var _newDragOrder5 = hoverOrder - _countAnyItems;\n          objOrder[dragPath] = _newDragOrder5;\n          var _i9 = 0;\n          var _j5 = 0;\n          Object.keys(immutableObj).forEach(function (path) {\n            if (_anyItems.indexOf(path) > -1) {\n              _i9 += 1;\n              objOrder[path] = _newDragOrder5 + _i9;\n            } else if (immutableObj[path] <= hoverOrder && immutableObj[path] > dragOrder + _countAnyItems) {\n              _j5 += 1;\n              objOrder[path] = dragOrder + _j5 - 1;\n            }\n          });\n        }\n      } else {\n        // Drag is a normal item (not Any item or a section)\n        if (!isSectionHover && isAnyHover === true && showLabelHover === true) {\n          // Drop is an Any item\n          var _anyItemsHover2 = []; // Includes the first item\n\n          var _countAnyItemsHover2 = 0; // Includes the first item\n\n          Object.keys(immutableObj).forEach(function (path) {\n            var query = hoverPath.split('.');\n            query.pop();\n            if (path.indexOf(query.join('.') + \".\") > -1) {\n              _anyItemsHover2.push(path);\n              _countAnyItemsHover2 += 1;\n            }\n          });\n          var _newDragOrder6 = _countAnyItemsHover2 + hoverOrder - 1;\n          objOrder[dragPath] = _newDragOrder6;\n          var _i10 = 0;\n          var _j6 = 0;\n          Object.keys(immutableObj).forEach(function (path) {\n            if (immutableObj[path] > dragOrder && immutableObj[path] < hoverOrder) {\n              _i10 += 1;\n              objOrder[path] = dragOrder - 1 + _i10;\n            } else if (_anyItemsHover2.indexOf(path) > -1) {\n              _j6 += 1;\n              objOrder[path] = hoverOrder - 2 + _j6;\n            }\n          });\n        } else if (!isSectionHover && isAnyHover === false) {\n          // Drop is not a section => is a normal item\n          objOrder[dragPath] = hoverOrder;\n          Object.keys(immutableObj).forEach(function (path) {\n            if (immutableObj[path] <= hoverOrder && immutableObj[path] > dragOrder) {\n              objOrder[path] = immutableObj[path] - 1;\n            }\n          });\n        } else if (isSectionHover) {\n          // Drop is a section\n          var _subItemsHover = []; // Doesn't include the section title\n\n          var _countSubItemsHover2 = 0; // Doesn't include the section title\n          // ir buscar todos os subItems da secção onde está a ser feito o drop\n\n          Object.keys(immutableObj).forEach(function (path) {\n            if (path.indexOf(hoverPath + \".\") > -1 && path !== hoverPath) {\n              _subItemsHover.push(path);\n              _countSubItemsHover2 += 1;\n            }\n          });\n          var _newDragOrder7 = _countSubItemsHover2 + hoverOrder;\n          objOrder[dragPath] = _newDragOrder7;\n          var _i11 = 0;\n          var _j7 = 0;\n          Object.keys(immutableObj).forEach(function (path) {\n            if (_subItemsHover.indexOf(path) > -1) {\n              _i11 += 1;\n              objOrder[path] = hoverOrder - 2 + _i11;\n            } else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder) {\n              _j7 += 1;\n              objOrder[path] = dragOrder - 1 + _j7;\n            }\n          });\n        }\n      }\n    }\n  }\n  return objOrder;\n};\nexport { handleOrder };","map":{"version":3,"names":["orderObjectByValue","handleOrder","isSection","isSectionHover","dragPath","hoverPath","dragOrder","hoverOrder","showLabelDrag","showLabelHover","isAnyDrag","isAnyHover","formOrder","immutableObj","objOrder","countSubItemsHover","countSubItemsDrag","Object","keys","forEach","path","indexOf","i","j","k","newDragOrder","countSubItems","anyItemsHover","countAnyItemsHover","query","split","pop","join","push","undefined","anyItems","countAnyItems","anyItemsDrag","countAnyItemsDrag","queryDrag","queryHover","subItemsHover"],"sources":["C:/Users/ines_/fisiosys/frontend/node_modules/protected-aidaforms/dist/assets/functions/HandleOrder/HandleOrder.js"],"sourcesContent":["import { orderObjectByValue } from \"../Order/orderObjectByValue\"; // Tendo em conta que temos: items únicos, items Any (mesmo field com mais do que um datatype) e sections (tem vários items)\r\n\r\nconst handleOrder = (isSection, isSectionHover, dragPath, hoverPath, dragOrder, hoverOrder, showLabelDrag, showLabelHover, isAnyDrag, isAnyHover, formOrder) => {\r\n  const immutableObj = orderObjectByValue(formOrder); // To guarantee the paths are by ascendent order while doing forEach\r\n\r\n  let objOrder = { ...immutableObj\r\n  };\r\n\r\n  if (isSection) {\r\n    // Drag is a section\r\n    if (isSectionHover) {\r\n      // Drag and drop are both sections\r\n      let countSubItemsHover = 0;\r\n      let countSubItemsDrag = 0;\r\n      Object.keys(immutableObj).forEach(path => {\r\n        if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\r\n          countSubItemsDrag += 1;\r\n        } else if (path.indexOf(hoverPath + \".\") > -1 && path !== hoverPath) {\r\n          countSubItemsHover += 1;\r\n        }\r\n      });\r\n\r\n      if (dragOrder > hoverOrder) {\r\n        // Move up section\r\n        objOrder[dragPath] = hoverOrder;\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = 0;\r\n        Object.keys(immutableObj).forEach(path => {\r\n          // Items are subitems of the drag section\r\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItemsDrag) {\r\n            i += 1;\r\n            objOrder[path] = hoverOrder + i;\r\n          } // Items are subitems of the hover section \r\n          else if (immutableObj[path] >= hoverOrder && immutableObj[path] <= hoverOrder + countSubItemsHover) {\r\n              j += 1;\r\n              objOrder[path] = hoverOrder + countSubItemsDrag + j;\r\n            } // Items are not subitems of either sections\r\n            else if (immutableObj[path] > hoverOrder + countSubItemsHover && immutableObj[path] < dragOrder) {\r\n                k += 1;\r\n                objOrder[path] = hoverOrder + countSubItemsDrag + 1 + countSubItemsHover + k;\r\n              }\r\n        });\r\n      } else if (dragOrder < hoverOrder) {\r\n        // Move down section\r\n        let newDragOrder = countSubItemsHover + hoverOrder - countSubItemsDrag;\r\n        objOrder[dragPath] = newDragOrder;\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = 0;\r\n        Object.keys(immutableObj).forEach(path => {\r\n          // Items are subitems of the drag section\r\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItemsDrag) {\r\n            i += 1;\r\n            objOrder[path] = newDragOrder + i;\r\n          } // Items are subitems of the hover section \r\n          else if (immutableObj[path] >= hoverOrder && immutableObj[path] <= hoverOrder + countSubItemsHover) {\r\n              j += 1; // dragOrder - 1 + ((hoverOrder - (dragOrder + countSubItemsDrag)) - 1) + j \r\n\r\n              objOrder[path] = hoverOrder - countSubItemsDrag - 2 + j;\r\n            } // Items are not subitems of either sections\r\n            else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder + countSubItemsDrag) {\r\n                k += 1;\r\n                objOrder[path] = dragOrder - 1 + k;\r\n              }\r\n        });\r\n      }\r\n    } else if (!isSectionHover && isAnyHover === false) {\r\n      // Drag is a section and drop is a item \r\n      let countSubItems = 0;\r\n      Object.keys(immutableObj).forEach(path => {\r\n        if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\r\n          countSubItems += 1;\r\n        }\r\n      });\r\n\r\n      if (dragOrder > hoverOrder) {\r\n        // Move up section\r\n        objOrder[dragPath] = hoverOrder;\r\n        let i = 0;\r\n        Object.keys(immutableObj).forEach(path => {\r\n          // Items are not subitems of the section\r\n          if (immutableObj[path] < dragOrder && immutableObj[path] >= hoverOrder) {\r\n            objOrder[path] = immutableObj[path] + (countSubItems + 1);\r\n          } // Items are subitems of the section\r\n          else if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItems) {\r\n              i += 1;\r\n              objOrder[path] = hoverOrder + i;\r\n            }\r\n        });\r\n      } else if (dragOrder < hoverOrder) {\r\n        // Move down section\r\n        let newDragOrder = hoverOrder - countSubItems;\r\n        objOrder[dragPath] = newDragOrder;\r\n        let i = 0;\r\n        Object.keys(immutableObj).forEach(path => {\r\n          // Items are not subitems of the section\r\n          if (immutableObj[path] > dragOrder + countSubItems && immutableObj[path] <= hoverOrder) {\r\n            objOrder[path] = immutableObj[path] - (countSubItems + 1);\r\n          } // Items are subitems of the section\r\n          else if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItems) {\r\n              i += 1;\r\n              objOrder[path] = newDragOrder + i;\r\n            }\r\n        });\r\n      }\r\n    } else if (isAnyHover === true && showLabelHover === true) {\r\n      // Drag is a section and drop is an Any item\r\n      if (dragOrder > hoverOrder) {\r\n        // Move up section\r\n        let countSubItemsDrag = 0; // Doesn't include the title\r\n\r\n        Object.keys(immutableObj).forEach(path => {\r\n          if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\r\n            countSubItemsDrag += 1;\r\n          }\r\n        });\r\n        objOrder[dragPath] = hoverOrder;\r\n        let i = 0;\r\n        Object.keys(immutableObj).forEach(path => {\r\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItemsDrag) {\r\n            i += 1;\r\n            objOrder[path] = hoverOrder + i;\r\n          } else if (immutableObj[path] < dragOrder && immutableObj[path] >= hoverOrder) {\r\n            objOrder[path] = immutableObj[path] + (countSubItemsDrag + 1);\r\n          }\r\n        });\r\n      } else if (dragOrder < hoverOrder) {\r\n        // Move down section\r\n        let countSubItemsDrag = 0; // Doesn't include the title\r\n\r\n        let anyItemsHover = []; // Includes the first item\r\n\r\n        let countAnyItemsHover = 0; // Includes the first item\r\n\r\n        Object.keys(immutableObj).forEach(path => {\r\n          let query = hoverPath.split('.');\r\n          query.pop();\r\n\r\n          if (path.indexOf(query.join('.') + \".\") > -1) {\r\n            anyItemsHover.push(path);\r\n            countAnyItemsHover += 1;\r\n          }\r\n\r\n          if (path.indexOf(dragPath + \".\") > -1 && path !== dragPath) {\r\n            countSubItemsDrag += 1;\r\n          }\r\n        });\r\n        let newDragOrder = hoverOrder - countSubItemsDrag + countAnyItemsHover - 1;\r\n        objOrder[dragPath] = newDragOrder;\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = 0;\r\n        Object.keys(immutableObj).forEach(path => {\r\n          if (immutableObj[path] > dragOrder && immutableObj[path] <= dragOrder + countSubItemsDrag) {\r\n            i += 1;\r\n            objOrder[path] = newDragOrder + i;\r\n          } else if (anyItemsHover.indexOf(path) > -1) {\r\n            j += 1;\r\n            objOrder[path] = hoverOrder - countSubItemsDrag - 2 + j;\r\n          } else if (immutableObj[path] > dragOrder + countSubItemsDrag && immutableObj[path] < hoverOrder) {\r\n            k += 1;\r\n            objOrder[path] = dragOrder - 1 + k;\r\n          }\r\n        });\r\n      }\r\n    }\r\n  } else if (!isSection) {\r\n    // Drag is not a section\r\n    // It means the client is dragging a RM component\r\n    // Falta considerar e testar com items Any\r\n    // Falta considerar o caso em que o Drop é uma secção\r\n    if (dragOrder === undefined) {\r\n      objOrder[dragPath] = hoverOrder;\r\n      Object.keys(immutableObj).forEach(path => {\r\n        if (immutableObj[path] >= hoverOrder) {\r\n          objOrder[path] = immutableObj[path] + 1; //move item up\r\n        }\r\n      });\r\n    } // Move up item\r\n    else if (dragOrder > hoverOrder) {\r\n        if (isAnyDrag === true && showLabelDrag === true) {\r\n          // Drag is an Any item => Drop can be anything\r\n          let anyItems = []; // Doesn't include first item\r\n\r\n          let countAnyItems = 0; // Doesn't include first item\r\n          // verificar se há um anyItem\r\n\r\n          Object.keys(immutableObj).forEach(path => {\r\n            let query = dragPath.split('.');\r\n            query.pop(); // comparar se no order existe algum path que contenha o caminho anterior - significa que é um anyItem\r\n\r\n            if (path.indexOf(query.join('.') + \".\") > -1 && path !== dragPath) {\r\n              anyItems.push(path);\r\n              countAnyItems += 1;\r\n            }\r\n          });\r\n          objOrder[dragPath] = hoverOrder;\r\n          let i = 0;\r\n          Object.keys(immutableObj).forEach(path => {\r\n            // se for o AnyItem, o valor do order - objOrder - fica o hoverOrder + o nº de anyItems encontrados até àquele path\r\n            if (anyItems.indexOf(path) > -1) {\r\n              i += 1;\r\n              objOrder[path] = hoverOrder + i;\r\n            } // se não for AnyItem, o valor do order - objOrder - fica o valor que tinha + o nº de anyItems + 1\r\n            else if (immutableObj[path] >= hoverOrder && immutableObj[path] < dragOrder) {\r\n                objOrder[path] = immutableObj[path] + countAnyItems + 1;\r\n              }\r\n          });\r\n        } else {\r\n          // Drag is a normal item (not Any item) => Drop can be anything\r\n          objOrder[dragPath] = hoverOrder;\r\n          Object.keys(immutableObj).forEach(path => {\r\n            if (immutableObj[path] >= hoverOrder && immutableObj[path] < dragOrder) {\r\n              objOrder[path] = immutableObj[path] + 1;\r\n            }\r\n          });\r\n        }\r\n      } // Move down item\r\n      else if (dragOrder < hoverOrder) {\r\n          if (isAnyDrag === true && showLabelDrag === true) {\r\n            // Drag is an Any item\r\n            if (!isSectionHover && isAnyHover === true && showLabelHover === true) {\r\n              // Drop is an Any item\r\n              let anyItemsDrag = []; // Doesn't include the first item\r\n\r\n              let countAnyItemsDrag = 0; // Doesn't include the first item\r\n\r\n              let anyItemsHover = []; // Includes the first item\r\n\r\n              let countAnyItemsHover = 0; // Includes the first item\r\n\r\n              Object.keys(immutableObj).forEach(path => {\r\n                let queryDrag = dragPath.split('.');\r\n                queryDrag.pop();\r\n                let queryHover = hoverPath.split('.');\r\n                queryHover.pop();\r\n\r\n                if (path.indexOf(queryDrag.join('.') + \".\") > -1 && path !== dragPath) {\r\n                  anyItemsDrag.push(path);\r\n                  countAnyItemsDrag += 1;\r\n                }\r\n\r\n                if (path.indexOf(queryHover.join('.') + \".\") > -1) {\r\n                  anyItemsHover.push(path);\r\n                  countAnyItemsHover += 1;\r\n                }\r\n              });\r\n              let newDragOrder = countAnyItemsHover + hoverOrder - countAnyItemsDrag - 1;\r\n              objOrder[dragPath] = newDragOrder;\r\n              let i = 0;\r\n              let j = 0;\r\n              let k = 0;\r\n              Object.keys(immutableObj).forEach(path => {\r\n                if (anyItemsDrag.indexOf(path) > -1) {\r\n                  i += 1;\r\n                  objOrder[path] = newDragOrder + i;\r\n                } else if (anyItemsHover.indexOf(path) > -1) {\r\n                  j += 1;\r\n                  objOrder[path] = hoverOrder - countAnyItemsDrag - 2 + j;\r\n                } else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder + countAnyItemsDrag) {\r\n                  k += 1;\r\n                  objOrder[path] = dragOrder - 1 + k;\r\n                }\r\n              });\r\n            } else if (isSectionHover) {\r\n              // Drop is a section\r\n              let anyItemsDrag = []; // Doesn't include first item\r\n\r\n              let countAnyItemsDrag = 0; // Doesn't include first item\r\n\r\n              let subItemsHover = []; // Doesn't include section title\r\n\r\n              let countSubItemsHover = 0; // Doesn't include section title\r\n\r\n              Object.keys(immutableObj).forEach(path => {\r\n                let queryDrag = dragPath.split('.');\r\n                queryDrag.pop();\r\n\r\n                if (path.indexOf(queryDrag.join('.') + \".\") > -1 && path !== dragPath) {\r\n                  anyItemsDrag.push(path);\r\n                  countAnyItemsDrag += 1;\r\n                }\r\n\r\n                if (path.indexOf(hoverPath + \".\") > -1 && path !== hoverPath) {\r\n                  subItemsHover.push(path);\r\n                  countSubItemsHover += 1;\r\n                }\r\n              });\r\n              let newDragOrder = countSubItemsHover + 1 + hoverOrder - countAnyItemsDrag - 1;\r\n              objOrder[dragPath] = newDragOrder;\r\n              let i = 0;\r\n              let j = 0;\r\n              let k = 0;\r\n              Object.keys(immutableObj).forEach(path => {\r\n                if (anyItemsDrag.indexOf(path) > -1) {\r\n                  i += 1;\r\n                  objOrder[path] = newDragOrder + i;\r\n                } else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder + countAnyItemsDrag) {\r\n                  k += 1;\r\n                  objOrder[path] = dragOrder - 1 + k;\r\n                } else if (immutableObj[path] >= hoverOrder && immutableObj[path] <= hoverOrder + countSubItemsHover) {\r\n                  j += 1;\r\n                  objOrder[path] = hoverOrder - countAnyItemsDrag - 2 + j;\r\n                }\r\n              });\r\n            } else if (!isSectionHover && isAnyHover === false) {\r\n              // Drop is not a section => normal item\r\n              let anyItems = [];\r\n              let countAnyItems = 0;\r\n              Object.keys(immutableObj).forEach(path => {\r\n                let query = dragPath.split('.');\r\n                query.pop();\r\n\r\n                if (path.indexOf(query.join('.') + \".\") > -1 && path !== dragPath) {\r\n                  anyItems.push(path);\r\n                  countAnyItems += 1;\r\n                }\r\n              });\r\n              let newDragOrder = hoverOrder - countAnyItems;\r\n              objOrder[dragPath] = newDragOrder;\r\n              let i = 0;\r\n              let j = 0;\r\n              Object.keys(immutableObj).forEach(path => {\r\n                if (anyItems.indexOf(path) > -1) {\r\n                  i += 1;\r\n                  objOrder[path] = newDragOrder + i;\r\n                } else if (immutableObj[path] <= hoverOrder && immutableObj[path] > dragOrder + countAnyItems) {\r\n                  j += 1;\r\n                  objOrder[path] = dragOrder + j - 1;\r\n                }\r\n              });\r\n            }\r\n          } else {\r\n            // Drag is a normal item (not Any item or a section)\r\n            if (!isSectionHover && isAnyHover === true && showLabelHover === true) {\r\n              // Drop is an Any item\r\n              let anyItemsHover = []; // Includes the first item\r\n\r\n              let countAnyItemsHover = 0; // Includes the first item\r\n\r\n              Object.keys(immutableObj).forEach(path => {\r\n                let query = hoverPath.split('.');\r\n                query.pop();\r\n\r\n                if (path.indexOf(query.join('.') + \".\") > -1) {\r\n                  anyItemsHover.push(path);\r\n                  countAnyItemsHover += 1;\r\n                }\r\n              });\r\n              let newDragOrder = countAnyItemsHover + hoverOrder - 1;\r\n              objOrder[dragPath] = newDragOrder;\r\n              let i = 0;\r\n              let j = 0;\r\n              Object.keys(immutableObj).forEach(path => {\r\n                if (immutableObj[path] > dragOrder && immutableObj[path] < hoverOrder) {\r\n                  i += 1;\r\n                  objOrder[path] = dragOrder - 1 + i;\r\n                } else if (anyItemsHover.indexOf(path) > -1) {\r\n                  j += 1;\r\n                  objOrder[path] = hoverOrder - 2 + j;\r\n                }\r\n              });\r\n            } else if (!isSectionHover && isAnyHover === false) {\r\n              // Drop is not a section => is a normal item\r\n              objOrder[dragPath] = hoverOrder;\r\n              Object.keys(immutableObj).forEach(path => {\r\n                if (immutableObj[path] <= hoverOrder && immutableObj[path] > dragOrder) {\r\n                  objOrder[path] = immutableObj[path] - 1;\r\n                }\r\n              });\r\n            } else if (isSectionHover) {\r\n              // Drop is a section\r\n              let subItemsHover = []; // Doesn't include the section title\r\n\r\n              let countSubItemsHover = 0; // Doesn't include the section title\r\n              // ir buscar todos os subItems da secção onde está a ser feito o drop\r\n\r\n              Object.keys(immutableObj).forEach(path => {\r\n                if (path.indexOf(hoverPath + \".\") > -1 && path !== hoverPath) {\r\n                  subItemsHover.push(path);\r\n                  countSubItemsHover += 1;\r\n                }\r\n              });\r\n              let newDragOrder = countSubItemsHover + hoverOrder;\r\n              objOrder[dragPath] = newDragOrder;\r\n              let i = 0;\r\n              let j = 0;\r\n              Object.keys(immutableObj).forEach(path => {\r\n                if (subItemsHover.indexOf(path) > -1) {\r\n                  i += 1;\r\n                  objOrder[path] = hoverOrder - 2 + i;\r\n                } else if (immutableObj[path] < hoverOrder && immutableObj[path] > dragOrder) {\r\n                  j += 1;\r\n                  objOrder[path] = dragOrder - 1 + j;\r\n                }\r\n              });\r\n            }\r\n          }\r\n        }\r\n  }\r\n\r\n  return objOrder;\r\n};\r\n\r\nexport { handleOrder };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}