{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.optionSetup = exports.removeNestedUndefinedValues = exports.isThisANonHTMLUrl = exports.isImageTypeValid = exports.findImageTypeFromUrl = exports.validateAndFormatURL = exports.isUrlValid = exports.defaultUrlValidatorSettings = void 0;\nconst validator_1 = __importDefault(require(\"validator\"));\nexports.defaultUrlValidatorSettings = {\n  allow_fragments: true,\n  allow_protocol_relative_urls: false,\n  allow_query_components: true,\n  allow_trailing_dot: false,\n  allow_underscores: false,\n  protocols: ['http', 'https'],\n  require_host: true,\n  require_port: false,\n  require_protocol: false,\n  require_tld: true,\n  require_valid_protocol: true,\n  validate_length: true\n};\n/**\n * Checks if URL is valid\n *\n * @param {string} url - url to be checked\n * @param {string} urlValidatorSettings - settings used by validator\n * @return {boolean} boolean value if the url is valid\n *\n */\nfunction isUrlValid(url, urlValidatorSettings) {\n  return typeof url === 'string' && url.length > 0 && validator_1.default.isURL(url, urlValidatorSettings);\n}\nexports.isUrlValid = isUrlValid;\n/**\n * Forces url to start with http:// if it doesn't\n *\n * @param {string} url - url to be updated\n * @return {string} url that starts with http\n *\n */\nconst coerceUrl = url => /^(f|ht)tps?:\\/\\//i.test(url) ? url : `http://${url}`;\n/**\n * Validates and formats url\n *\n * @param {string} url - url to be checked and formatted\n * @param {string} urlValidatorSettings - settings used by validator\n * @return {string} proper url or null\n *\n */\nfunction validateAndFormatURL(url, urlValidatorSettings) {\n  return {\n    url: isUrlValid(url, urlValidatorSettings) ? coerceUrl(url) : null\n  };\n}\nexports.validateAndFormatURL = validateAndFormatURL;\n/**\n * Finds the image type from a given url\n *\n * @param {string} url - url to be checked\n * @return {string} image type from url\n *\n */\nfunction findImageTypeFromUrl(url) {\n  let type = url.split('.').pop() || '';\n  [type] = type.split('?');\n  return type;\n}\nexports.findImageTypeFromUrl = findImageTypeFromUrl;\n/**\n * Checks if image type is valid\n *\n * @param {string} type - type to be checked\n * @return {boolean} boolean value if type is value\n *\n */\nfunction isImageTypeValid(type) {\n  const validImageTypes = ['apng', 'bmp', 'gif', 'ico', 'cur', 'jpg', 'jpeg', 'jfif', 'pjpeg', 'pjp', 'png', 'svg', 'tif', 'tiff', 'webp'];\n  return validImageTypes.includes(type);\n}\nexports.isImageTypeValid = isImageTypeValid;\n/**\n * Checks if URL is a non html page\n *\n * @param {string} url - url to be checked\n * @return {boolean} boolean value if url is non html\n *\n */\nfunction isThisANonHTMLUrl(url) {\n  const invalidImageTypes = ['.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.3gp', '.avi', '.mov', '.mp4', '.m4v', '.m4a', '.mp3', '.mkv', '.ogv', '.ogm', '.ogg', '.oga', '.webm', '.wav', '.bmp', '.gif', '.jpg', '.jpeg', '.png', '.webp', '.zip', '.rar', '.tar', '.tar.gz', '.tgz', '.tar.bz2', '.tbz2', '.txt', '.pdf'];\n  const extension = findImageTypeFromUrl(url);\n  return invalidImageTypes.some(type => `.${extension}`.includes(type));\n}\nexports.isThisANonHTMLUrl = isThisANonHTMLUrl;\n/**\n * Find and delete nested undefs\n *\n * @param {object} object - object to be cleaned\n * @return {object} object without nested undefs\n *\n */\nfunction removeNestedUndefinedValues(object) {\n  Object.entries(object).forEach(_ref => {\n    let [key, value] = _ref;\n    if (value && typeof value === 'object') removeNestedUndefinedValues(value);else if (value === undefined) delete object[key];\n  });\n  return object;\n}\nexports.removeNestedUndefinedValues = removeNestedUndefinedValues;\n/**\n * Split the options object into ogs and got option objects\n *\n * @param {object} options - options that need to be split\n * @return {object} object with nested options for ogs and got\n *\n */\nfunction optionSetup(ogsOptions) {\n  const options = {\n    onlyGetOpenGraphInfo: false,\n    ...ogsOptions\n  };\n  return {\n    options\n  };\n}\nexports.optionSetup = optionSetup;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","optionSetup","removeNestedUndefinedValues","isThisANonHTMLUrl","isImageTypeValid","findImageTypeFromUrl","validateAndFormatURL","isUrlValid","defaultUrlValidatorSettings","validator_1","require","allow_fragments","allow_protocol_relative_urls","allow_query_components","allow_trailing_dot","allow_underscores","protocols","require_host","require_port","require_protocol","require_tld","require_valid_protocol","validate_length","url","urlValidatorSettings","length","default","isURL","coerceUrl","test","type","split","pop","validImageTypes","includes","invalidImageTypes","extension","some","object","entries","forEach","key","undefined","ogsOptions","options","onlyGetOpenGraphInfo"],"sources":["C:/Users/ines_/bee_v2/bee_school/frontend/node_modules/open-graph-scraper/dist/lib/utils.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.optionSetup = exports.removeNestedUndefinedValues = exports.isThisANonHTMLUrl = exports.isImageTypeValid = exports.findImageTypeFromUrl = exports.validateAndFormatURL = exports.isUrlValid = exports.defaultUrlValidatorSettings = void 0;\nconst validator_1 = __importDefault(require(\"validator\"));\nexports.defaultUrlValidatorSettings = {\n    allow_fragments: true,\n    allow_protocol_relative_urls: false,\n    allow_query_components: true,\n    allow_trailing_dot: false,\n    allow_underscores: false,\n    protocols: ['http', 'https'],\n    require_host: true,\n    require_port: false,\n    require_protocol: false,\n    require_tld: true,\n    require_valid_protocol: true,\n    validate_length: true,\n};\n/**\n * Checks if URL is valid\n *\n * @param {string} url - url to be checked\n * @param {string} urlValidatorSettings - settings used by validator\n * @return {boolean} boolean value if the url is valid\n *\n */\nfunction isUrlValid(url, urlValidatorSettings) {\n    return typeof url === 'string' && url.length > 0 && validator_1.default.isURL(url, urlValidatorSettings);\n}\nexports.isUrlValid = isUrlValid;\n/**\n * Forces url to start with http:// if it doesn't\n *\n * @param {string} url - url to be updated\n * @return {string} url that starts with http\n *\n */\nconst coerceUrl = (url) => (/^(f|ht)tps?:\\/\\//i.test(url) ? url : `http://${url}`);\n/**\n * Validates and formats url\n *\n * @param {string} url - url to be checked and formatted\n * @param {string} urlValidatorSettings - settings used by validator\n * @return {string} proper url or null\n *\n */\nfunction validateAndFormatURL(url, urlValidatorSettings) {\n    return { url: isUrlValid(url, urlValidatorSettings) ? coerceUrl(url) : null };\n}\nexports.validateAndFormatURL = validateAndFormatURL;\n/**\n * Finds the image type from a given url\n *\n * @param {string} url - url to be checked\n * @return {string} image type from url\n *\n */\nfunction findImageTypeFromUrl(url) {\n    let type = url.split('.').pop() || '';\n    [type] = type.split('?');\n    return type;\n}\nexports.findImageTypeFromUrl = findImageTypeFromUrl;\n/**\n * Checks if image type is valid\n *\n * @param {string} type - type to be checked\n * @return {boolean} boolean value if type is value\n *\n */\nfunction isImageTypeValid(type) {\n    const validImageTypes = ['apng', 'bmp', 'gif', 'ico', 'cur', 'jpg', 'jpeg', 'jfif', 'pjpeg', 'pjp', 'png', 'svg', 'tif', 'tiff', 'webp'];\n    return validImageTypes.includes(type);\n}\nexports.isImageTypeValid = isImageTypeValid;\n/**\n * Checks if URL is a non html page\n *\n * @param {string} url - url to be checked\n * @return {boolean} boolean value if url is non html\n *\n */\nfunction isThisANonHTMLUrl(url) {\n    const invalidImageTypes = ['.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.3gp', '.avi', '.mov', '.mp4', '.m4v', '.m4a', '.mp3', '.mkv', '.ogv', '.ogm', '.ogg', '.oga', '.webm', '.wav', '.bmp', '.gif', '.jpg', '.jpeg', '.png', '.webp', '.zip', '.rar', '.tar', '.tar.gz', '.tgz', '.tar.bz2', '.tbz2', '.txt', '.pdf'];\n    const extension = findImageTypeFromUrl(url);\n    return invalidImageTypes.some((type) => `.${extension}`.includes(type));\n}\nexports.isThisANonHTMLUrl = isThisANonHTMLUrl;\n/**\n * Find and delete nested undefs\n *\n * @param {object} object - object to be cleaned\n * @return {object} object without nested undefs\n *\n */\nfunction removeNestedUndefinedValues(object) {\n    Object.entries(object).forEach(([key, value]) => {\n        if (value && typeof value === 'object')\n            removeNestedUndefinedValues(value);\n        else if (value === undefined)\n            delete object[key];\n    });\n    return object;\n}\nexports.removeNestedUndefinedValues = removeNestedUndefinedValues;\n/**\n * Split the options object into ogs and got option objects\n *\n * @param {object} options - options that need to be split\n * @return {object} object with nested options for ogs and got\n *\n */\nfunction optionSetup(ogsOptions) {\n    const options = {\n        onlyGetOpenGraphInfo: false,\n        ...ogsOptions,\n    };\n    return { options };\n}\nexports.optionSetup = optionSetup;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,WAAW,GAAGF,OAAO,CAACG,2BAA2B,GAAGH,OAAO,CAACI,iBAAiB,GAAGJ,OAAO,CAACK,gBAAgB,GAAGL,OAAO,CAACM,oBAAoB,GAAGN,OAAO,CAACO,oBAAoB,GAAGP,OAAO,CAACQ,UAAU,GAAGR,OAAO,CAACS,2BAA2B,GAAG,KAAK,CAAC;AAClP,MAAMC,WAAW,GAAGf,eAAe,CAACgB,OAAO,CAAC,WAAW,CAAC,CAAC;AACzDX,OAAO,CAACS,2BAA2B,GAAG;EAClCG,eAAe,EAAE,IAAI;EACrBC,4BAA4B,EAAE,KAAK;EACnCC,sBAAsB,EAAE,IAAI;EAC5BC,kBAAkB,EAAE,KAAK;EACzBC,iBAAiB,EAAE,KAAK;EACxBC,SAAS,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC;EAC5BC,YAAY,EAAE,IAAI;EAClBC,YAAY,EAAE,KAAK;EACnBC,gBAAgB,EAAE,KAAK;EACvBC,WAAW,EAAE,IAAI;EACjBC,sBAAsB,EAAE,IAAI;EAC5BC,eAAe,EAAE;AACrB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASf,UAAU,CAACgB,GAAG,EAAEC,oBAAoB,EAAE;EAC3C,OAAO,OAAOD,GAAG,KAAK,QAAQ,IAAIA,GAAG,CAACE,MAAM,GAAG,CAAC,IAAIhB,WAAW,CAACiB,OAAO,CAACC,KAAK,CAACJ,GAAG,EAAEC,oBAAoB,CAAC;AAC5G;AACAzB,OAAO,CAACQ,UAAU,GAAGA,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMqB,SAAS,GAAIL,GAAG,IAAM,mBAAmB,CAACM,IAAI,CAACN,GAAG,CAAC,GAAGA,GAAG,GAAI,UAASA,GAAI,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASjB,oBAAoB,CAACiB,GAAG,EAAEC,oBAAoB,EAAE;EACrD,OAAO;IAAED,GAAG,EAAEhB,UAAU,CAACgB,GAAG,EAAEC,oBAAoB,CAAC,GAAGI,SAAS,CAACL,GAAG,CAAC,GAAG;EAAK,CAAC;AACjF;AACAxB,OAAO,CAACO,oBAAoB,GAAGA,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,oBAAoB,CAACkB,GAAG,EAAE;EAC/B,IAAIO,IAAI,GAAGP,GAAG,CAACQ,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,EAAE,IAAI,EAAE;EACrC,CAACF,IAAI,CAAC,GAAGA,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC;EACxB,OAAOD,IAAI;AACf;AACA/B,OAAO,CAACM,oBAAoB,GAAGA,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,gBAAgB,CAAC0B,IAAI,EAAE;EAC5B,MAAMG,eAAe,GAAG,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC;EACxI,OAAOA,eAAe,CAACC,QAAQ,CAACJ,IAAI,CAAC;AACzC;AACA/B,OAAO,CAACK,gBAAgB,GAAGA,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,iBAAiB,CAACoB,GAAG,EAAE;EAC5B,MAAMY,iBAAiB,GAAG,CAAC,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,UAAU,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC;EAChU,MAAMC,SAAS,GAAG/B,oBAAoB,CAACkB,GAAG,CAAC;EAC3C,OAAOY,iBAAiB,CAACE,IAAI,CAAEP,IAAI,IAAM,IAAGM,SAAU,EAAC,CAACF,QAAQ,CAACJ,IAAI,CAAC,CAAC;AAC3E;AACA/B,OAAO,CAACI,iBAAiB,GAAGA,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,2BAA2B,CAACoC,MAAM,EAAE;EACzCzC,MAAM,CAAC0C,OAAO,CAACD,MAAM,CAAC,CAACE,OAAO,CAAC,QAAkB;IAAA,IAAjB,CAACC,GAAG,EAAEzC,KAAK,CAAC;IACxC,IAAIA,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAClCE,2BAA2B,CAACF,KAAK,CAAC,CAAC,KAClC,IAAIA,KAAK,KAAK0C,SAAS,EACxB,OAAOJ,MAAM,CAACG,GAAG,CAAC;EAC1B,CAAC,CAAC;EACF,OAAOH,MAAM;AACjB;AACAvC,OAAO,CAACG,2BAA2B,GAAGA,2BAA2B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,WAAW,CAAC0C,UAAU,EAAE;EAC7B,MAAMC,OAAO,GAAG;IACZC,oBAAoB,EAAE,KAAK;IAC3B,GAAGF;EACP,CAAC;EACD,OAAO;IAAEC;EAAQ,CAAC;AACtB;AACA7C,OAAO,CAACE,WAAW,GAAGA,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}