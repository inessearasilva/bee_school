{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * \r\n * @emails oncall+draft_js\r\n */\n'use strict';\n\nvar DraftEntitySegments = require(\"./DraftEntitySegments\");\nvar getRangesForDraftEntity = require(\"./getRangesForDraftEntity\");\nvar invariant = require(\"fbjs/lib/invariant\");\n/**\r\n * Given a SelectionState and a removal direction, determine the entire range\r\n * that should be removed from a ContentState. This is based on any entities\r\n * within the target, with their `mutability` values taken into account.\r\n *\r\n * For instance, if we are attempting to remove part of an \"immutable\" entity\r\n * range, the entire entity must be removed. The returned `SelectionState`\r\n * will be adjusted accordingly.\r\n */\n\nfunction getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n  var startEntityKey = startBlock.getEntityAt(start);\n  var endEntityKey = endBlock.getEntityAt(end - 1);\n  if (!startEntityKey && !endEntityKey) {\n    return selectionState;\n  }\n  var newSelectionState = selectionState;\n  if (startEntityKey && startEntityKey === endEntityKey) {\n    newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);\n  } else if (startEntityKey && endEntityKey) {\n    var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n    var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: startSelectionState.getAnchorOffset(),\n      focusOffset: endSelectionState.getFocusOffset(),\n      isBackward: false\n    });\n  } else if (startEntityKey) {\n    var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: _startSelectionState.getStartOffset(),\n      isBackward: false\n    });\n  } else if (endEntityKey) {\n    var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n    newSelectionState = newSelectionState.merge({\n      focusOffset: _endSelectionState.getEndOffset(),\n      isBackward: false\n    });\n  }\n  return newSelectionState;\n}\nfunction getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n  var entity = entityMap.__get(entityKey);\n  var mutability = entity.getMutability();\n  var sideToConsider = isEntityAtStart ? start : end; // `MUTABLE` entities can just have the specified range of text removed\n  // directly. No adjustments are needed.\n\n  if (mutability === 'MUTABLE') {\n    return selectionState;\n  } // Find the entity range that overlaps with our removal range.\n\n  var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function (range) {\n    return sideToConsider <= range.end && sideToConsider >= range.start;\n  });\n  !(entityRanges.length == 1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'There should only be one entity range within this removal range.') : invariant(false) : void 0;\n  var entityRange = entityRanges[0]; // For `IMMUTABLE` entity types, we will remove the entire entity range.\n\n  if (mutability === 'IMMUTABLE') {\n    return selectionState.merge({\n      anchorOffset: entityRange.start,\n      focusOffset: entityRange.end,\n      isBackward: false\n    });\n  } // For `SEGMENTED` entity types, determine the appropriate segment to\n  // remove.\n\n  if (!isEntireSelectionWithinEntity) {\n    if (isEntityAtStart) {\n      end = entityRange.end;\n    } else {\n      start = entityRange.start;\n    }\n  }\n  var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);\n  return selectionState.merge({\n    anchorOffset: removalRange.start,\n    focusOffset: removalRange.end,\n    isBackward: false\n  });\n}\nmodule.exports = getCharacterRemovalRange;","map":{"version":3,"names":["DraftEntitySegments","require","getRangesForDraftEntity","invariant","getCharacterRemovalRange","entityMap","startBlock","endBlock","selectionState","direction","start","getStartOffset","end","getEndOffset","startEntityKey","getEntityAt","endEntityKey","newSelectionState","getEntityRemovalRange","startSelectionState","endSelectionState","merge","anchorOffset","getAnchorOffset","focusOffset","getFocusOffset","isBackward","_startSelectionState","_endSelectionState","block","entityKey","isEntireSelectionWithinEntity","isEntityAtStart","entity","__get","mutability","getMutability","sideToConsider","entityRanges","filter","range","length","process","env","NODE_ENV","entityRange","removalRange","getRemovalRange","getText","slice","module","exports"],"sources":["C:/Users/ines_/Desktop/fisiosys/fisiosys/frontend/node_modules/protected-aidaforms/node_modules/draft-js/lib/getCharacterRemovalRange.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * \r\n * @emails oncall+draft_js\r\n */\r\n'use strict';\r\n\r\nvar DraftEntitySegments = require(\"./DraftEntitySegments\");\r\n\r\nvar getRangesForDraftEntity = require(\"./getRangesForDraftEntity\");\r\n\r\nvar invariant = require(\"fbjs/lib/invariant\");\r\n/**\r\n * Given a SelectionState and a removal direction, determine the entire range\r\n * that should be removed from a ContentState. This is based on any entities\r\n * within the target, with their `mutability` values taken into account.\r\n *\r\n * For instance, if we are attempting to remove part of an \"immutable\" entity\r\n * range, the entire entity must be removed. The returned `SelectionState`\r\n * will be adjusted accordingly.\r\n */\r\n\r\n\r\nfunction getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {\r\n  var start = selectionState.getStartOffset();\r\n  var end = selectionState.getEndOffset();\r\n  var startEntityKey = startBlock.getEntityAt(start);\r\n  var endEntityKey = endBlock.getEntityAt(end - 1);\r\n\r\n  if (!startEntityKey && !endEntityKey) {\r\n    return selectionState;\r\n  }\r\n\r\n  var newSelectionState = selectionState;\r\n\r\n  if (startEntityKey && startEntityKey === endEntityKey) {\r\n    newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);\r\n  } else if (startEntityKey && endEntityKey) {\r\n    var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\r\n    var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\r\n    newSelectionState = newSelectionState.merge({\r\n      anchorOffset: startSelectionState.getAnchorOffset(),\r\n      focusOffset: endSelectionState.getFocusOffset(),\r\n      isBackward: false\r\n    });\r\n  } else if (startEntityKey) {\r\n    var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\r\n\r\n    newSelectionState = newSelectionState.merge({\r\n      anchorOffset: _startSelectionState.getStartOffset(),\r\n      isBackward: false\r\n    });\r\n  } else if (endEntityKey) {\r\n    var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\r\n\r\n    newSelectionState = newSelectionState.merge({\r\n      focusOffset: _endSelectionState.getEndOffset(),\r\n      isBackward: false\r\n    });\r\n  }\r\n\r\n  return newSelectionState;\r\n}\r\n\r\nfunction getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {\r\n  var start = selectionState.getStartOffset();\r\n  var end = selectionState.getEndOffset();\r\n\r\n  var entity = entityMap.__get(entityKey);\r\n\r\n  var mutability = entity.getMutability();\r\n  var sideToConsider = isEntityAtStart ? start : end; // `MUTABLE` entities can just have the specified range of text removed\r\n  // directly. No adjustments are needed.\r\n\r\n  if (mutability === 'MUTABLE') {\r\n    return selectionState;\r\n  } // Find the entity range that overlaps with our removal range.\r\n\r\n\r\n  var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function (range) {\r\n    return sideToConsider <= range.end && sideToConsider >= range.start;\r\n  });\r\n  !(entityRanges.length == 1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'There should only be one entity range within this removal range.') : invariant(false) : void 0;\r\n  var entityRange = entityRanges[0]; // For `IMMUTABLE` entity types, we will remove the entire entity range.\r\n\r\n  if (mutability === 'IMMUTABLE') {\r\n    return selectionState.merge({\r\n      anchorOffset: entityRange.start,\r\n      focusOffset: entityRange.end,\r\n      isBackward: false\r\n    });\r\n  } // For `SEGMENTED` entity types, determine the appropriate segment to\r\n  // remove.\r\n\r\n\r\n  if (!isEntireSelectionWithinEntity) {\r\n    if (isEntityAtStart) {\r\n      end = entityRange.end;\r\n    } else {\r\n      start = entityRange.start;\r\n    }\r\n  }\r\n\r\n  var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);\r\n  return selectionState.merge({\r\n    anchorOffset: removalRange.start,\r\n    focusOffset: removalRange.end,\r\n    isBackward: false\r\n  });\r\n}\r\n\r\nmodule.exports = getCharacterRemovalRange;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,IAAIA,mBAAmB,GAAGC,OAAO,CAAC,uBAAuB,CAAC;AAE1D,IAAIC,uBAAuB,GAAGD,OAAO,CAAC,2BAA2B,CAAC;AAElE,IAAIE,SAAS,GAAGF,OAAO,CAAC,oBAAoB,CAAC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASG,wBAAwB,CAACC,SAAS,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,cAAc,EAAEC,SAAS,EAAE;EAC5F,IAAIC,KAAK,GAAGF,cAAc,CAACG,cAAc,EAAE;EAC3C,IAAIC,GAAG,GAAGJ,cAAc,CAACK,YAAY,EAAE;EACvC,IAAIC,cAAc,GAAGR,UAAU,CAACS,WAAW,CAACL,KAAK,CAAC;EAClD,IAAIM,YAAY,GAAGT,QAAQ,CAACQ,WAAW,CAACH,GAAG,GAAG,CAAC,CAAC;EAEhD,IAAI,CAACE,cAAc,IAAI,CAACE,YAAY,EAAE;IACpC,OAAOR,cAAc;EACvB;EAEA,IAAIS,iBAAiB,GAAGT,cAAc;EAEtC,IAAIM,cAAc,IAAIA,cAAc,KAAKE,YAAY,EAAE;IACrDC,iBAAiB,GAAGC,qBAAqB,CAACb,SAAS,EAAEC,UAAU,EAAEW,iBAAiB,EAAER,SAAS,EAAEK,cAAc,EAAE,IAAI,EAAE,IAAI,CAAC;EAC5H,CAAC,MAAM,IAAIA,cAAc,IAAIE,YAAY,EAAE;IACzC,IAAIG,mBAAmB,GAAGD,qBAAqB,CAACb,SAAS,EAAEC,UAAU,EAAEW,iBAAiB,EAAER,SAAS,EAAEK,cAAc,EAAE,KAAK,EAAE,IAAI,CAAC;IACjI,IAAIM,iBAAiB,GAAGF,qBAAqB,CAACb,SAAS,EAAEE,QAAQ,EAAEU,iBAAiB,EAAER,SAAS,EAAEO,YAAY,EAAE,KAAK,EAAE,KAAK,CAAC;IAC5HC,iBAAiB,GAAGA,iBAAiB,CAACI,KAAK,CAAC;MAC1CC,YAAY,EAAEH,mBAAmB,CAACI,eAAe,EAAE;MACnDC,WAAW,EAAEJ,iBAAiB,CAACK,cAAc,EAAE;MAC/CC,UAAU,EAAE;IACd,CAAC,CAAC;EACJ,CAAC,MAAM,IAAIZ,cAAc,EAAE;IACzB,IAAIa,oBAAoB,GAAGT,qBAAqB,CAACb,SAAS,EAAEC,UAAU,EAAEW,iBAAiB,EAAER,SAAS,EAAEK,cAAc,EAAE,KAAK,EAAE,IAAI,CAAC;IAElIG,iBAAiB,GAAGA,iBAAiB,CAACI,KAAK,CAAC;MAC1CC,YAAY,EAAEK,oBAAoB,CAAChB,cAAc,EAAE;MACnDe,UAAU,EAAE;IACd,CAAC,CAAC;EACJ,CAAC,MAAM,IAAIV,YAAY,EAAE;IACvB,IAAIY,kBAAkB,GAAGV,qBAAqB,CAACb,SAAS,EAAEE,QAAQ,EAAEU,iBAAiB,EAAER,SAAS,EAAEO,YAAY,EAAE,KAAK,EAAE,KAAK,CAAC;IAE7HC,iBAAiB,GAAGA,iBAAiB,CAACI,KAAK,CAAC;MAC1CG,WAAW,EAAEI,kBAAkB,CAACf,YAAY,EAAE;MAC9Ca,UAAU,EAAE;IACd,CAAC,CAAC;EACJ;EAEA,OAAOT,iBAAiB;AAC1B;AAEA,SAASC,qBAAqB,CAACb,SAAS,EAAEwB,KAAK,EAAErB,cAAc,EAAEC,SAAS,EAAEqB,SAAS,EAAEC,6BAA6B,EAAEC,eAAe,EAAE;EACrI,IAAItB,KAAK,GAAGF,cAAc,CAACG,cAAc,EAAE;EAC3C,IAAIC,GAAG,GAAGJ,cAAc,CAACK,YAAY,EAAE;EAEvC,IAAIoB,MAAM,GAAG5B,SAAS,CAAC6B,KAAK,CAACJ,SAAS,CAAC;EAEvC,IAAIK,UAAU,GAAGF,MAAM,CAACG,aAAa,EAAE;EACvC,IAAIC,cAAc,GAAGL,eAAe,GAAGtB,KAAK,GAAGE,GAAG,CAAC,CAAC;EACpD;;EAEA,IAAIuB,UAAU,KAAK,SAAS,EAAE;IAC5B,OAAO3B,cAAc;EACvB,CAAC,CAAC;;EAGF,IAAI8B,YAAY,GAAGpC,uBAAuB,CAAC2B,KAAK,EAAEC,SAAS,CAAC,CAACS,MAAM,CAAC,UAAUC,KAAK,EAAE;IACnF,OAAOH,cAAc,IAAIG,KAAK,CAAC5B,GAAG,IAAIyB,cAAc,IAAIG,KAAK,CAAC9B,KAAK;EACrE,CAAC,CAAC;EACF,EAAE4B,YAAY,CAACG,MAAM,IAAI,CAAC,CAAC,GAAGC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAGzC,SAAS,CAAC,KAAK,EAAE,kEAAkE,CAAC,GAAGA,SAAS,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;EACtL,IAAI0C,WAAW,GAAGP,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;;EAEnC,IAAIH,UAAU,KAAK,WAAW,EAAE;IAC9B,OAAO3B,cAAc,CAACa,KAAK,CAAC;MAC1BC,YAAY,EAAEuB,WAAW,CAACnC,KAAK;MAC/Bc,WAAW,EAAEqB,WAAW,CAACjC,GAAG;MAC5Bc,UAAU,EAAE;IACd,CAAC,CAAC;EACJ,CAAC,CAAC;EACF;;EAGA,IAAI,CAACK,6BAA6B,EAAE;IAClC,IAAIC,eAAe,EAAE;MACnBpB,GAAG,GAAGiC,WAAW,CAACjC,GAAG;IACvB,CAAC,MAAM;MACLF,KAAK,GAAGmC,WAAW,CAACnC,KAAK;IAC3B;EACF;EAEA,IAAIoC,YAAY,GAAG9C,mBAAmB,CAAC+C,eAAe,CAACrC,KAAK,EAAEE,GAAG,EAAEiB,KAAK,CAACmB,OAAO,EAAE,CAACC,KAAK,CAACJ,WAAW,CAACnC,KAAK,EAAEmC,WAAW,CAACjC,GAAG,CAAC,EAAEiC,WAAW,CAACnC,KAAK,EAAED,SAAS,CAAC;EAC3J,OAAOD,cAAc,CAACa,KAAK,CAAC;IAC1BC,YAAY,EAAEwB,YAAY,CAACpC,KAAK;IAChCc,WAAW,EAAEsB,YAAY,CAAClC,GAAG;IAC7Bc,UAAU,EAAE;EACd,CAAC,CAAC;AACJ;AAEAwB,MAAM,CAACC,OAAO,GAAG/C,wBAAwB"},"metadata":{},"sourceType":"script","externalDependencies":[]}